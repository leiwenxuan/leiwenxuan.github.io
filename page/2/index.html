<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>雷文轩</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="keywords" content="网站关键字, key, key1, key2, key3">
<meta property="og:type" content="website">
<meta property="og:title" content="雷文轩">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="雷文轩">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="雷文轩">
  
    <link rel="alternate" href="/atom.xml" title="雷文轩" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">雷文轩</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-操作系统与进程的基础概念" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/02/操作系统与进程的基础概念/" class="article-date">
  <time datetime="2018-10-02T04:24:39.008Z" itemprop="datePublished">2018-10-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/python/">python</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/02/操作系统与进程的基础概念/">操作系统和进程的基础概念</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#操作系统的发展史</p>
<p>##手工操作 —— 穿孔卡片      </p>
<p>###手工操作的两个特点：<br>    1：用户独占全机， 不会出现因资源一杯其他用户占用而等待的现象， 但是资源利用率低<br>    2：cup等待手工操作。 CPU的利用不充分</p>
<p>##批处理 —— 磁带存储和批处理系统、</p>
<p>###批处理系统：加载在计算机上的一个系统软件， 在他的控制下， 计算机能够自动的， 成批地处理有个或者多个用户的作业</p>
<p>###卫星机：<br>    一台不与主机直接相连而用于输出输入设备打交道<br>    其功能：<br>        1：输入机上读取用户作业并放到磁带上<br>        2：从输入磁带上读取执行结果给打印机<br>    不足：每次主机内存中仅存放到一道作业， 每当它运行期间输入、输出请求后， 高速的CPU变处于等待低速的IO完成状态致使CPU空闲</p>
<p>##多道程序系统<br><img src="https://i.imgur.com/DU9G0m7.png" alt=""></p>
<p>###所谓的多道程序设计技术， 就是指允许多个程序进入内存并允许。 即把多个程序放入内存。他们在内存中交替运行。共享系统资源。一道程序运行结束立马转向去另一个。</p>
<p>###单机处理系统中的多道程序运行的特点：<br>    1：多道：计算机内部放入多道程序<br>    2:宏观上的并行： 同时进入系统的几道程序都处于运行过程中，都开始运行，但都为运行完毕<br>    3：微观上串性：各道程序轮流的用CPU， 交替运行</p>
<p>##多道批处理系统</p>
<p>##分时系统</p>
<p>##实时系统</p>
<p>##通用操作系统</p>
<p>##操作系统的进一步发展</p>
<p>##操作系统的作用</p>
<p>I/O ：input 进入内存的过程就是输入<br>    ：ouput 数据从内存从内存出去的过程就是输出 （写文件， dump， send）</p>
<p>##多道操作系统<br>    可以有多个程序在操作系统中执行<br>    当一个程序遇到IO操作时候就把CPU让出来给其他程序</p>
<p>###分时操作系统</p>
<pre><code>#时间片 特别短的时间
#不是遇到IO的时候才让出CPU， 而是时间到了就将CPU让出来
#切换要占时间：单纯的分时系统没有提高CPU的利用率
                提高了用户体验
</code></pre><p>###实时系统</p>
<p>###个人计算机<br>    python celery 分布式计算</p>
<p>##进程 Process id = pid<br>程序  进程<br>pid 是全系统</p>
<p>进程是操作系统最小的资源分配单位</p>
<p>资源分配  — 内存 寄存器</p>
<p>多级反馈附列<br>    先把短的执行， 长任务放到队列下面</p>
<p>同步阻塞： 不能充分利用CPU<br>异步非阻塞： 过度利用CPU</p>
<p>IO多路复用：比较完善的在网络编程中的解决方案</p>
<h2 id="if-name-‘name‘"><a href="#if-name-‘name‘" class="headerlink" title="if name == ‘name‘:"></a>if <strong>name</strong> == ‘<strong>name</strong>‘:</h2><pre><code>只有在winds上才需要
</code></pre><p>1：父进程和子进程的启动时异步的<br>父进程只负责通知操作系统启动子进程<br>接下来的工作由操作系统接手，父进程继续执行<br>2：父进程执行完毕后并不会直接结束程序<br>而是等待所有的子进程都执行完毕后才结束<br>父进程要负责回收子进程的资源</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/10/02/操作系统与进程的基础概念/" data-id="cjn6hbtxe000z80u84qdxwtkg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-socket" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/02/socket/" class="article-date">
  <time datetime="2018-10-02T04:24:38.992Z" itemprop="datePublished">2018-10-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/python/">python</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/02/socket/">socke</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#1：网络编程之socketserver</p>
<p>###1:首先socketserver 服务器调用socketserver 模块</p>
<p>###2:继承了socketserver.BaseRequestHandler</p>
<p>###3:在父类的基础上重写了handle</p>
<p>##下面是一个简单的文件登录文件上传的例子</p>
<p>###server端<br>    import socketserver<br>    import json<br>    import struct<br>    import socket</p>
<pre><code>class MyTCPHandler(socketserver.BaseRequestHandler):


def handle(self):
    flag = self.login_check()
    while flag:
        try:
            self.data = self.request.recv(1024).strip()
            print(&apos;{} wrote&apos;.format(self.client_address[0]))
            print(self.data)
            self.request.send(self.data.upper())
            print(self.data.decode(&apos;utf-8&apos;))
            if self.data.decode(&apos;utf-8&apos;) == &apos;2&apos;:
                self.uploading()

        except ConnectionResetError as e:
            print(&apos;error&apos;, e)
            break

def login_check(self):
    dic_user = {
        &apos;name&apos;: &apos;qwer&apos;,
        &apos;pwad&apos;: &apos;1234&apos;
    }
    dic_clinet = self.request.recv(1024).strip()
    dic_clinet = json.loads(dic_clinet)
    print(dic_clinet)
    if dic_user[&apos;name&apos;] == dic_clinet[&apos;name&apos;] and \
            dic_user[&apos;pwad&apos;] == dic_clinet[&apos;pwad&apos;]:
        self.request.send(b&apos;True&apos;)
        return True

def uploading(self):
    &apos;&apos;&apos;接受上传文件&apos;&apos;&apos;
    ret = self.request.recv(1024)
    dic_client = json.loads(ret)
    print(dic_client)
    self.request.send(b&apos;Start To upload&apos;)
    print(&apos;Start the download&apos;)
    size = dic_client[&apos;size&apos;]
    with open(dic_client[&apos;filename&apos;],&apos;wb&apos;) as f:
        while size:
            ret = self.request.recv(1024)
            f.write(ret)
            size -= len(ret)
    print(&apos;下载完毕！&apos;)



if __name__ == &apos;__main__&apos;:
    Host, port = &apos;127.0.0.1&apos;, 9999
    # sever = socketserver.TCPServer((Host, port), MyTCPHandler)
    sever = socketserver.ThreadingTCPServer((Host, port), MyTCPHandler)
    sever.serve_forever()
</code></pre><p>###client端</p>
<pre><code>import socket
import json
import os
import sys
import time

#进度条
import time
from tqdm import tqdm

# for i in tqdm(range(100)):
#     time.sleep(0.05)

def processBar(num, total):

    rate = num / total
    rate_num = int(rate * 100)
    if rate_num == 100:
        r = &apos;\r%s&gt;%d%%\n&apos; % (&apos;|&apos; * rate_num, rate_num,)
    else:
        r = &apos;\r%s&gt;%d%%&apos; % (&apos;|&apos; * rate_num, rate_num,)
    sys.stdout.write(r)
    sys.stdout.flush


class Client():
    &apos;&apos;&apos;客户端&apos;&apos;&apos;
    cmd_list = [
        (&apos;下载文件&apos;, &apos;ncftpget&apos;),
        (&apos;上传文件&apos;, &apos;upload&apos;),
        (&apos;切换目录&apos;, &apos;chdir&apos;),
        (&apos;创建目录&apos;, &apos;create_directory&apos;),
        (&apos;删除文件或者目录&apos;,&apos;expurgate &apos;),
    ]
    def __init__(self):
        self.client = socket.socket() #实例socket对象
    def connect(self, ip, port):
        &apos;&apos;&apos;绑定端口&apos;&apos;&apos;
        self.client.connect((ip, port))
    def logon(self):
        &apos;&apos;&apos;用户登录&apos;&apos;&apos;
        name = input(&apos;user_name:&apos;)
        pawd = input(&apos;passwork:&apos;)
        user_dic = {
            &apos;name&apos;: name,
            &apos;pwad&apos;: pawd
        }
        self.client.send(json.dumps(user_dic).encode(&apos;utf-8&apos;))
        ret = self.client.recv(1024).decode(&apos;utf-8&apos;)
        print(ret)
        return ret
    def User_input(self):
        flag = self.logon()
        name_path = &apos;/home/&apos;
        while flag:
            for index, val in enumerate(self.cmd_list, 1):
                print(&apos;%s  %s&apos;%(index, val[0]))
            inp = input(&apos;%s:&apos;%name_path)
            self.client.send(inp.encode(&apos;utf-8&apos;))
            ret = self.client.recv(1024).decode(&apos;utf-8&apos;)
            if inp == &apos;2&apos;:
                self.upload()

        else:
            print(&apos;密码错误！&apos;)

    def ncftpget(self):
        &apos;&apos;&apos;下载文件&apos;&apos;&apos;
    def upload(self):
        &apos;&apos;&apos;上传文件&apos;&apos;&apos;
        path_name = r&apos;G:\python笔记\Pythonjing\day18\video\01 深圳校区 python fullstuck 1期 day18 内容回顾.mp4&apos;
        size = os.path.getsize(path_name)
        print(size)
        total = size
        dic_user = {
            &apos;means&apos;: &apos;uploading&apos;,
            &apos;filename&apos;: &apos;test.mp4&apos;,
            &apos;size&apos;: size,
        }
        self.client.send(json.dumps(dic_user).encode(&apos;utf-8&apos;))
        ret = self.client.recv(1024)
        print(ret)
        with open(path_name, &apos;rb&apos;) as f:
            count = 0
            time_old = time.clock()
            pbar = tqdm(total=size)
            while size:
                data = f.read(1024)
                self.client.send(data)
                size -= len(data)
                count += len(data)

                pbar.update(len(data)) #进度条

                # processBar(count, total) #进度条
            time_new = time.clock()
            pbar.close()
            print(&apos;上传完毕！一个用时%s秒&apos;%int(time_new - time_old))


    def chdir(self):
        &apos;&apos;&apos;切换目录&apos;&apos;&apos;
    def create_directory(self):
        &apos;&apos;&apos;创建目录&apos;&apos;&apos;
    def expurgate(self):
        &apos;&apos;&apos;删除文件或者文件夹&apos;&apos;&apos;

if __name__ == &apos;__main__&apos;:
    # Host, port = &apos;127.0.0.1&apos;, 9999
    Host, port = &apos;192.168.16.46&apos;, 9999
    cl = Client()
    cl.connect(Host, port)
    cl.User_input()
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/10/02/socket/" data-id="cjn6hbtwy000i80u80axce15b" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-multiprocess进程-锁-信号量-事件" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/02/multiprocess进程-锁-信号量-事件/" class="article-date">
  <time datetime="2018-10-02T04:24:38.979Z" itemprop="datePublished">2018-10-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/python/">python</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/02/multiprocess进程-锁-信号量-事件/">multiprocessing模块</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>##1.1：process模块介绍</p>
<p>###具体方法<br>    p.start()：启动进程，并调用该子进程中的p.run()<br>    p.run():进程启动时运行的方法，正是它去调用target指定的函数，我们自定义类的类中一定要实现该方法<br>    p.terminate():强制终止进程p，不会进行任何清理操作，如果p创建了子进程，该子进程就成<br>    了僵尸进程，使用该方法需要特别小心这种情况。如果p还保存了一个锁那么也将不会被释放，进而导致死锁<br>    p.is_alive():如果p仍然运行，返回True<br>    p.join([timeout]):主线程等待p终止（强调：是主线程处于等的状态，而p是处于运行的状态）。<br>    timeout是可选的超时时间，需要强调的是，p.join只能join住start开启的进程，而不能join住run开启的进程  </p>
<p>###具体实现<br>    p.daemon：默认值为False，如果设为True，代表p为后台运行的守护进程，当p的父进程终止时，p也随之终止，并且设定为True后，p不能创建自己的新进程，必须在p.start()之前设置<br>    p.name:进程的名称<br>    p.pid：进程的pid<br>    p.exitcode:进程在运行时为None、如果为–N，表示被信号N结束(了解即可)<br>    p.authkey:进程的身份验证键,默认是由os.urandom()随机生成的32字符的字符串。这个键的用途是为涉及网络连接的底层进程间通信提供安全性，这类连接只有在具有相同的身份验证键时才能成功（了解即可）</p>
<p>###具体代码<br>    import os<br>    from multiprocessing import Process</p>
<pre><code>def f(x):
    print(&apos;子进程id ：&apos;,os.getpid(),&apos;父进程id ：&apos;,os.getppid())
    #查看主进程和子进程的进程号
    return x*x

if __name__ == &apos;__main__&apos;:
    print(&apos;主进程id ：&apos;, os.getpid())
    p_lst = []
    for i in range(5):
        p = Process(target=f, args=(i,))
        p.start()
</code></pre><p>##1.2：守护进程</p>
<pre><code>会随着主进程的结束而结束。
主进程创建守护进程
　　其一：守护进程会在主进程代码执行结束后就终止
　　其二：守护进程内无法再开启子进程,否则抛出异常：AssertionError: daemonic processes are not allowed to have children
注意：进程之间是互相独立的，主进程代码运行结束，守护进程随即终止
</code></pre><p>###具体代码<br>    from multiprocessing import Process<br>    import time<br>    def fun():<br>        while 1:<br>            print(‘守护进程’)<br>            time.sleep(1)<br>    if <strong>name</strong> == ‘<strong>main</strong>‘:<br>        p = Process(target= fun)<br>        p.daemon = True<br>        p.start()<br>        time.sleep(5) #主进程结束守护进程结束</p>
<p>##1.3：multiprocess.Lock</p>
<pre><code>#加锁可以保证多个进程修改同一块数据时，同一时间只能有一个任务可以进行修改，即串行的修改，没错，速度是慢了，但牺牲了速度却保证了数据安全。
虽然可以用文件共享数据实现进程间通信，但问题是：
1.效率低（共享数据基于文件，而文件是硬盘上的数据）
2.需要自己加锁处理

#因此我们最好找寻一种解决方案能够兼顾：1、效率高（多个进程共享一块内存的数据）
2，我们处理好锁问题。这就是mutiprocessing模块为我们提供的基于消息的IPC通信机制：队列和管道。
队列和管道都是将数据存放于内存中
队列又是基于（管道+锁）实现的，可以让我们从复杂的锁问题中解脱出来，
我们应该尽量避免使用共享数据，尽可能使用消息传递和队列，避免处理复杂的同步和锁问题，而且在进程数目增多时，往往可以获得更好的可获展性。
</code></pre><p>###抢票的例子</p>
<pre><code>#文件db的内容为：{&quot;count&quot;:1}
#注意一定要用双引号，不然json无法识别
#并发运行，效率高，但竞争写同一文件，数据写入错乱
from multiprocessing import Process,Lock
import time,json,random
def search():
    dic=json.load(open(&apos;db&apos;))
    print(&apos;\033[43m剩余票数%s\033[0m&apos; %dic[&apos;count&apos;])

def get():
    dic=json.load(open(&apos;db&apos;))
    time.sleep(0.1) #模拟读数据的网络延迟
    if dic[&apos;count&apos;] &gt;0:
        dic[&apos;count&apos;]-=1
        time.sleep(0.2) #模拟写数据的网络延迟
        json.dump(dic,open(&apos;db&apos;,&apos;w&apos;))
        print(&apos;\033[43m购票成功\033[0m&apos;)

def task():
    search()
    get()

if __name__ == &apos;__main__&apos;:
    for i in range(100): #模拟并发100个客户端抢票
        p=Process(target=task)
        p.start()
</code></pre><p>##multiprocess.Semaphore<br>    斥锁同时只允许一个线程更改数据，而信号量Semaphore是同时允许一定数量的线程更改数据 。<br>    假设商场里有4个迷你唱吧，所以同时可以进去4个人，如果来了第五个人就要在外面等待，等到有人出来才能再进去玩。<br>    实现：<br>    信号量同步基于内部计数器，每调用一次acquire()，计数器减1；每调用一次release()，计数器加1.<br>    当计数器为0时，acquire()调用被阻塞。这是迪科斯彻（Dijkstra）信号量概念P()和V()Python实现。信号量同步机制适用于访问像服务器这样的有限资源。<br>    信号量与进程池的概念很像，但是要区分开，信号量涉及到加锁的概念</p>
<p>###具体例子（进KTV）<br>    from multiprocessing import Process,Semaphore<br>    import time,random</p>
<pre><code>def go_ktv(sem,user):
    sem.acquire()
    print(&apos;%s 占到一间ktv小屋&apos; %user)
    time.sleep(random.randint(0,3)) #模拟每个人在ktv中待的时间不同
    sem.release()

if __name__ == &apos;__main__&apos;:
    sem=Semaphore(4)
    p_l=[]
    for i in range(13):
        p=Process(target=go_ktv,args=(sem,&apos;user%s&apos; %i,))
        p.start()
        p_l.append(p)

    for i in p_l:
        i.join()
    print(&apos;============》&apos;)
</code></pre><p>##multiprocess.Event</p>
<p>###介绍<br>    python线程的事件用于主线程控制其他线程的执行，事件主要提供了三个方法 set、wait、clear。</p>
<pre><code>事件处理的机制：全局定义了一个“Flag”，如果“Flag”值为 False，那么当程序执行 event.wait 方法时就会阻塞，如果“Flag”值为True，那么event.wait 方法时便不再阻塞。

clear：将“Flag”设置为False
set：将“Flag”设置为True
</code></pre><p>###红绿灯例子<br>    import time<br>    import random<br>    from multiprocessing import Process,Event<br>    def traffic_light(e):<br>        print(‘\033[31m红灯亮\033[0m’)<br>        while True:<br>            if e.is_set():<br>                time.sleep(2)<br>                print(‘\033[31m红灯亮\033[0m’)<br>                e.clear()<br>            else:<br>                time.sleep(2)<br>                print(‘\033[32m绿灯亮\033[0m’)<br>                e.set()</p>
<pre><code>def car(e,i):
    if not e.is_set():
        print(&apos;car %s 在等待&apos; % i)
        e.wait()
    print(&apos;car %s 通过了&apos;%i)

if __name__ == &apos;__main__&apos;:
    e = Event()
    p = Process(target=traffic_light,args=(e,))
    p.daemon = True
    p.start()
    p_lst = []
    for i in  range(20):
        time.sleep(random.randrange(0,3,2))
        p = Process(target=car,args=(e,i))
        p.start()  # car19
        p_lst.append(p)
    for p in p_lst:p.join()
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/10/02/multiprocess进程-锁-信号量-事件/" data-id="cjn6hbtwo000c80u8491pppr3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-multiprocessing模块" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/02/multiprocessing模块/" class="article-date">
  <time datetime="2018-10-02T04:24:38.971Z" itemprop="datePublished">2018-10-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/python/">python</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/02/multiprocessing模块/">multiprocess进程-锁-信号量-事件</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="创建共享的进程队列，Queue是多进程安全的队列，可以使用Queue实现多进程之间的数据传递。"><a href="#创建共享的进程队列，Queue是多进程安全的队列，可以使用Queue实现多进程之间的数据传递。" class="headerlink" title="创建共享的进程队列，Queue是多进程安全的队列，可以使用Queue实现多进程之间的数据传递。"></a>创建共享的进程队列，Queue是多进程安全的队列，可以使用Queue实现多进程之间的数据传递。</h2><pre><code>Queue([maxsize]) 
创建共享的进程队列。maxsize是队列中允许的最大项数。如果省略此参数，则无大小限制。
底层队列使用管道和锁定实现。另外，还需要运行支持线程以便队列中的数据传输到底层管道中。 
Queue的实例q具有以下方法：

q.get( [ block [ ,timeout ] ] ) 
返回q中的一个项目。如果q为空，此方法将阻塞，直到队列中有项目可用为止。block用于控
制阻塞行为，默认为True. 如果设置为False，将引发Queue.Empty异常（定义在Queue模块
中）。timeout是可选超时时间，用在阻塞模式中。如果在制定的时间间隔内没有项目变为可
用，将引发Queue.Empty异常。

q.get_nowait( ) 
同q.get(False)方法。

q.put(item [, block [,timeout ] ] ) 
将item放入队列。如果队列已满，此方法将阻塞至有空间可用为止。block控制阻塞行为，默
认为True。如果设置为False，将引发Queue.Empty异常（定义在Queue库模块中）。timeout
指定在阻塞模式中等待可用空间的时间长短。超时后将引发Queue.Full异常。

q.qsize() 
返回队列中目前项目的正确数量。此函数的结果并不可靠，因为在返回结果和在稍后程序中使
用结果之间，队列中可能添加或删除了项目。在某些系统上，此方法可能引发NotImplementedError异常。


q.empty() 
如果调用此方法时 q为空，返回True。如果其他进程或线程正在往队列中添加项目，结果不
可靠的。也就是说，在返回和使用结果之间，队列中可能已经加入新的项目。

q.full() 
如果q已满，返回为True. 由于线程的存在，结果也可能是不可靠的（参考q.empty（）方法）。。

方法介绍
</code></pre><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><pre><code>from multiprocessing import Process, Queue
import time
def fun(q):
    print(&apos;my name is li&apos;)
    q.put([&apos;lei&apos;, 1, 2, 3, 4])

if __name__ == &apos;__main__&apos;:
    q = Queue()
    p = Process(target=fun, args=(q,))
    p.start()
    time.sleep(1)
    print(q.get())
</code></pre><h2 id="队里问题，-消费者生产模型"><a href="#队里问题，-消费者生产模型" class="headerlink" title="队里问题， 消费者生产模型"></a>队里问题， 消费者生产模型</h2><pre><code>from multiprocessing import Process, Queue
import time

def producer(q, name, food):
    for i in range(10):
        time.sleep(0.0005)
        print(&apos;%s生产了%s%s&apos; % (name, food,i))
        q.put(food + str(i))

def consume(q, name):
    while 1:
        food = q.get()
        if food is None:break
        print(&apos;%s吃了%s&apos;%(name, food))

if __name__ == &apos;__main__&apos;:
    q = Queue()
    p1 = Process(target=producer, args=(q,&apos;li&apos;,&apos;包子&apos;))
    p1.start()

    p2 = Process(target=consume, args=(q,&apos;alex&apos;))
    p2.daemon = True
    p2.start()
    p1.join() #等p1的原因是先让生产完，防止生产来不及队列里面为空
    q.put(None)
</code></pre><p>#<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></p>
<p>##JoinableQueue 类</p>
<p>###put</p>
<p>###get</p>
<p>###task_done 通知队列已经有一个数据被处理了</p>
<p>###q.join() # 阻塞直到放入队列中所有的数据都被处理掉(有多少个数据就接收到了多少taskdone)</p>
<pre><code>import time
import random
from multiprocessing import Process,JoinableQueue

def consumer(q,name):
    #处理数据
    while 1:
        food = q.get()
        time.sleep(random.uniform(0, 1))
        print(&apos;%s吃了%s&apos;%(name, food))
        q.task_done()

def producer(q, name, food):
    for i in range(10):
        time.sleep(random.uniform(0,1))
        print(&quot;%s生产了%s%s&quot;%(name, food, i))
        q.put(food + str(i))

if __name__ == &apos;__main__&apos;:
    q = JoinableQueue()
    c1 = Process(target=consumer, args=(q, &apos;lei&apos;))
    c1.daemon = True #创建了一个守护进程
    c1.start()

    p1 = Process(target=producer, args=(q, &apos;wuyan&apos;, &apos;煎饼&apos;))
    p1.start()
    p1.join() #等待生产完毕， 保证了队列里面有全部的数据
    q.join() #每次取出数据调用 q.task_done() 当为数据取玩阻塞消失
</code></pre><p>#<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></p>
<h2 id="pipe的端口管理不会随着某一个进程的关闭就关闭"><a href="#pipe的端口管理不会随着某一个进程的关闭就关闭" class="headerlink" title="pipe的端口管理不会随着某一个进程的关闭就关闭"></a>pipe的端口管理不会随着某一个进程的关闭就关闭</h2><h3 id="操作系统来管理进程对这些端口的使用"><a href="#操作系统来管理进程对这些端口的使用" class="headerlink" title="操作系统来管理进程对这些端口的使用"></a>操作系统来管理进程对这些端口的使用</h3><h3 id="left-right"><a href="#left-right" class="headerlink" title="left,right"></a>left,right</h3><h3 id="left-right-1"><a href="#left-right-1" class="headerlink" title="left,right"></a>left,right</h3><h3 id="操作系统管理4个端口-每关闭一个端口计数-1，直到所有的端口都关闭了，"><a href="#操作系统管理4个端口-每关闭一个端口计数-1，直到所有的端口都关闭了，" class="headerlink" title="操作系统管理4个端口  每关闭一个端口计数-1，直到所有的端口都关闭了，"></a>操作系统管理4个端口  每关闭一个端口计数-1，直到所有的端口都关闭了，</h3><h3 id="剩余1个端口的时候-recv就会报错"><a href="#剩余1个端口的时候-recv就会报错" class="headerlink" title="剩余1个端口的时候 recv就会报错"></a>剩余1个端口的时候 recv就会报错</h3><pre><code>from multiprocessing import Pipe, Process

def pipeline(left, right):
    ret = right.recv() #右边接受
    print(&apos;%s&apos;%(ret))

if __name__ == &apos;__main__&apos;:
    left, right = Pipe()
    p = Process(target=pipeline, args=(left, right))
    left.send(&apos;你好，保重&apos;) #左边发送
    p.start()

def pipeline(left, right):
    left.close()
    while 1:
        try:
            print(right.recv())
        except EOFError:
            break
if __name__ == &apos;__main__&apos;:
    left, right = Pipe()
    p = Process(target=pipeline, args=(left, right))
    p.start()
    right.close()
    for i in range(10):
        left.send(i)
    left.close()
</code></pre><p>#<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></p>
<h3 id="为什么要有进程池？"><a href="#为什么要有进程池？" class="headerlink" title="为什么要有进程池？"></a>为什么要有进程池？</h3><pre><code>开启过多的进程并不能提高你的效率，反而会降低效率
</code></pre><h3 id="计算密集型-充分占用CPU-多进程可以充分利用多核"><a href="#计算密集型-充分占用CPU-多进程可以充分利用多核" class="headerlink" title="计算密集型  充分占用CPU 多进程可以充分利用多核"></a>计算密集型  充分占用CPU 多进程可以充分利用多核</h3><pre><code>适合开启多进程，但是不适合开启很多多进程
</code></pre><h3 id="IO密集型-大部分时间都在阻塞队列，而不是在运行状态中"><a href="#IO密集型-大部分时间都在阻塞队列，而不是在运行状态中" class="headerlink" title="IO密集型    大部分时间都在阻塞队列，而不是在运行状态中"></a>IO密集型    大部分时间都在阻塞队列，而不是在运行状态中</h3><pre><code>根本不太适合开启多进程
</code></pre><p><strong>实例化 传参数 进程的个数 cpu/cpu+1<br>提交任务<br>同步提交 apply<br>    返回值 ： 子进程对应函数的返回值<br>    一个一个顺序执行的，并没有任何并发效果<br>异步提交 apply_async<br>    没有返回值，要想所有任务能够顺利的执行完毕<br>        p.close()<br>        p.join() # 必须先close再join，阻塞直到进程池中的所有任务都执行完毕<br>    有返回值的情况下<br>        res.get() # get不能再提交任务之后立刻执行，应该是先提交所有的任务再通过get获取结果<br>    map()方法<br>        异步提交的简化版本<br>        自带close和join方法</strong></p>
<p> #<strong>*</strong><br>    from multiprocessing import Pool<br>    import time<br>    def fun(i):<br>        print(i)<br>    if <strong>name</strong> == ‘<strong>main</strong>‘:<br>        p = Pool(5)<br>        start = time.clock()<br>        for i in range(10000):</p>
<pre><code>    # p.apply_async(func=fun, args=(i,)) #异步提交 1.3874192285529539(时间)
    p.apply(fun, args=(i,)) #通同步提交2.2022746500453803(时间)
p.close() # 关闭进程池，用户不能再向这个池中提交任务了
p.join() # 阻塞，直到进程池中所有的任务都被执行完
end = time.clock()
print(end - start)
</code></pre><p>#<strong>*</strong></p>
<pre><code>from multiprocessing import Pool
import time
def fun(i):
    print(i)
    return i*2
if __name__ == &apos;__main__&apos;:
    p = Pool(5)
    start = time.clock()
    p_lis = []
    for i in range(10000):
        ret = p.apply_async(func=fun, args=(i,)) #异步提交 1.3874192285529539(时间)
        p_lis.append(ret)
         # p.apply(fun, args=(i,)) #通同步提交2.2022746500453803(时间)
    p.close() # 关闭进程池，用户不能再向这个池中提交任务了
    p.join() # 阻塞，直到进程池中所有的任务都被执行完
    for ret in p_lis:
        print(ret.get()) #取出进程里面的返回值
    end = time.clock()
    print(end - start)
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/10/02/multiprocessing模块/" data-id="cjn6hbtwt000g80u8z2si9rz5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-异常处理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/02/异常处理/" class="article-date">
  <time datetime="2018-10-02T04:24:38.954Z" itemprop="datePublished">2018-10-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/python/">python</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/02/异常处理/">异常处理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>##1：初始异常</p>
<p>###即便是放在try语句中的内容，在遇到报错之后也会中断这段语句的执行</p>
<p>####1.1 类型异常<br>    l = [‘登录’, ‘注册’]<br>    try:<br>        num = int(input(‘input :’)) #输入：非数字报错 invalid literal for int() with base 10: ‘j’<br>    except ValueError:<br>        print(‘异常：num’)</p>
<p>####1.2列表索引异常<br>    try:<br>        num = int(input(‘input:’))<br>        print(l[num -1]) #输入数字大于2 IndexError: list index out of range<br>    except IndexError:<br>        print(‘异常：索引超标!’)</p>
<p>####1.3多分支异常<br>    try:<br>        num = int(input(‘input: ‘))<br>        print(l[num-1])<br>    except IndexError:<br>        print(‘索引越界！’)<br>    except ValueError:<br>        print(‘类型有误！’)</p>
<p>####1.4多异常<br>    try:<br>           num = int(input(‘input:’))<br>          print(l[num -1])<br>    except (ValueError, IndexError):<br>          print(‘报错！’)</p>
<p>####1.5万能异常</p>
<pre><code>try:
    l = []
    # l[3]
    open(&apos;aaa&apos;)
except Exception:
    print(&apos;异常！&apos;)
</code></pre><p>####1.6 as 异常<br>    try:<br>        l[3] #list index out of range<br>        name #name ‘name’ is not defined<br>    except Exception as e:<br>        print(e) #抛出异常的内容</p>
<p>####1.7 多异常加万能异常<br>    try:<br>        num = int(input(‘input :’))<br>        print(l[num -1])<br>    except (ValueError, IndexError):<br>        print(‘异常！’) #持性了这里下面的将不在执行<br>    except Exception as e:<br>        print(e)</p>
<p>##2：异常的其他处理机制</p>
<p>####2.1 else 机制<br>    try:<br>        print(‘My name is Dan’)<br>    except ValueError:<br>        print(‘name is leiwenxuan’)<br>    else:<br>        print(‘出错了’) #报错将不执行, 没触发异常将执行</p>
<p>###2.2finally</p>
<pre><code>try:
    name #异常
    print(&apos;hello !&apos;)
except NameError:
    print(&apos;报错！&apos;)
finally:
    print(&apos;你好！&apos;) #无论异常处不触发都执行
# finally 无论如何都要执行
# 收尾工作，打开了一个文件，占用了一个网络资源，打开了一个和数据库的链接

try:
    f = open(&apos;content&apos;)
    name #即使报错了，也执行finally
finally:
    f.close()
    print(&apos;执行了！&apos;)
</code></pre><p>###2.3 强制异常<br>    raise NameError(‘name’)<br>    raise NameError</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/10/02/异常处理/" data-id="cjn6hbtxd000x80u86t2l0ydu" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-协程，线程池" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/02/协程，线程池/" class="article-date">
  <time datetime="2018-10-02T04:24:38.924Z" itemprop="datePublished">2018-10-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/python/">python</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/02/协程，线程池/">协程，线程池</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>标签（空格分隔）：线程池/协程</p>
<p>#线程池</p>
<p>###concurrent.futures模块提供了一个用于异步执行callables的高级接口。</p>
<p>##<strong>concurrent.futures.ThreadPoolExecutor</strong></p>
<p>###submit（fn，* args，** kwargs ）<br>将可调用的fn调度为执行， 并返回表示可调用执行的对象</p>
<pre><code>from concurrent.futures import ThreadPoolExecutor
def fun(i):
    print(&apos;my name is %s&apos;%i)
t = ThreadPoolExecutor(5)
for i in range(10):
    ret = t.submit(fun, i)
    #返回一个可执行的对象 &lt;Future at 0x7f2da90c3e10 state=pending&gt;
</code></pre><p>###<strong>shutdown(wait=True) </strong><br>相当于进程池的pool.close()+pool.join()操作<br>wait=True，等待池内所有任务执行完毕回收完资源后才继续<br>wait=False，立即返回，并不会等待池内的任务执行完毕<br>但不管wait参数为何值，整个程序都会等到所有任务执行完毕<br>submit和map必须在shutdown之前</p>
<p>####具体代码</p>
<pre><code>def fun(i):
print(&apos;my name is %s&apos;%i)
return i*2
t = ThreadPoolExecutor(5)
for i in range(10):
    ret = t.submit(fun, i)
    print(ret.result()) #查看返回的结果
t.shutdown() #表示线程都执行完毕
print(&apos;主进程结束&apos;)
</code></pre><p>###map  取代for循环submit的操作</p>
<pre><code>from concurrent.futures import ThreadPoolExecutor
def fun(i):
    print(&apos;my name is %s&apos;%i)
    return i*2
t = ThreadPoolExecutor(5)
res = map(fun, range(20))
for i in res:print(i)
</code></pre><p>##ProcessPoolExecutor<br>它是Executor使用的过程池异步执行调用子类。 ProcessPoolExecutor使用该multiprocessing模块，它允许它侧向全局解释器锁定，但也意味着只能执行和返回可选对象。<br>该<strong>main</strong>模块必须可由工作程序子进程导入。这意味着ProcessPoolExecutor在交互式解释器中不起作用。</p>
<p>###简单的回调函数</p>
<pre><code>from concurrent.futures import ProcessPoolExecutor
def fun(i):
    print(i)
    return i*2
def call_back(arg):
    print(&apos;call back:&apos;, arg.result())
if __name__ == &apos;__main__&apos;:
    p = ProcessPoolExecutor()
    for i in range(20):
        p.submit(fun, i).add_done_callback(call_back)
    print(&apos;主线程&apos;)
</code></pre><p>##××××××××××××××××××××××××××××××××××××××</p>
<p>##<strong>协程</strong></p>
<p>###协程的优势：<br>    线程： 计算机中能被cpu执行的最小单位<br>        一条线程在多个任务之间来回切换，切换这个动作是浪费时间的<br>        对与cpu， 操作系统来说协程是不存在的# 一个任务不得不陷入阻塞， 在这个任务的过程中切换到另一个任务继续执行<br>    你的程序的只要还需要执行， 你的当前线程永远不会阻塞<br>    同时做几件事件，在做一件事件的时候还可以做其他的事件，比如做饭的时候，煮粥的时候可以切菜，炒菜，干一些其他事件，等待煮粥事件<br>    合理的利用时间， 不要等待一个事件， 比如程序的时候，在阻塞的时候干一些其他啊的事件</p>
<p>###协程模块：<br>    利用协程来进行多个任务陷入阻塞的时候进行切换来保证在处理多个任务的时候总是忙<br>    无论是进程还是线程都是有操作系统来切换的，开启的线程，进程会给操作系统的调动带来压力<br>    如果我们使用的是协程，协程在程序之间的切换操作系统感知不到，无论开启多个协程对操作系统的调用不会带来压力</p>
<p> spawn(函数名) 产生了一个协程任物在遇到IO操作的时候帮助我们在多任务之&gt; 间自动切换<br>    join()        阻塞 直到某个任务被执行完毕<br>    join_all()<br>    value属性      获取返回值</p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><pre><code>from gevent import monkey
monkey.patch_all() #d
import threading
import time
import gevent
def fun1():
    print(&apos;1111&apos;)
    gevent.sleep(1)
    print(&apos;2222&apos;)
    g1_id = threading.current_thread().getName()
    print(g1_id)
def fun2():
    print(&apos;3333&apos;)
    gevent.sleep(1)
    print(&apos;44444&apos;)
    #查看进程ID
    g2_id = threading.current_thread().getName()
    print(g2_id) #假的线程
g1 = gevent.spawn(fun1)#遇到阻塞就回切换
g2 = gevent.spawn(fun2)
gevent.joinall([g1, g2]) #等待子线程结束
</code></pre><p>###<strong>爬虫示例代码</strong></p>
<p>###具体的示例</p>
<pre><code>from gevent import monkey
monkey.patch_all()
import time
import gevent
import requests
usl_list = [
        &apos;http://www.baidu.com&apos;,
        &apos;http://www.4399.com&apos;,
        &apos;http://www.7k7k.com&apos;,
        &apos;http://www.sogou.com&apos;,
        &apos;http://www.sohu.com&apos;,
        &apos;http://www.sina.com&apos;,
        &apos;http://www.jd.com&apos;,
        &apos;https://www.luffycity.com/home&apos;,
        &apos;https://www.douban.com&apos;,
        &apos;http://www.cnblogs.com/Eva-J/articles/8324673.html&apos;,
        &apos;http://www.baidu.com&apos;,
        &apos;http://www.7k7k.com&apos;,
        &apos;http://www.sogou.com&apos;,
        &apos;http://www.sohu.com&apos;,
        &apos;https://www.luffycity.com/home&apos;,
    ]
def get_url(url):
    response = requests.get(url)
    if response.status_code == 200: #查看验证网页是否通
        print(url, len(response.text)) #response.text网页的信息
        pass
start = time.time()
for url in usl_list:
    get_url(url)
print(time.time() - start) #7.55
start = time.time()
g_lis = []
for url in usl_list:
    g = gevent.spawn(get_url, url)
    #响应网页有延迟， 在延迟期间切换其他任务执行
    g_lis.append(g)
gevent.joinall(g_lis)
print(time.time() - start) # 1.7
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/10/02/协程，线程池/" data-id="cjn6hbtxa000u80u8oc87esbm" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-线程知识点" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/02/线程知识点/" class="article-date">
  <time datetime="2018-10-02T04:24:38.895Z" itemprop="datePublished">2018-10-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/python/">python</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/02/线程知识点/">线程知识点</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#线程知识点</p>
<p>##1线程锁</p>
<p>###1.1GIL</p>
<p>###1.2线程之间的数据安全问题<br>    例如：多个线程对同一块数据进行操作；<br>            比如赋值运算， 一个线程那到数据还没有返回数据结果时间片轮转，引起数据的不安全；<br>        pop, append 操作是安全的，<br>        队列也是安全的</p>
<p>####具体操作<br>    <code>此处输入代码
    from threading import Thread, Lock</code><br>    lock.acquire()<br>    ‘’’<br>        对数据的操作<br>    ‘’’<br>    lock.release()</p>
<p>###1.3递归锁和死锁现象</p>
<p>####死锁<br>     是指两个或两个以上的进程或线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程，如下就是死锁</p>
<p>#####死锁现象<br>        两把锁<br>        异步的<br>        操作的时候 抢到一把锁之后还要再去抢第二把锁<br>        一个线程抢到一把锁<br>        另一个线程抢到了另一把锁</p>
<p>####解决办法<br>    解决方法，递归锁，在Python中为了支持在同一线程中多次请求同一资源，python提供了可重入锁RLock。这个RLock内部维护着一个Lock和一个counter变量，counter记录了acquire的次数，从而使得资源可以被多次require。直到一个线程所有的acquire都被release，其他的线程才能获得资源。上面的例子如果使用RLock代替Lock，则不会发生死锁：</p>
<p>####示例代码<br>    import time<br>    def fun(lock):<br>        lock.acquire()<br>        print(‘我还活着’)<br>        lock.release()<br>        time.sleep(1)<br>        lock.acquire()<br>        print(‘你还没死’)<br>        lock.release()<br>    def func(lock):<br>        lock.acquire()<br>        lock.acquire()<br>        print(‘没死’)<br>        lock.release()<br>        lock.release()                           </p>
<pre><code>if __name__ == &apos;__main__&apos;:                   
    lock = Lock()                            
    # for i in range(10):                    
    t1 = Thread(target=fun, args=(lock,))    
    t1.start()                               
    t2 = Thread(target=func, args=(lock,))   
    t2.start()      
</code></pre><p>###递归锁<br>    在Python中为了支持在同一线程中多次请求同一资源，python提供了可重入锁RLock。这个RLock内部维护着一个Lock和一个counter变量，counter记录了acquire的次数，从而使得资源可以被多次require。直到一个线程所有的acquire都被release，其他的线程才能获得资源。上面的例子如果使用RLock代替Lock，则不会发生生死锁</p>
<p>####具体代码<br>    from threading import Thread, RLock<br>    fork_lock = noodle_lock = RLock()# 一把锁<br>    def fun1(*args):<br>        noodle_lock.acquire()                   </p>
<pre><code>#具体操作                                   
fork_lock.acquire()                     
# 具体操作                                  
fork_lock.release()                     
noodle_lock.release()  #只有当锁释放后才能执行其他操作
</code></pre><h3 id="递归锁可以解决互斥锁的死锁问题"><a href="#递归锁可以解决互斥锁的死锁问题" class="headerlink" title="递归锁可以解决互斥锁的死锁问题"></a>递归锁可以解决互斥锁的死锁问题</h3><pre><code># 互斥锁
 ¦   # 两把锁
 ¦   # 多个线程抢
 # 递归锁
 ¦   # 一把锁
 ¦   # 多个线程抢
</code></pre><h4 id="递归锁能够快速的解决死锁问题"><a href="#递归锁能够快速的解决死锁问题" class="headerlink" title="递归锁能够快速的解决死锁问题"></a>递归锁能够快速的解决死锁问题</h4><pre><code>  # 递归锁好不好？
  不好， 出现死锁，肯定是程序的逻辑有问题， 在快速解决死锁的情况下， 修改程序的逻辑。
 递归锁
 迅速恢复服务 递归锁替换互斥锁
     在接下来的时间中慢慢把递归锁替换成互斥锁
     能够完善代码的逻辑
     提高代码的效率
多个线程之间，用完一个资源再用另外一个资源
先释放一个资源，再去获取一个资源的锁
</code></pre><p>###信号量<br>    与进程的的信号量用法一样</p>
<p>###<strong>事件Event</strong><br>    wait() 等待 事件内的信号编程True<br>    set()  把信号变成True<br>    clear  把信号变成False<br>    is_set 查看信号状态是否为True</p>
<p>###示例代码<br>    from threading import<br>    import time          </p>
<pre><code>def fun1(e):         
    e.wait()   #在set没有调用之前下面的语句不执行 
    print(&apos;你好呀，我来了&apos;) 
def fun2(e):         
    time.sleep(5)    
    e.set()          

if __name__ == &apos;__mai
    e = Event()      
    t1 = Thread(targe
    t1.start()       
    t2 = Thread(targe
    t2.start()       
</code></pre><p>###<strong>条件 Condition</strong><br>    Python提供的Condition对象提供了对复杂线程同步问题的支持。Condition被称为条件变量，除了提供与Lock类似的acquire和release方法外，还提供了wait和notify方法。线程首先acquire一个条件变量，然后判断一些条件。如果条件不满足则wait；如果条件满足，进行一些处理改变条件后，通过notify方法通知其他线程，其他处于wait状态的线程接到通知后会重新判断条件。不断的重复这一过程，从而解决复杂的同步问题<br>    from threading import Condition, Thread<br>    def fun(con, name):<br>        print(‘欢迎光临’)<br>        con.acquire()<br>        con.wait()     #使用前后都需要加锁<br>        print(‘%s go to school’%name)<br>        con.release()<br>    if <strong>name</strong> == ‘<strong>main</strong>‘:<br>        con = Condition()<br>        for i in range(10):<br>            t = Thread(target=fun, args=(con, i))<br>            t.start()<br>        con.acquire()                                                                      </p>
<pre><code># con.notify(4)   #使用前后都需要加锁  每次默认一个，参数代表通过的次数                                     
# con.notify_all()                                                                 
con.notifyAll()                                                                    
con.release()       
</code></pre><p>###定时器 Timer<br>定时器，指定n秒后执行某个操作</p>
<pre><code>from threading import Thread, Timer                       
def func():                                               
    print(&apos;Timer: going to &apos;)                             
if __name__ == &apos;__main__&apos;:                                
    t = Timer(5, func)                                    
    t.start()                                   
</code></pre><p>###线程队列 queue队列<br>跟队列进程队列一样的用法</p>
<pre><code>q = queue.Queue()         
q.put(1)                  
q.put(2)                  
q.put(3)                  
#先进先出原则                   
print(q.get())    #1      
print(q.get())    #2      
print(q.get())    #3      
</code></pre><p>###<strong>线程队列 LifoQueue</strong><br>和栈类似先进后出</p>
<pre><code>from queue import LifoQueue
q = LifoQueue()
q.put(1)
q.put(2)
q.put(3)
print(q.get()) #3
print(q.get()) #2
print(q.get()) #1
</code></pre><p>###<strong>PriorityQueue</strong><br>存储数据时可设置优先级的队列</p>
<pre><code>from queue import PriorityQueue
q = PriorityQueue()
q.put((3,&apos;lei&apos;))
q.put((2,&apos;wen&apos;))
q.put((1,&apos;xuan&apos;))
print(q.get())
print(q.get())
print(q.get())
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/10/02/线程知识点/" data-id="cjn6hbu0y001p80u88xhls7ee" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-网络编程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/02/网络编程/" class="article-date">
  <time datetime="2018-10-02T04:24:38.864Z" itemprop="datePublished">2018-10-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/python/">python</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/02/网络编程/">网络编程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>##1：软件开发的架构</p>
<p>###两件程序之间通讯的应用大致可以分为两种：<br>    第一种：qq. 微信，网盘，优酷 这一类是属于需要安装的桌面应用<br>    第二种：比如百度， 知乎，博客园之类</p>
<p>####c/s架构<br>    即Client 与 Server， 客户端与服务器的端架构</p>
<p>####b/s架构<br>    Browser 与 Serverm 浏览器与服务端架构</p>
<p>##IP地址</p>
<pre><code>1: 网卡 ：身份证 mac地址 计算机在网络上的身份证
2: 交换机 ：负责一个网络内的多台机器之间的信息交换
3: mac地址 ：16进制的数  全球唯一

1: 127.0.0.1 ：本地回环地址 本机的地址
2: 0.0.0.0 ： ip地址的、回环地址的所有的用户都能找到你这台机器
</code></pre><p>####局域网</p>
<pre><code># 局域网
1: 网关ip    不同局域网之间通信依赖的ip地址
2: 子网掩码  判断两个ip地址是否在同一个网段内
3：网段


# 0.0.0.0 - 255.255.255.255
# 局域网的概念
# 外网ip 我们谁都能访问
# 内网ip 从外部不能访问，只能在内部环境中互相访问
# 外网ip永远不会和内网ip冲突？
# 0.0.0.0 - 255.255.255.255中间为内网保留了一些字段
# 192.168.0.0 - 192.168.255.255
# 10.0.0.0 - 10.255.255.255
# 172.16.0.0 - 172.31.255.255
</code></pre><p>###局域网中两台机器的通信原理</p>
<h1 id="局域网中两台机器的通信原理"><a href="#局域网中两台机器的通信原理" class="headerlink" title="局域网中两台机器的通信原理"></a>局域网中两台机器的通信原理</h1><pre><code># 交换机
# ip地址
# ip地址 -arp协议-&gt; mac地址
# mac地址 ： 全球唯一
# arp协议 ： 广播 和 单播
    # 通过ip地址获取mac地址
    # 一台机器A发起一个arp请求（只包含ip地址），发送给交换机
    # 交换机接收到请求，广播这条消息
    # 所有的机器都会接收到这个请求，只有和要寻找ip地址吻合的机器B
    # 才会回应交换机的广播，（带着自己的mac地址）
    # 交换机通过单播的形式将回复的B的mac地址发送给A
# 判断两台机器是不是在同一个局域网内：
    # 子网掩码
    # A机器的ip地址和A的子网掩码 按位与
    # B机器的ip地址和B的子网掩码 按位与
    # 得到的结果如果一致 那么说明两台机器是在一个网段内的
</code></pre><p>####端口</p>
<pre><code># 端口的概念 —— 帮助你找到一个应用
# 每一个网络服务都会占用计算机上的一个端口
# 计算机上的端口范围 0-65535
# 在同一时刻 同一台计算机上 不同的网络应用 占用的端口一定是不同的
</code></pre><p>##2：OSI 七层模型</p>
<p>####在7层的基础上简化为5层</p>
<pre><code># 应用层 http、https ftp smtp
# 传输层 TCP、UDP协议  4层路由器， 4层交换机
        # 端口 ：找到某一台机器上的具体的网络应用
        # tcp 面向连接 可靠 慢 全双工
            # 三次握手 建立tcp连接的过程
            # 发消息
            # 四次挥手 断开tcp连接的过程
           # udp 无连接 不可靠 快

# 网络层 ip协议  3层交换机 3层路由器
# 数据链路层 arp协议 / mac地址 网卡，交换机
        arp协议：根据ip地址找mac地址 ----交换机（广播， 单播）
# 物理层
</code></pre><p>##Tcp 和 Udp</p>
<h4 id="tcp-面向连接的-可靠的-但是慢"><a href="#tcp-面向连接的-可靠的-但是慢" class="headerlink" title="tcp 面向连接的 可靠的 但是慢"></a>tcp 面向连接的 可靠的 但是慢</h4><pre><code># tcp协议
# 两个应用之间要想通信 必须先建立连接
# 然后基于连接来通信
# 比较重要的文件 邮件的发送 下载安装包
#比较可靠的长数据
</code></pre><h4 id="udp-无连接的-快-能够发送的信息长度是有限的"><a href="#udp-无连接的-快-能够发送的信息长度是有限的" class="headerlink" title="udp 无连接的 快 能够发送的信息长度是有限的"></a>udp 无连接的 快 能够发送的信息长度是有限的</h4><pre><code># 快 但 不可靠 不能发送过长的数据
# 即时通讯类的程序
#高并发的短消息
</code></pre><p>###tcp和udp 的区别<br>     tcp、udp是通过网络通信的两种方式<br>       tcp 先建立连接再通信</p>
<pre><code>    # 可靠
    # 慢， 流式传输
udp 不需要建立连接直接通信
    # 快
    # 不可靠
</code></pre><p>###<strong>TCP协议中的数据传递</strong></p>
<p>###tcp协议的拆包机制</p>
<pre><code>当发送端缓冲区的长度大于网卡的MTU时，tcp会将这次发送的数据拆成几个数据包发送出去。 
MTU是Maximum Transmission Unit的缩写。意思是网络上传送的最大数据包。MTU的单位是字节。 
大部分网络设备的MTU都是1500。如果本机的MTU比网关的MTU大，大的数据包就会被拆开来传送，这样会产生很多数据包碎片，增加丢包率，降低网络速度。
</code></pre><p>###面向流的通信特点和Nagle算法</p>
<pre><code>TCP（transport control protocol，传输控制协议）是面向连接的，面向流的，提供高可靠性服务。
收发两端（客户端和服务器端）都要有一一成对的socket，因此，发送端为了将多个发往接收端的包，
更有效的发到对方，使用了优化方法（Nagle算法），将多次间隔较小且数据量小的数据，合并成一个大的数据块，然后进行封包。
这样，接收端，就难于分辨出来了，必须提供科学的拆包机制。 即面向流的通信是无消息保护边界的。 
对于空消息：tcp是基于数据流的，于是收发的消息不能为空，这就需要在客户端和服务端都添加空消息的处理机制，
防止程序卡住，而udp是基于数据报的，即便是你输入的是空内容（直接回车），也可以被发送，udp协议会帮你封装上消息头发送过去。 
可靠黏包的tcp协议：tcp的协议数据不会丢，没有收完包，下次接收，会继续上次继续接收，己端总是在收到ack时才会清除缓冲区内容。数据是可靠的，但是会粘包。
</code></pre><p>###一个简单的tcp： server 和 client</p>
<p>####sever<br>    from socket import *<br>    ip_port = (‘127.0.0.1’, 9514)</p>
<pre><code>sk = socket(AF_INET, SOCK_STREAM)
sk.bind(ip_port)
sk.listen()
sk_cl, addr = sk.accept()
data1 = sk_cl.recv(10)
data2 = sk_cl.recv(10)

print(&apos;-----&gt;&apos;, data1.decode(&apos;utf-8&apos;))
print(&apos;-----&gt;&apos;, data2.decode(&apos;utf-8&apos;))

sk_cl.close()
</code></pre><p>####client<br>    from socket import *<br>    ip_port = (‘127.0.0.1’, 9514)</p>
<pre><code>sk = socket(AF_INET, SOCK_STREAM)
sk.connect(ip_port)

sk.send(b&apos;my name is leiwenxuan&apos;)
sk.send(b&apos;nsdfasfdsf&apos;)
</code></pre><p>####udp的简单程序</p>
<p>###sever<br>    import socket<br>    sk = socket.socket(type=socket.SOCK_DGRAM)</p>
<pre><code>sk.bind((&apos;127.0.0.1&apos;, 9000))
while 1:
    msg,addr = sk.recvfrom(1024)
    print(msg.decode(&apos;utf-8&apos;), addr)
    # sk.sendto(&apos;正在发送...&apos;.encode(&apos;utf-8&apos;), addr)
    inp = input(&apos;input :&apos;)
</code></pre><p>###client<br>    import socket</p>
<pre><code>sk = socket.socket(type=socket.SOCK_DGRAM)
sk.bind((&apos;127.0.0.1&apos;, 9001))

while 1:
    # sk.sendto(&apos;正在发送...&apos;.encode(&apos;utf-8&apos;), (&apos;127.0.0.1&apos;, 9000))
    inp = input(&apos;input:&apos;)
    sk.sendto(inp.encode(&apos;utf-8&apos;),(&apos;127.0.0.1&apos;, 9000) )
    msg, addr = sk.recvfrom(1024)
    print(msg.decode(&apos;utf-8&apos;), addr[1])
</code></pre><p>##一个重要的黏包处理</p>
<p>###server<br>    import json, struct<br>    ‘’’传输一个简单的文件’’’<br>    import os<br>    from socket import *<br>    path_name = r’G:\python笔记\Pythonjing\day31\video\1.内容回顾和作业讲解.mp4’<br>    path_name = os.path.realpath(path_name)<br>    size = str(os.path.getsize(path_name))</p>
<pre><code>ip_port = (&apos;127.0.0.1&apos;, 9514)
sk = socket(AF_INET, SOCK_STREAM)
sk.bind(ip_port)
sk.listen()
sk_cl, addr = sk.accept()

sk_cl.send(size.encode(&apos;utf-8&apos;))
with open(path_name, &apos;rb&apos;) as f:
    while 1:
        data = f.read(2048)
        pack_num = struct.pack(&apos;i&apos;, len(data))
        sk_cl.send(pack_num)
        sk_cl.send(data)
        if not data:
            pack_num = struct.pack(&apos;i&apos;, len(&apos;&apos;))
            sk_cl.send(pack_num)
            print(len(data))
            break
</code></pre><p>##client<br>    from socket import *<br>    import struct<br>    import sys</p>
<pre><code>def processBar(num, total):
    &apos;&apos;&apos;进度条&apos;&apos;&apos;
    rate = num / total
    rate_num = int(rate * 100)
    if rate_num == 100:
        r = &apos;\r%s&gt;%d%%\n&apos; % (&apos;|&apos; * rate_num, rate_num,)
    else:
        r = &apos;\r%s&gt;%d%%&apos; % (&apos;|&apos; * rate_num, rate_num,)
    sys.stdout.write(r)
    sys.stdout.flush


ip_port = (&apos;127.0.0.1&apos;, 9514)
sk = socket(AF_INET, SOCK_STREAM)
sk.connect(ip_port)


size = int(sk.recv(1024).decode(&apos;utf-8&apos;))
# processBar(2048, size)
num_size = 0
with open(&apos;lw.mp4&apos;,&apos;wb&apos;) as f:
    while 1:
        pack_num = sk.recv(4)
        num = struct.unpack(&apos;i&apos;, pack_num)[0]
        # print(num)
        if not num:
            break
        ret = sk.recv(num)
        f.write(ret)
        num_size += num
        processBar(num_size, size)
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/10/02/网络编程/" data-id="cjn6hbu10001t80u8nl9ns6ji" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-re模块" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/01/re模块/" class="article-date">
  <time datetime="2018-10-01T06:45:16.865Z" itemprop="datePublished">2018-10-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/python/">python</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/01/re模块/">正则表达式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>###正则表达式的常见使用场景<br>    1：判断某一个字符串是否符合规则 #注册页-判断手机号-身份证<br>    2：将符合规则的内容从一个庞大的字符串体系中提取出来</p>
<pre><code>#爬虫日志分析
</code></pre><p>###什么是正则表达式？<br>    1：是一种规则</p>
<h2 id="一正则表达式步骤"><a href="#一正则表达式步骤" class="headerlink" title="一正则表达式步骤"></a>一正则表达式步骤</h2><pre><code>1.用 import re 导入正则表达式模块。
2.用 re.compile()函数创建一个 regex 对象（记得使用原始字符串）。
3.向 regex 对象的 search()方法传入想查找的字符串。它返回一个 match 对象
4.调用 match 对象的 group()方法，返回实际匹配文本的字符串。
补充：regex 对象的 search()方法查找传入的字符串， 寻找该正则表达式的所有匹配。如果字符串中没有找到该正则表达式模式，search()方法将返回 none。如果找到了该模式，search()方法将返回一个 match 对象。
</code></pre><h2 id="二用正则表达式匹配更多模式"><a href="#二用正则表达式匹配更多模式" class="headerlink" title="二用正则表达式匹配更多模式"></a>二用正则表达式匹配更多模式</h2><h4 id="2-1：利用括号分组"><a href="#2-1：利用括号分组" class="headerlink" title="2.1：利用括号分组"></a>2.1：利用括号分组</h4><pre><code>phonenumregex = re.compile(&apos;(\d{3})-(\d{3})-(\d{4})&apos;)
mo = phonenumregex.search(&apos;my number is 444-333-3333&apos;)
print(mo.group(1)) #444
print(mo.group(0)) #444-333-3333
print(mo.group()) #向group传0或者不传值匹配的都是字符串
print(mo.groups())#(&apos;444&apos;, &apos;333&apos;, &apos;3333&apos;)
</code></pre><h3 id="2-2：用管道匹配多个分组"><a href="#2-2：用管道匹配多个分组" class="headerlink" title="2.2：用管道匹配多个分组"></a>2.2：用管道匹配多个分组</h3><pre><code>heroregex = re.compile(r&apos;batman|雷文轩&apos;)
mo = heroregex.search(&apos;雷文轩 and batman&apos;)
print(mo.group())#雷文轩 匹配一个就退出

heroregex = re.compile(r&apos;雷(文轩|一鸣|英)&apos;)
mo = heroregex.search(&apos; 雷文轩， 雷文轩and 雷英&apos;)
print(mo.group()) #匹配其中一个
</code></pre><h3 id="2-3：用问好实现可选匹配"><a href="#2-3：用问好实现可选匹配" class="headerlink" title="2.3：用问好实现可选匹配"></a>2.3：用问好实现可选匹配</h3><p>#####正则表达式中的(文)?部分表明， 模式 wo 是可选的分组。该正则表达式匹配的文本中， 文将出现零次或一次。<br>    batregex = re.compile(r’雷(文)?轩’)<br>    mo = batregex.search(‘my name is 雷轩’)<br>    print(mo.group()) #雷轩</p>
<h3 id="2-4：用星号匹配零次或多次"><a href="#2-4：用星号匹配零次或多次" class="headerlink" title="2.4：用星号匹配零次或多次"></a>2.4：用星号匹配零次或多次</h3><p>#####（称为星号）意味着“匹配零次或多次”，即星号之前的分组或者<strong>一个元字符</strong>，可以在文本中出现任意次。它可以完全不存在，或一次又一次地重复。</p>
<pre><code>batrgex = re.compile(r&apos;bat(wo)*man&apos;)
mo = batrgex.search(&apos; the adventures of batman&apos;)
print(mo.group()) #batman

mo1 = batrgex.search(&apos; the adventures of batwoman&apos;)
print(mo1.group()) #batwoman

mo2 = batrgex.search(&apos; the adventures of batwowowoman&apos;)
print(mo2.group()) #batwowowoman
</code></pre><h3 id="2-5：用加号匹配一次或多次"><a href="#2-5：用加号匹配一次或多次" class="headerlink" title="2.5：用加号匹配一次或多次"></a>2.5：用加号匹配一次或多次</h3><p>#####正则表达式 bat(wo)+man 不会匹配字符串’the adventures of batman’，因为加号要求 wo 至少出现一次。如果需要匹配真正的加号字符， 在加号前面加上倒斜杠实现转义： +。</p>
<pre><code>#batregex = re.compile(&apos;bat(wo)+man&apos;)
mo = batregex.search(&apos;the adventures of batwoman&apos;)
print(mo.group()) #batwoman
#******
mo = batregex.search(&apos;the adventures of batman&apos;)#+ 号代表一次或者多次
print(mo == none) #匹配队里里为空 等于none
</code></pre><h3 id="2-5：用花括号匹配特定次数"><a href="#2-5：用花括号匹配特定次数" class="headerlink" title="2.5：用花括号匹配特定次数"></a>2.5：用花括号匹配特定次数</h3><p>#####如果想要一个分组重复特定次数，就在正则表达式中该分组的后面，跟上花括号包围的数字。例如，正则表达式(ha){3}将匹配字符串’hahaha’，但不会匹配’haha’，因为后者只重复了(ha)分组两次。除了一个数字，还可以指定一个范围，即在花括号中写下一个最小值、一个逗号和一个最大值。例如，正则表达式(ha){3,5}将匹配’hahaha’、 ‘hahahaha’和’hahahahaha’。</p>
<p>#####也可以不写花括号中的第一个或第二个数字， 不限定最小值或最大值。例如，(ha){3,}将匹配 3 次或更多次实例， (ha){,5}将匹配 0 到 5 次实例。花括号让正则表达式更简短。这两个正则表达式匹配同样的模式：<br>    hareget = re.compile(r’(ha){3}’)#匹配hahaha<br>    mo = hareget.search(‘hahaha’) #不会匹配haha<br>    print(mo.group())#hahaha</p>
<h3 id="2-6贪心和非贪心匹配"><a href="#2-6贪心和非贪心匹配" class="headerlink" title="2:6贪心和非贪心匹配"></a>2:6贪心和非贪心匹配</h3><pre><code>greedyharegex = re.compile(r&apos;(ha){3,5}&apos;)
mo = greedyharegex.search(&apos;hahahaha&apos;)
print(mo.group()) #hahahaha 他会匹配更长的值

nongeedyharegex = re.compile(r&apos;(ha){3,5}?&apos;)
mo2 = nongeedyharegex.search(&apos;hahahahaha&apos;)
print(mo2.group())#hahaha 尽量取少的模式
#贪婪匹配：正则会尽量多的帮我们匹配， 默认贪婪，回溯算法
#非贪婪匹配：会尽量少的为我们匹配，
    1：
</code></pre><h2 id="三重要的方法"><a href="#三重要的方法" class="headerlink" title="三重要的方法"></a>三重要的方法</h2><h3 id="3-1-findall-方法"><a href="#3-1-findall-方法" class="headerlink" title="3.1    findall()方法"></a>3.1    findall()方法</h3><pre><code>phonenumregex = re.compile(r&apos;(\d{3})-(\d{3})-(\d{4})&apos;)
mo = phonenumregex.findall(&apos;cell: 415-555-9999 work: 212-555-0000&apos;)
print(mo) #[(&apos;415&apos;, &apos;555&apos;, &apos;9999&apos;), (&apos;212&apos;, &apos;555&apos;, &apos;0000&apos;)]
#1:返回一个字符串列表，． 如果调用在一个有分组的正则表达式上，
#2:方法 findall()将返回一个字符串的元组的列表（每个分组对应一个字符串），
#3：会优先显示分组中的内容 ,(?:) 取消分组优先
</code></pre><h3 id="3-2-split"><a href="#3-2-split" class="headerlink" title="3.2 split()"></a>3.2 split()</h3><pre><code>1.mo = re.split(&apos;(\w+)&apos;, &apos;my name is Dan, My sperk 1 langure&apos;)
2.print(mo)#[&apos;my name is  leiwenxuan , the man years old &apos;, &apos;25&apos;, &apos;, It is sunny water&apos;]
3.print(mo)#[&apos;my name is  leiwenxuan , the man years old &apos;, &apos;, It is sunny water&apos;]
#() 和没有()的匹配的结果是不一样的

#在匹配部分加上（）之后所切出的结果是不同的，
#没有（）的没有保留所匹配的项，但是有（）的却能够保留了匹配的项，
#这个在某些需要保留匹配部分的使用过程是非常重要的。
</code></pre><h3 id="3-3-finditer（）"><a href="#3-3-finditer（）" class="headerlink" title="3.3 finditer（）"></a>3.3 finditer（）</h3><pre><code>fin = re.finditer(&apos;\d+&apos;, &apos;186lei 987has 123&apos;) #finditer返回一个存放匹配结果的迭代器

for ret in fin:
      print(ret) #&lt;_sre.SRE_Match object; span=(14, 17), match=&apos;123&apos;&gt;
       print(ret.group())  #186
</code></pre><h3 id="3-4match"><a href="#3-4match" class="headerlink" title="3.4match"></a>3.4match</h3><pre><code>mo = re.match(&apos;\d+&apos;, &apos;jkhjk892028617dsds&apos;)
print(mo.group())# 报错AttributeError
mo = re.match(&apos;\d+&apos;, &apos;892028617rsds&apos;)
print(mo.group()) #892028617

*#注意事项： match 和search区别  match默认匹配加 ^ *
</code></pre><h3 id="3-5sub-方法替换字符串"><a href="#3-5sub-方法替换字符串" class="headerlink" title="3.5sub()方法替换字符串"></a>3.5sub()方法替换字符串</h3><pre><code>1. sub_mo = re.compile(&apos;Agent \w+&apos;)
2. mo = sub_mo.sub(&apos;leiwenxuan&apos;, &apos;Agent Alice gave the secret documents to Agent Bob.&apos;)
3. print(mo) #leiwenxuan gave the secret documents to leiwenxuan.
4. 对象的 sub()方法需要传入两个参数。第一个参数是一个字符串， 用于取代发现的匹配。第二个参数是一个字符串，即正则表达式。
5. 在没有compile 绑定的情况下： 第一个参数是正则， 第二个是 替换的 ， 第三个是字符串， 还可以有第四个代表替换次数
6. mo = re.sub(r&apos;name&apos;, &apos;姓名&apos;, &apos;name: Dan, name: lisa&apos;, 1)
7. print(mo) # 姓名: Dan, name: lisa

1. agentNameRggex = re.compile(r&apos;Agent (\w)\w*&apos;)
2. mo = agentNameRggex.sub(r&apos;\1****&apos;, &apos;Agent Alice told Agent Carol that AgentEve knew Agent Bob was a double agent.&apos;)
3. print(mo)
</code></pre><h2 id="四字符分类"><a href="#四字符分类" class="headerlink" title="四字符分类"></a>四字符分类</h2><pre><code>4.1 元字符
</code></pre><p>匹配内容</p>
<pre><code>.      匹配除换行符以外的任意字符
\w     匹配字母或数字或下划线
\s     匹配任意的空白符
\d     匹配数字
\n     匹配一个换行符
\t     匹配一个制表符
\b     匹配一个单词的结尾
^     匹配字符串的开始
$     匹配字符串的结尾
\W     匹配非字母或数字或下划线
\D     匹配非数字
\S     匹配非空白符
a|b     匹配字符a或字符b
()     匹配括号内的表达式，也表示一个组
[...]     匹配字符组中的字符
[^...]     匹配除了字符组中字符的所有字符

例如：字符分类[0-5]只匹配数字 0 到 5， 这比输入(0|1|2|3|4|5)要短很多。
![字符分类](https://i.imgur.com/P2Udbd6.png)
</code></pre><p>2018/9/10/周一 10:04:49 </p>
<h3 id="4-1插入字符和美元字符"><a href="#4-1插入字符和美元字符" class="headerlink" title="4.1插入字符和美元字符"></a>4.1插入字符和美元字符</h3><pre><code>1. 可以在正则表达式的开始处使用插入符号（^），表明匹配必须发生在被查找文本开始处
2. 类似地，可以再正则表达式的末尾加上美元符号（$），表示该字符串必须以这个正则表达式的模式结束。可以同时使用^和$，表明整个字符串必须匹配该模式，也就是说，只匹配该字符串的某个子集是不够的。
</code></pre><h3 id="4-2不区分大小写的匹配"><a href="#4-2不区分大小写的匹配" class="headerlink" title="4.2不区分大小写的匹配"></a>4.2不区分大小写的匹配</h3><pre><code>1. rebocp = re.compile(r&apos;leiWenXuan&apos;,re.I) 
2. #忽略大小写  re.IGNORECASE 或者re.I
3. mo = rebocp.search(&apos;Leiwenxuan livs in chain&apos;)
4. print(mo.group())
</code></pre><h3 id="管理复杂的正则表达式"><a href="#管理复杂的正则表达式" class="headerlink" title="管理复杂的正则表达式"></a>管理复杂的正则表达式</h3><pre><code>1. phoneRegex = re.compile(r&apos;&apos;&apos;
       \w     #可以加注释
&apos;&apos;&apos;, re.VERBOSE)
2.mo = phoneRegex.findall(&apos;erhja&apos;)
3.print(mo)

flags有很多可选值：

    re.I(IGNORECASE)忽略大小写，括号内是完整的写法
    re.M(MULTILINE)多行模式，改变^和$的行为
    re.S(DOTALL)点可以匹配任意字符，包括换行符
    re.L(LOCALE)做本地化识别的匹配，表示特殊字符集 \w, \W, \b, \B, \s, \S 依赖于当前环境，不推荐使用
    re.U(UNICODE) 使用\w \W \s \S \d \D使用取决于unicode定义的字符属性。在python3中默认使用该flag
    re.X(VERBOSE)冗长模式，该模式下pattern字符串可以是多行的，忽略空白字符，并可以添加注释
</code></pre><h3 id="分组命名、分组约束"><a href="#分组命名、分组约束" class="headerlink" title="分组命名、分组约束"></a>分组命名、分组约束</h3><h4 id="用途-前端"><a href="#用途-前端" class="headerlink" title="用途 前端"></a>用途 前端</h4><pre><code>1.pattern = &apos;&lt;(?P&lt;tag&gt;.*?)&gt;.*?&lt;/(?P=tag)&gt;&apos;
2.ret = re.search(pattern, &apos;&lt;h2&gt; my name is who&lt;/h1&gt;&apos;)
3.&apos;&apos;&apos;匹配&lt;&gt;里面一样才匹配&apos;&apos;&apos;
4.if ret:
5.     print(ret.group())
6 pattern = r&apos;&lt;(.*?)&gt;.*?&lt;/\1&gt;&apos;
7.ret = re.search(pattern, &apos;&lt;h1&gt; my name is who&lt;/h1&gt;&apos;)
8.&apos;&apos;&apos;匹配前后格式一样的标签&apos;&apos;&apos;
9.if ret:
10.    print(ret.group())
11.    
#(?:正则表达式) 表示取消优先显示功能
# (?P&lt;组名&gt;正则表达式) 表示给这个组起一个名字
#(?P=组名) 表示引用之前组的名字，引用部分匹配到的内容必须和之前那个组中的内容一模一样    **
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/10/01/re模块/" data-id="cjn6hbu0w001m80u8nitluykq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/01/hello-world/" class="article-date">
  <time datetime="2018-10-01T04:42:47.891Z" itemprop="datePublished">2018-10-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/01/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/10/01/hello-world/" data-id="cjn6hbtwd000680u8457n46sr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/html/">html</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">mysql</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/个人感想/">个人感想</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/云服务器/">云服务器</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL练习/">MySQL练习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/centOS/">centOS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/">css</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tomcat/">tomcat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多表/">多表</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据操作/">数据操作</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据操作Python/">数据操作Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/珍惜/">珍惜</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/MySQL练习/" style="font-size: 20px;">MySQL练习</a> <a href="/tags/centOS/" style="font-size: 10px;">centOS</a> <a href="/tags/css/" style="font-size: 10px;">css</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/tomcat/" style="font-size: 10px;">tomcat</a> <a href="/tags/多表/" style="font-size: 10px;">多表</a> <a href="/tags/数据操作/" style="font-size: 10px;">数据操作</a> <a href="/tags/数据操作Python/" style="font-size: 10px;">数据操作Python</a> <a href="/tags/珍惜/" style="font-size: 10px;">珍惜</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">十月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/10/11/CSS进阶/">CSS 进阶</a>
          </li>
        
          <li>
            <a href="/2018/10/10/CSS-给HTML设置样式/">CSS-给HTML设置样式</a>
          </li>
        
          <li>
            <a href="/2018/10/09/HTML初识/">HTML初识</a>
          </li>
        
          <li>
            <a href="/2018/10/08/mysql练习 copy/">Mysql 小练习</a>
          </li>
        
          <li>
            <a href="/2018/10/08/Mysql增删改查/">Mysql增删改查</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 Leiwenxuan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>