<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>雷文轩</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-10-15T09:18:25.498Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Leiwenxuan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>cssPostion-定位</title>
    <link href="http://yoursite.com/2018/10/15/cssPostion-%E5%AE%9A%E4%BD%8D/"/>
    <id>http://yoursite.com/2018/10/15/cssPostion-定位/</id>
    <published>2018-10-15T09:18:02.000Z</published>
    <updated>2018-10-15T09:18:25.498Z</updated>
    
    <content type="html"><![CDATA[<h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><pre><code>static 默认值，无定位，不能当作绝对定位的参照物，并且设置标签对象的left、top等值是不起作用的的。</code></pre><h1 id="relative（相对定位）"><a href="#relative（相对定位）" class="headerlink" title="relative（相对定位）"></a>relative（相对定位）</h1><pre><code>相对定位是相对于该元素在文档流中的原始位置，即以自己原始位置为参照物。有趣的是，即使设定了元素的相对定位以及偏移值，元素还占有着原来的位置，即占据文档流空间。对象遵循正常文档流，但将依据top，right，bottom，left等属性在正常文档流中偏移位置。而其层叠通过z-index属性定义。注意：position：relative的一个主要用法：方便绝对定位元素找到参照物。</code></pre><h1 id="absolute（绝对定位）"><a href="#absolute（绝对定位）" class="headerlink" title="absolute（绝对定位）"></a>absolute（绝对定位）</h1><pre><code>定义：设置为绝对定位的元素框从文档流完全删除，并相对于最近的已定位祖先元素定位，如果元素没有已定位的祖先元素，那么它的位置相对于最初的包含块（即body元素）。元素原先在正常文档流中所占的空间会关闭，就好像该元素原来不存在一样。元素定位后生成一个块级框，而不论原来它在正常流中生成何种类型的框。重点：如果父级设置了position属性，例如position:relative;，那么子元素就会以父级的左上角为原始点进行定位。这样能很好的解决自适应网站的标签偏离问题，即父级为自适应的，那我子元素就设置position:absolute;父元素设置position:relative;，然后Top、Right、Bottom、Left用百分比宽度表示。另外，对象脱离正常文档流，使用top，right，bottom，left等属性进行绝对定位。而其层叠通过z-index属性定义。</code></pre><p>fixed（固定）</p><pre><code>fixed：对象脱离正常文档流，使用top，right，bottom，left等属性以窗口为参考点进行定位，当出现滚动条时，对象不会随着滚动。而其层叠通过z-index属性 定义。 注意点： 一个元素若设置了 position:absolute | fixed; 则该元素就不能设置float。这 是一个常识性的知识点，因为这是两个不同的流，一个是浮动流，另一个是“定位流”。但是 relative 却可以。因为它原本所占的空间仍然占据文档流。在理论上，被设置为fixed的元素会被定位于浏览器窗口的一个指定坐标，不论窗口是否滚动，它都会固定在这个位置。</code></pre><h2 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;  &lt;title&gt;返回顶部示例&lt;/title&gt;  &lt;style&gt;    * {      margin: 0;    }    .d1 {      height: 1000px;      background-color: #eeee;    }    .scrollTop {      background-color: darkgrey;      padding: 10px;      text-align: center;      position: fixed;      right: 10px;      bottom: 20px;    }  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;d1&quot;&gt;111&lt;/div&gt;&lt;div class=&quot;scrollTop&quot;&gt;返回顶部&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h1 id="z-index"><a href="#z-index" class="headerlink" title="z-index"></a>z-index</h1><pre><code>#i2 {  z-index: 999;}设置对象的层叠顺序，数值大的会覆盖在数值小的标签之上。z-index 仅能在定位元素上奏效。 自定义模态框示例</code></pre><h1 id="opacity"><a href="#opacity" class="headerlink" title="opacity"></a>opacity</h1><pre><code>用来定义透明效果。取值范围是0~1，0是完全透明，1是完全不透明</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;static&quot;&gt;&lt;a href=&quot;#static&quot; class=&quot;headerlink&quot; title=&quot;static&quot;&gt;&lt;/a&gt;static&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;static 默认值，无定位，不能当作绝对定位的参照物，并且设置标签对象的left、top等
      
    
    </summary>
    
      <category term="html" scheme="http://yoursite.com/categories/html/"/>
    
    
      <category term="css-Postion" scheme="http://yoursite.com/tags/css-Postion/"/>
    
  </entry>
  
  <entry>
    <title>面试真题：</title>
    <link href="http://yoursite.com/2018/10/15/%E9%9D%A2%E8%AF%95%E9%A2%98Python/"/>
    <id>http://yoursite.com/2018/10/15/面试题Python/</id>
    <published>2018-10-15T09:18:02.000Z</published>
    <updated>2018-10-15T09:19:26.201Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-编写函数-实现功能：将-1-2-3-4-5-6-7-转换成-1-2-3-4-5-6-7"><a href="#1-编写函数-实现功能：将-1-2-3-4-5-6-7-转换成-1-2-3-4-5-6-7" class="headerlink" title="1. 编写函数,实现功能：将[1,2,[3,[4,5]],6,[7,]] 转换成[1,2,3,4,5,6,7]"></a>1. 编写函数,实现功能：将[1,2,[3,[4,5]],6,[7,]] 转换成[1,2,3,4,5,6,7]</h1><p>li = [1, 2, [3, [4, 5, [1, 2, [1, 2]]]], 6, [7, ]]</p><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><pre><code>def func( li ):    # lis = []    if isinstance(li, list):        return [y for x in li for y in func(x)]    else:        return [li]</code></pre><p>print(func(li))</p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><pre><code>lis = []def func(li):    for i in li:        if isinstance(i,list):           func(i)        else:            lis.append(i)    return lis</code></pre><p>print(list(func(li)))</p><h1 id="2-1-2-3-4-5-6-7-用生成器将其生成-1-2-3-4-5-6-7"><a href="#2-1-2-3-4-5-6-7-用生成器将其生成-1-2-3-4-5-6-7" class="headerlink" title="2. [1,2,[3,[4,5]],6,[7,]]  用生成器将其生成[1,2,3,4,5,6,7]"></a>2. [1,2,[3,[4,5]],6,[7,]]  用生成器将其生成[1,2,3,4,5,6,7]</h1><h2 id="生成器-一"><a href="#生成器-一" class="headerlink" title="生成器 一"></a>生成器 一</h2><pre><code>def func3(li):    for i in li:        if isinstance(i, list):            for j in func3(i):                yield j        else:            yield iprint(list(func3(li)))</code></pre><h2 id="生产器yield-from"><a href="#生产器yield-from" class="headerlink" title="生产器yield from"></a>生产器yield from</h2><pre><code>def func4(li):    for i in li:        if isinstance(i, list):            yield from func4(i)        else:            yield iprint(list(func4(li)))</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-编写函数-实现功能：将-1-2-3-4-5-6-7-转换成-1-2-3-4-5-6-7&quot;&gt;&lt;a href=&quot;#1-编写函数-实现功能：将-1-2-3-4-5-6-7-转换成-1-2-3-4-5-6-7&quot; class=&quot;headerlink&quot; title=&quot;1.
      
    
    </summary>
    
      <category term="面试题Python编程题" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98Python%E7%BC%96%E7%A8%8B%E9%A2%98/"/>
    
    
      <category term="Python编程题" scheme="http://yoursite.com/tags/Python%E7%BC%96%E7%A8%8B%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>CSS 进阶</title>
    <link href="http://yoursite.com/2018/10/11/CSS%E8%BF%9B%E9%98%B6/"/>
    <id>http://yoursite.com/2018/10/11/CSS进阶/</id>
    <published>2018-10-11T07:57:57.000Z</published>
    <updated>2018-10-11T12:01:14.131Z</updated>
    
    <content type="html"><![CDATA[<ol><li>CSS属性：<a href="https://www.cnblogs.com/liwenzhou/p/7999532.html" target="_blank" rel="noopener">https://www.cnblogs.com/liwenzhou/p/7999532.html</a></li></ol><h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h1><p>width属性可以为元素设置宽度。<br>height属性可以为元素设置高度。<br>块级标签才能设置宽度，内联标签的宽度由内容来决定。<br>     <style><br>        p {color: red} #优先显示<br>        body {color: #0000cc}<br>    </style></p><pre><code> &lt;style&gt;        /*显示背景的*/    .c1 {        height: 100px;          width: 100px;        color: red;        background-color: darkorange; #背景设置    }    .c2 {        height: 600px;        width: 600px;        /*设置背景图片出现的次数 位置*/        background: url(&quot;01.jpg&quot; ) no-repeat center bottom;    }雪碧图：为了减少网页请求图片的次数，将很多小图片放在一个大图片中，通过background-postion来指定background: url(&apos;xx.png&apos; no-repeat center center)</code></pre><h2 id="背景图片的设置"><a href="#背景图片的设置" class="headerlink" title="背景图片的设置"></a>背景图片的设置</h2><pre><code>repeat(默认):背景图片平铺排满整个网页repeat-x：背景图片只在水平方向上平铺repeat-y：背景图片只在垂直方向上平铺no-repeat：背景图片不平铺</code></pre><h1 id="2-边框"><a href="#2-边框" class="headerlink" title="2. 边框"></a>2. 边框</h1><pre><code>border: 1px solid red</code></pre><h2 id="边框设置属性"><a href="#边框设置属性" class="headerlink" title="边框设置属性"></a>边框设置属性</h2><pre><code>border-widthborder-styleborder-color    值    描述none    无边框。dotted    点状虚线边框。dashed    矩形虚线边框。solid    实线边框。</code></pre><h2 id="画圆和-圆角矩形"><a href="#画圆和-圆角矩形" class="headerlink" title="画圆和 圆角矩形"></a>画圆和 圆角矩形</h2><pre><code> &lt;style&gt;    .c1 {        height: 100px;        width: 100px;        background-color: red;        border-radius:            50%;    }&lt;style&gt;</code></pre><h1 id="3-display"><a href="#3-display" class="headerlink" title="3. display"></a>3. display</h1><pre><code>1. none2. inline3. block4. inline-blockdisplay: none和visibility: hidden的区别？    都是隐藏页面上的标签    display: none隐藏标签并且不占位置    visibility: hidden 隐藏标签的同时会占住位置</code></pre><p><img src="https://i.imgur.com/zp0CS2F.png" alt=""></p><h1 id="4-盒子模型"><a href="#4-盒子模型" class="headerlink" title="4. 盒子模型"></a>4. 盒子模型</h1><h3 id="margin-用于控制元素与元素之间的距离；margin的最基本用途就是控制元素周围空间的间隔，从视觉角度上达到相互隔开的目的。"><a href="#margin-用于控制元素与元素之间的距离；margin的最基本用途就是控制元素周围空间的间隔，从视觉角度上达到相互隔开的目的。" class="headerlink" title="margin:用于控制元素与元素之间的距离；margin的最基本用途就是控制元素周围空间的间隔，从视觉角度上达到相互隔开的目的。"></a>margin:用于控制元素与元素之间的距离；margin的最基本用途就是控制元素周围空间的间隔，从视觉角度上达到相互隔开的目的。</h3><h3 id="padding-用于控制内容与边框之间的距离；"><a href="#padding-用于控制内容与边框之间的距离；" class="headerlink" title="padding:   用于控制内容与边框之间的距离；"></a>padding:   用于控制内容与边框之间的距离；</h3><h3 id="Border-边框-围绕在内边距和内容外的边框。"><a href="#Border-边框-围绕在内边距和内容外的边框。" class="headerlink" title="Border(边框):     围绕在内边距和内容外的边框。"></a>Border(边框):     围绕在内边距和内容外的边框。</h3><h3 id="Content-内容-盒子的内容，显示文本和图像。"><a href="#Content-内容-盒子的内容，显示文本和图像。" class="headerlink" title="Content(内容):   盒子的内容，显示文本和图像。"></a>Content(内容):   盒子的内容，显示文本和图像。</h3><pre><code>内容&gt;内填充(padding)&gt;边框(border)&gt;外边距(margin)</code></pre><p><img src="https://i.imgur.com/KUvfWZ7.png" alt=""></p><h1 id="5-浮动"><a href="#5-浮动" class="headerlink" title="5. 浮动"></a>5. 浮动</h1><pre><code>1. 浮动多用于页面大范围布局2. 浮动    - left   往左浮动    - right  往右浮动3. 清除浮动的副作用    1. clear        - left    左边不能有浮动元素        - right   右边不能有浮动元素        - both    两边都不能有浮动元素    2. 常用class        .clearfix:after {            content: &apos;&apos;;            display: block;            clear:both        }</code></pre><h1 id="6-溢出"><a href="#6-溢出" class="headerlink" title="6. 溢出"></a>6. 溢出</h1><pre><code>overflow    - hidden    - scroll    - auto圆形头像的例子</code></pre><h1 id="7-定位"><a href="#7-定位" class="headerlink" title="7. 定位"></a>7. 定位</h1><pre><code>1. 相对定位：相对 标签原来的位置 做的定位    position: relative    left:    top:    bottom:    right:2. 绝对定位：相对 已经定位过的祖先标签 做的定位    多用于页面局部的布局，注意要和定位过的祖先标签配合使用    绝对定位和浮动一样，标签都会脱离文档，别的标签可以占用它的位置3. 固定定位    固定定位相对于 屏幕 固定显示在某个位置    固定定位的元素也是脱离文档的    返回顶部按钮</code></pre><h1 id="2-Blog页面"><a href="#2-Blog页面" class="headerlink" title="2. Blog页面"></a>2. Blog页面</h1><pre><code>1. 先写HTML(HTML是骨架)2. 再写CSS(CSS控制HTML的显示效果)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;CSS属性：&lt;a href=&quot;https://www.cnblogs.com/liwenzhou/p/7999532.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/liwenzhou/p
      
    
    </summary>
    
      <category term="html" scheme="http://yoursite.com/categories/html/"/>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>CSS-给HTML设置样式</title>
    <link href="http://yoursite.com/2018/10/10/CSS-%E7%BB%99HTML%E8%AE%BE%E7%BD%AE%E6%A0%B7%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/10/10/CSS-给HTML设置样式/</id>
    <published>2018-10-10T12:15:54.367Z</published>
    <updated>2018-10-10T12:15:54.378Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-CSS（给HTML标签设置样式的）"><a href="#1-CSS（给HTML标签设置样式的）" class="headerlink" title="1. CSS（给HTML标签设置样式的）"></a>1. CSS（给HTML标签设置样式的）</h1><h2 id="1-1-CSS定义："><a href="#1-1-CSS定义：" class="headerlink" title="1.1 CSS定义："></a>1.1 CSS定义：</h2><p>层叠样式表</p><h2 id="1-2-CSS语法："><a href="#1-2-CSS语法：" class="headerlink" title="1.2 CSS语法："></a>1.2 CSS语法：</h2><p>选择器 {k1: v1; k2:v2…}</p><h2 id="1-3-CSS代码存在的位置"><a href="#1-3-CSS代码存在的位置" class="headerlink" title="1.3 CSS代码存在的位置"></a>1.3 CSS代码存在的位置</h2><pre><code>1. 直接写在标签中的style属性2. 写在head标签中的style标签内3. 写在单独的CSS文件中，通过link标签引用4. CSS选择器（定义如何在HTML中找标签）</code></pre><h1 id="2-CSS样式分类"><a href="#2-CSS样式分类" class="headerlink" title="2.CSS样式分类"></a>2.CSS样式分类</h1><h2 id="2-1-基本选择器"><a href="#2-1-基本选择器" class="headerlink" title="2.1 基本选择器"></a>2.1 基本选择器</h2><pre><code>1. ID选择器      --&gt; #p12. 标签选择器    --&gt; div3. 类选择器      --&gt; .c14. 通用选择器    --&gt; *  #没有设置样式的将匹配</code></pre><h3 id="2-1-1-具体实例"><a href="#2-1-1-具体实例" class="headerlink" title="2.1.1 具体实例"></a>2.1.1 具体实例</h3><pre><code>&lt;style&gt;    /*id是p1的标签*/    #p1 {color: red}    /*id是p2的标签*/    #p2 {        color: green    }    /*所有的div标签*/    div {color: blue}    /*有c1这个class的标签*/    .c1 {color: deeppink}    /*有c2这个class的标签*/    .c2 {color: purple}    /*有c1这个class的i标签*/    i.c1 {color: yellow}    /* 通用 */    * {color: black}&lt;/style&gt;</code></pre><h3 id="id-和-class的区别"><a href="#id-和-class的区别" class="headerlink" title="id 和 class的区别"></a>id 和 class的区别</h3><pre><code>1.class是设置标签的类， 用于指定元素属于何种样式的类2.ID是设置标签的标识。用于定义一个元素的独特的样式。3.class和ID的用法一样4.概念上说是不一样的    1.一个class是用来根据用户定义的样式对一个或者多个元素进行定义    2.ID通常用于定义页面上一个仅出现一次         </code></pre><h2 id="2-2组合选择器"><a href="#2-2组合选择器" class="headerlink" title="2.2组合选择器"></a>2.2组合选择器</h2><pre><code>1. 子子孙孙选择器（后代选择器）     --&gt; div p2. 儿子选择器                       --&gt; div&gt;p3. 毗邻选择器(紧挨着下面的标签)     --&gt; div+p4. 弟弟选择器(同级下面所有的标签)   --&gt; div~p</code></pre><h3 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h3><pre><code>&lt;style&gt;    /*找儿子标签：li的儿子a标签*/    li&gt;a {color: red}    /*子子孙孙中找标签*/    #d1 p {color: green}    /*毗邻选择器：找下面紧挨着的*/    div+p {color: blue}    /*弟弟选择器：同级往下面找 */    #d2~a {color: deeppink}&lt;/style&gt;</code></pre><h2 id="2-3-属性选择器"><a href="#2-3-属性选择器" class="headerlink" title="2.3 属性选择器"></a>2.3 属性选择器</h2><pre><code>1. 有某个属性的标签                 --&gt; div[title]2. 有属性并且属性值等于我给定的值   --&gt; div[title=&apos;hello&apos;]</code></pre><h3 id="代码实例-1"><a href="#代码实例-1" class="headerlink" title="代码实例"></a>代码实例</h3><pre><code>&lt;style&gt;    /* 找到所有有qs这个属性的标签 */    div[qs] {color: green}    /* 找到qs属性值是nb2的标签 */    div[qs=&apos;nb2&apos;] {color: yellow}    /*判断字符串是否包含给定的值*/    div[title*=&apos;hello&apos;] {color: blue}    /* 判断属性值按照空格分割得到的列表中是否包含指定的值 */    div[title~=&apos;hello&apos;] {color: deeppink}&lt;/style&gt;</code></pre><h2 id="2-4-分组和嵌套"><a href="#2-4-分组和嵌套" class="headerlink" title="2.4 分组和嵌套"></a>2.4 分组和嵌套</h2><pre><code>1. 分组应用于多个选择器找到的标签应用相同的样式时，为了避免重复写到一起    div, p {color: red}    &lt;style&gt;    /*#d1 {color: red}*/    /*.c1 {color: red}*/    #d1, .c1 {color: red}&lt;/style&gt;2. 基本选择器之间可以任意嵌套组合使用    .c1&gt;p </code></pre><h2 id="2-5-伪类选择器"><a href="#2-5-伪类选择器" class="headerlink" title="2.5 伪类选择器"></a>2.5 伪类选择器</h2><pre><code>&lt;style&gt;    a:link {        color: red;    }    /* 已访问的链接 */    a:visited {      color: green;    }    /*a标签被点击的那一刻*/    a:active {color: yellow}    /*鼠标移上去之后*/    span:hover {color: deeppink}    /*input输入框获取焦点时样式*/    input:focus {      background-color: red;    }&lt;/style&gt;</code></pre><h2 id="2-6-伪元素选择器-－１"><a href="#2-6-伪元素选择器-－１" class="headerlink" title="2.6 伪元素选择器　－１"></a>2.6 伪元素选择器　－１</h2><pre><code>&lt;style&gt;    /*没有访问*/   a:link {       color: red;   }    /*已访问的连接*/    a:visited {        color: green;    }    /*ａ标签被点击的那一刻*/    a:active {        color: yellow;    }    /*鼠标移动到便签时*/    a:hover {        color: #2b99ff;    }    /*input 点击输入框的时候的背景*/    input:focus {        background-color: red;    }&lt;/style&gt;</code></pre><h2 id="2-6-伪元素选择器-－2"><a href="#2-6-伪元素选择器-－2" class="headerlink" title="2.6 伪元素选择器　－2"></a>2.6 伪元素选择器　－2</h2><pre><code>&lt;style&gt;    /*首元素按照定义的格式*/    div.c1:first-letter {        color: red;font-size: 48px;    }    /*p标签首元素＋“×”*/    p:before {        content: &quot;lei&quot;;        color: blue;    }    /*p标签末尾加入*/    p:after {        content: &quot;[?]&quot;;        color: red;    }&lt;/style&gt;</code></pre><h2 id="元素选择器"><a href="#元素选择器" class="headerlink" title="元素选择器"></a>元素选择器</h2><pre><code>&lt;style&gt;    p {color: red}    div {color: #0000cc}&lt;/style&gt;</code></pre><h1 id="3-选择器的优先级"><a href="#3-选择器的优先级" class="headerlink" title="3. 选择器的优先级"></a>3. 选择器的优先级</h1><h2 id="3-1-当选择器相同的时候"><a href="#3-1-当选择器相同的时候" class="headerlink" title="3.1.当选择器相同的时候"></a>3.1.当选择器相同的时候</h2><pre><code>谁最后加载听谁的！</code></pre><p>##　3.2 选择器不同的时候</p><pre><code>1. 内联样式(1000) &gt; ID选择器(100) &gt; class选择器(10) &gt; 元素选择器(1)2. 不讲道理的!import</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-CSS（给HTML标签设置样式的）&quot;&gt;&lt;a href=&quot;#1-CSS（给HTML标签设置样式的）&quot; class=&quot;headerlink&quot; title=&quot;1. CSS（给HTML标签设置样式的）&quot;&gt;&lt;/a&gt;1. CSS（给HTML标签设置样式的）&lt;/h1&gt;&lt;h2
      
    
    </summary>
    
      <category term="html" scheme="http://yoursite.com/categories/html/"/>
    
    
      <category term="MySQL练习" scheme="http://yoursite.com/tags/MySQL%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>HTML初识</title>
    <link href="http://yoursite.com/2018/10/09/HTML%E5%88%9D%E8%AF%86/"/>
    <id>http://yoursite.com/2018/10/09/HTML初识/</id>
    <published>2018-10-09T13:25:52.811Z</published>
    <updated>2018-10-09T13:23:25.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="html初识"><a href="#html初识" class="headerlink" title="html初识"></a>html初识</h1><h2 id="1-CS-–-gt-BS架构"><a href="#1-CS-–-gt-BS架构" class="headerlink" title="1. CS   –&gt;  BS架构"></a>1. CS   –&gt;  BS架构</h2><h2 id="2-Web的原理"><a href="#2-Web的原理" class="headerlink" title="2. Web的原理"></a>2. Web的原理</h2><pre><code>浏览器地址栏输入URL--&gt; 浏览器往服务端发消息 --&gt; 服务端接收消息--&gt; 服务端回消息（从文件中读取数据）--&gt; 浏览器收到消息(按照一个约定好的规则展示出来)</code></pre><h2 id="3-HTML初识"><a href="#3-HTML初识" class="headerlink" title="3. HTML初识"></a>3. HTML初识</h2><pre><code>1. 就是一些特殊符号，不同的符号有不同的显示效果2. 学前端就是学怎么写HTML文件,学后端框架就是学怎么样返回写好的HTML文件</code></pre><h2 id="4-HTML规则：https-www-cnblogs-com-liwenzhou-p-7988087-html"><a href="#4-HTML规则：https-www-cnblogs-com-liwenzhou-p-7988087-html" class="headerlink" title="4. HTML规则：https://www.cnblogs.com/liwenzhou/p/7988087.html"></a>4. HTML规则：<a href="https://www.cnblogs.com/liwenzhou/p/7988087.html" target="_blank" rel="noopener">https://www.cnblogs.com/liwenzhou/p/7988087.html</a></h2><h3 id="4-1-HTML中把连续的空格和换行都解析成一个空格，不存在缩进的问题"><a href="#4-1-HTML中把连续的空格和换行都解析成一个空格，不存在缩进的问题" class="headerlink" title="4.1. HTML中把连续的空格和换行都解析成一个空格，不存在缩进的问题"></a>4.1. HTML中把连续的空格和换行都解析成一个空格，不存在缩进的问题</h3><h3 id="4-2-基本标签"><a href="#4-2-基本标签" class="headerlink" title="4.2. 基本标签"></a>4.2. 基本标签</h3><h3 id="4-3-块级标签和行内标签"><a href="#4-3-块级标签和行内标签" class="headerlink" title="4.3. 块级标签和行内标签"></a>4.3. 块级标签和行内标签</h3><pre><code>div和span标签的特点：    没有自带的样式，方便后续使用CSS调整样式！块级标签：    自己独占一行！    p    h1~h6    hr    div行内标签（内联标签）：    默认都在一行显示！    b、i、u、s    span</code></pre><h3 id="4-4-标签支持嵌套"><a href="#4-4-标签支持嵌套" class="headerlink" title="4.4. 标签支持嵌套"></a>4.4. 标签支持嵌套</h3><pre><code>1. 块级标签可以包含内联标签2. p标签不能包含p标签和div标签</code></pre><h3 id="4-5-标签分类"><a href="#4-5-标签分类" class="headerlink" title="4.5. 标签分类"></a>4.5. 标签分类</h3><pre><code>1. 展示给用户看的标签2. 获取用户输入的标签    form标签（表单标签）</code></pre><h2 id="表格-lt-DOCTYPE-html-gt"><a href="#表格-lt-DOCTYPE-html-gt" class="headerlink" title="表格&lt;!DOCTYPE html&gt;"></a>表格&lt;!DOCTYPE html&gt;</h2><pre><code>&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;!--&lt;table border=&quot;1&quot; cellpadding=&quot;10&quot; cellspacing=&quot;5&quot;&gt;--&gt;    &lt;table border=&quot;1&quot; &gt;        &lt;thead&gt;            &lt;tr&gt;                &lt;th&gt;id&lt;/th&gt;                &lt;th&gt;name&lt;/th&gt;                &lt;th&gt;pwd&lt;/th&gt;            &lt;/tr&gt;        &lt;/thead&gt;        &lt;tbody&gt;            &lt;tr&gt;                &lt;td&gt;1&lt;/td&gt;                &lt;td&gt;qwer&lt;/td&gt;                &lt;td&gt;1234&lt;/td&gt;            &lt;/tr&gt;            &lt;tr&gt;                &lt;td&gt;2&lt;/td&gt;                &lt;td&gt;qaz&lt;/td&gt;                &lt;td&gt;1234&lt;/td&gt;            &lt;/tr&gt;            &lt;tr&gt;                &lt;td&gt;3&lt;/td&gt;                &lt;td&gt;wen&lt;/td&gt;                &lt;td&gt;1234&lt;/td&gt;            &lt;/tr&gt;        &lt;/tbody&gt;    &lt;/table&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="获取用户输入的标签"><a href="#获取用户输入的标签" class="headerlink" title="获取用户输入的标签"></a>获取用户输入的标签</h2><h2 id="1-input"><a href="#1-input" class="headerlink" title="1. input"></a>1. input</h2><h3 id="1-根据type类型划分"><a href="#1-根据type类型划分" class="headerlink" title="1. 根据type类型划分"></a>1. 根据type类型划分</h3><pre><code>1. text2. password4. email5. date6. radio      --&gt; 单选7. checkbox   --&gt; 多选7. button     --&gt; 普通按钮，多用于使用JS代码绑定事件8. submit     --&gt; 提交9. reset      --&gt; 重置    10. file      --&gt; 上传文件</code></pre><h2 id="2-select"><a href="#2-select" class="headerlink" title="2. select"></a>2. select</h2><pre><code>1. select标签内部包含的是option，需要配置value属性    默认选中：selected=&quot;selected&quot;2. 多选    multiple3. textare</code></pre><h3 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h3><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;http://127.0.0.1:8081&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;    &lt;p&gt;        &lt;label for=&quot;i1&quot;&gt;用户名：&lt;/label&gt;      &lt;input id=&quot;i1&quot; type=&quot;text&quot; name=&quot;username&quot;&gt;    &lt;/p&gt;    &lt;p&gt;        &lt;label&gt;密码：            &lt;input type=&quot;password&quot; name=&quot;pwd&quot;&gt;        &lt;/label&gt;    &lt;/p&gt;    &lt;p&gt;        邮箱：        &lt;input disabled type=&quot;email&quot; name=&quot;email&quot;&gt;    &lt;/p&gt;    &lt;p&gt;出生日期：        &lt;input type=&quot;date&quot; name=&quot;birthday&quot;&gt;    &lt;/p&gt;    &lt;p&gt;        头像：        &lt;input type=&quot;file&quot; name=&quot;avatar&quot;&gt;    &lt;/p&gt;    &lt;p&gt;        隐藏的输入框：        &lt;input type=&quot;hidden&quot;&gt;    &lt;/p&gt;    &lt;p&gt;性别：        &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;male&quot; checked&gt;男        &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;female&quot;&gt;女    &lt;/p&gt;    &lt;p&gt;        爱好：        &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;basketball&quot;&gt;篮球        &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;football&quot;&gt;足球        &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;doublecolorball&quot;&gt;双色球    &lt;/p&gt;    &lt;label for=&quot;s1&quot;&gt;城市&lt;/label&gt;    &lt;select id=&quot;s1&quot; name=&quot;city1&quot;&gt;        &lt;option value=&quot;010&quot;&gt;北京&lt;/option&gt;        &lt;option value=&quot;021&quot;&gt;上海&lt;/option&gt;        &lt;option value=&quot;020&quot;&gt;广州&lt;/option&gt;        &lt;option value=&quot;0755&quot; selected=&quot;selected&quot;&gt;深圳&lt;/option&gt;    &lt;/select&gt;     &lt;select name=&quot;city2&quot; multiple=&quot;multiple&quot;&gt;            &lt;option value=&quot;010&quot;&gt;北京&lt;/option&gt;        &lt;option value=&quot;021&quot;&gt;上海&lt;/option&gt;        &lt;option value=&quot;020&quot;&gt;广州&lt;/option&gt;        &lt;option value=&quot;0755&quot; selected=&quot;selected&quot;&gt;深圳&lt;/option&gt;    &lt;/select&gt;    &lt;p&gt;        个人简介：        &lt;textarea name=&quot;info&quot;  cols=&quot;60&quot; rows=&quot;40&quot;&gt;        &lt;/textarea&gt;    &lt;/p&gt;    &lt;input type=&quot;button&quot; value=&quot;按钮&quot;&gt;    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;    &lt;input type=&quot;reset&quot; value=&quot;重置&quot;&gt;&lt;/form&gt;{&quot;name属性的值&quot;: 用户填写的内容}&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h2><pre><code>1. 所有放在form标签中获取用户输入的标签，必须要有name属性2. form标签有action属性和method属性    1. action：控制往哪里提交数据    2. method：控制用什么方式提交    3. 上传文件需要额外配置enctype=&quot;multipart/form-data&quot;3. form要提交数据必须要有submit按钮        </code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;html初识&quot;&gt;&lt;a href=&quot;#html初识&quot; class=&quot;headerlink&quot; title=&quot;html初识&quot;&gt;&lt;/a&gt;html初识&lt;/h1&gt;&lt;h2 id=&quot;1-CS-–-gt-BS架构&quot;&gt;&lt;a href=&quot;#1-CS-–-gt-BS架构&quot; class=&quot;
      
    
    </summary>
    
      <category term="html" scheme="http://yoursite.com/categories/html/"/>
    
    
      <category term="MySQL练习" scheme="http://yoursite.com/tags/MySQL%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Mysql 小练习</title>
    <link href="http://yoursite.com/2018/10/08/mysql%E7%BB%83%E4%B9%A0%20copy/"/>
    <id>http://yoursite.com/2018/10/08/mysql练习 copy/</id>
    <published>2018-10-08T12:32:11.783Z</published>
    <updated>2018-10-08T12:32:11.784Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、查询男生、女生的人数；"><a href="#1、查询男生、女生的人数；" class="headerlink" title="1、查询男生、女生的人数；"></a>1、查询男生、女生的人数；</h2><pre><code>select gender, count(gender) from student group by gender;</code></pre><p>  +——–+—————+<br>    | gender | count(gender) |<br>    +——–+—————+<br>    | 女     |             6 |<br>    | 男     |            10 |<br>    +——–+—————+</p><h2 id="2、查询姓“张”的学生名单；"><a href="#2、查询姓“张”的学生名单；" class="headerlink" title="2、查询姓“张”的学生名单；"></a>2、查询姓“张”的学生名单；</h2><pre><code>select * from student where sname like &apos;张%&apos;;</code></pre><p>  +—–+——–+———-+——–+<br>    | sid | gender | class_id | sname  |<br>    +—–+——–+———-+——–+<br>    |   3 | 男     |        1 | 张三   |<br>    |   4 | 男     |        1 | 张一   |<br>    |   5 | 女     |        1 | 张二   |<br>    |   6 | 男     |        1 | 张四   |<br>    +—–+——–+———-+——–+</p><h2 id="3、课程平均分从高到低显示"><a href="#3、课程平均分从高到低显示" class="headerlink" title="3、课程平均分从高到低显示"></a>3、课程平均分从高到低显示</h2><pre><code>select * ,avg(num) from score group by course_id order by  avg(num) asc;</code></pre><p>  +—–+————+———–+—–+———-+<br>    | sid | student_id | course_id | num | avg(num) |<br>    +—–+————+———–+—–+———-+<br>    |   1 |          1 |         1 |  10 |  53.4167 |<br>    |   8 |          2 |         3 |  68 |  64.4167 |<br>    |   2 |          1 |         2 |   9 |  65.0909 |<br>    |   5 |          1 |         4 |  66 |  85.2500 |<br>    +—–+————+———–+—–+———-+</p><h2 id="4、查询有课程成绩小于60分的同学的学号、姓名；"><a href="#4、查询有课程成绩小于60分的同学的学号、姓名；" class="headerlink" title="4、查询有课程成绩小于60分的同学的学号、姓名；"></a>4、查询有课程成绩小于60分的同学的学号、姓名；</h2><pre><code> select sname, student_id from score, student where student.sid = score.student_id and score.num &lt; 60;+--------+------------+| sname  | student_id |+--------+------------+| 理解   |          1 || 理解   |          1 || 钢蛋   |          2 || 张一   |          4 || 张二   |          5 || 张四   |          6 || 铁锤   |          7 || 李三   |          8 || 李一   |          9 || 李二   |         10 || 李四   |         11 || 如花   |         12 |+--------+------------+</code></pre><h2 id="5、查询至少有一门课与学号为1的同学所学课程相同的同学的学号和姓名；"><a href="#5、查询至少有一门课与学号为1的同学所学课程相同的同学的学号和姓名；" class="headerlink" title="5、查询至少有一门课与学号为1的同学所学课程相同的同学的学号和姓名；"></a>5、查询至少有一门课与学号为1的同学所学课程相同的同学的学号和姓名；</h2><pre><code>  select sname, sid from student where sid in (     select student_id from score where course_id in    (select course_id from score where student_id = 1)        group by student_id having student_id != 1);+--------+-----+| sname  | sid |+--------+-----+| 钢蛋   |   2 || 张三   |   3 || 张一   |   4 || 张二   |   5 || 张四   |   6 || 铁锤   |   7 || 李三   |   8 || 李一   |   9 || 李二   |  10 || 李四   |  11 || 如花   |  12 |+--------+-----+</code></pre><h2 id="6、查询出只选修了一门课程的全部学生的学号和姓名；"><a href="#6、查询出只选修了一门课程的全部学生的学号和姓名；" class="headerlink" title="6、查询出只选修了一门课程的全部学生的学号和姓名；"></a>6、查询出只选修了一门课程的全部学生的学号和姓名；</h2><pre><code>select sid, sname from student where sid in (select student_id from score group by     student_id having count(student_id) =1 );+-----+--------+| sid | sname  |+-----+--------+|  13 | 刘三   |+-----+--------+</code></pre><h2 id="7、查询各科成绩最高和最低的分：以如下形式显示：课程ID，最高分，最低分；"><a href="#7、查询各科成绩最高和最低的分：以如下形式显示：课程ID，最高分，最低分；" class="headerlink" title="7、查询各科成绩最高和最低的分：以如下形式显示：课程ID，最高分，最低分；"></a>7、查询各科成绩最高和最低的分：以如下形式显示：课程ID，最高分，最低分；</h2><pre><code>select course_id, max(num) as &apos;最高分&apos;, min(num) as &apos;最低分&apos; from score group by course_id; +-----------+-----------+-----------+| course_id | 最高分    | 最低分    |+-----------+-----------+-----------+|         1 |        91 |         8 ||         2 |       100 |         9 ||         3 |        87 |        43 ||         4 |       100 |        22 |+-----------+-----------+-----------+</code></pre><h2 id="8、查询课程编号“2”的成绩比课程编号“1”课程低的所有同学的学号、姓名；"><a href="#8、查询课程编号“2”的成绩比课程编号“1”课程低的所有同学的学号、姓名；" class="headerlink" title="8、查询课程编号“2”的成绩比课程编号“1”课程低的所有同学的学号、姓名；"></a>8、查询课程编号“2”的成绩比课程编号“1”课程低的所有同学的学号、姓名；</h2><pre><code>方法1：select sid, sname from student where (select num from score where course_id =1 and student.sid =student_id) &gt; (select num from score where course_id =2 and student.sid =student_id); 方法2：  select s1.student_id, s1.num as slnum, s2.num as s2num from score as s1, score as s2 where s1.student_id = s2.student_id and s1.course_id = 1 and s2.course_id =2 and s1.num &gt; s2.num;+------------+-------+-------+| student_id | slnum | s2num |+------------+-------+-------+|          1 |    10 |     9 ||          3 |    77 |    66 ||          4 |    79 |    11 ||          5 |    79 |    11 ||          9 |    91 |    88 ||         10 |    90 |    77 ||         11 |    90 |    77 ||         12 |    90 |    77 |+------------+-------+-------+</code></pre><h2 id="9、查询“生物”课程比“物理”课程成绩高的所有学生的学号；"><a href="#9、查询“生物”课程比“物理”课程成绩高的所有学生的学号；" class="headerlink" title="9、查询“生物”课程比“物理”课程成绩高的所有学生的学号；"></a>9、查询“生物”课程比“物理”课程成绩高的所有学生的学号；</h2><pre><code>方法 1： 分开查询select student.sid, student.sname from student where  (select num from score, course  where course_id = course.cid and course.cname = &apos;生物&apos; and student_id=student.sid) &gt;   (select num from score, course  where course_id = course.cid and course.cname = &apos;物理&apos; and student_id= student.sid);方法2：select s1.student_id from score as s1, score as s2 where-&gt; s1.student_id = s2.student_id and s1.course_id =(select cid from course where cname = &apos;生物&apos;) and s2.course_id =(select cid from course where cname =&apos;物理&apos;) and s1.num &gt; s2.num;+------------+| student_id |+------------+|          1 ||          3 ||          4 ||          5 ||          9 ||         10 ||         11 ||         12 |+------------+</code></pre><h2 id="10、查询平均成绩大于60分的同学的学号和平均成绩"><a href="#10、查询平均成绩大于60分的同学的学号和平均成绩" class="headerlink" title="10、查询平均成绩大于60分的同学的学号和平均成绩;"></a>10、查询平均成绩大于60分的同学的学号和平均成绩;</h2><pre><code>select sid, avg(num) from score group by student_id having avg(num) &gt; 60;</code></pre><h2 id="11、查询所有同学的学号、姓名、选课数、总成绩；"><a href="#11、查询所有同学的学号、姓名、选课数、总成绩；" class="headerlink" title="11、查询所有同学的学号、姓名、选课数、总成绩；"></a>11、查询所有同学的学号、姓名、选课数、总成绩；</h2><pre><code>select student.sname as 姓名, score.student_id as 学号, count(score.course_id) as 选课数,  sum(score.num) as 总成绩 from student ,score where student.sid = score.student_id group by score.student_id;+--------+--------+-----------+-----------+| 姓名   | 学号   | 选课数    | 总成绩    |+--------+--------+-----------+-----------+| 理解   |      1 |         3 |        85 || 钢蛋   |      2 |         3 |       175 || 张三   |      3 |         4 |       329 || 张一   |      4 |         4 |       257 || 张二   |      5 |         4 |       257 || 张四   |      6 |         4 |       276 || 铁锤   |      7 |         4 |       264 || 李三   |      8 |         4 |       264 || 李一   |      9 |         4 |       268 || 李二   |     10 |         4 |       297 || 李四   |     11 |         4 |       297 || 如花   |     12 |         4 |       297 || 刘三   |     13 |         1 |        87 |+--------+--------+-----------+-----------+</code></pre><h2 id="12、查询姓“李”的老师的个数；"><a href="#12、查询姓“李”的老师的个数；" class="headerlink" title="12、查询姓“李”的老师的个数；"></a>12、查询姓“李”的老师的个数；</h2><pre><code>方法1；select  count(tname) from teacher where tname like &apos;李%&apos;;方法2；select count(tid) from teacher where tname like &apos;李%&apos;;+--------------+| count(tname) |+--------------+|            2 |+--------------+</code></pre><h2 id="13、查询没学过“张磊老师”课的同学的学号、姓名；"><a href="#13、查询没学过“张磊老师”课的同学的学号、姓名；" class="headerlink" title="13、查询没学过“张磊老师”课的同学的学号、姓名；"></a>13、查询没学过“张磊老师”课的同学的学号、姓名；</h2><pre><code>select sid, sname from student where sid not in ( select student_id from score where course_id =(  select cid from course where teacher_id=( select tid from teacher where tname = &apos;张磊老师&apos;)));</code></pre><h2 id="14、查询学过“1”并且也学过编号“2”课程的同学的学号、姓名；"><a href="#14、查询学过“1”并且也学过编号“2”课程的同学的学号、姓名；" class="headerlink" title="14、查询学过“1”并且也学过编号“2”课程的同学的学号、姓名；"></a>14、查询学过“1”并且也学过编号“2”课程的同学的学号、姓名；</h2><pre><code>select sid, sname from student where sid in ( select s1.student_id from score as s1, score as s2 where s1.student_id = s2.student_id and s1.course_id = 1 and  s2.course_id =2);+-----+--------+| sid | sname  |+-----+--------+|   1 | 理解   ||   3 | 张三   ||   4 | 张一   ||   5 | 张二   ||   6 | 张四   ||   7 | 铁锤   ||   8 | 李三   ||   9 | 李一   ||  10 | 李二   ||  11 | 李四   ||  12 | 如花   |+-----+--------+</code></pre><h2 id="15、查询学过“李平老师”所教的所有课的同学的学号、姓名；"><a href="#15、查询学过“李平老师”所教的所有课的同学的学号、姓名；" class="headerlink" title="15、查询学过“李平老师”所教的所有课的同学的学号、姓名；"></a>15、查询学过“李平老师”所教的所有课的同学的学号、姓名；</h2><pre><code>select sid, sname from student where sid in ( select student_id from score where course_id in ( select cid from course where teacher_id =( select tid from teacher where tname = &apos;李平老师&apos;)) group by student_id);+-----+--------+| sid | sname  |+-----+--------+|   1 | 理解   ||   2 | 钢蛋   ||   3 | 张三   ||   4 | 张一   ||   5 | 张二   ||   6 | 张四   ||   7 | 铁锤   ||   8 | 李三   ||   9 | 李一   ||  10 | 李二   ||  11 | 李四   ||  12 | 如花   |+-----+--------+</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1、查询男生、女生的人数；&quot;&gt;&lt;a href=&quot;#1、查询男生、女生的人数；&quot; class=&quot;headerlink&quot; title=&quot;1、查询男生、女生的人数；&quot;&gt;&lt;/a&gt;1、查询男生、女生的人数；&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;select gender, cou
      
    
    </summary>
    
      <category term="mysql" scheme="http://yoursite.com/categories/mysql/"/>
    
    
      <category term="MySQL练习" scheme="http://yoursite.com/tags/MySQL%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Mysql增删改查</title>
    <link href="http://yoursite.com/2018/10/08/Mysql%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/"/>
    <id>http://yoursite.com/2018/10/08/Mysql增删改查/</id>
    <published>2018-10-08T08:11:58.327Z</published>
    <updated>2018-10-08T08:25:53.468Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL数据操作： DML<br>在MySQL管理软件中，可以通过SQL语句中的DML语言来实现数据的操作，包括</p><ol><li>使用INSERT实现数据的插入</li><li>UPDATE实现数据的更新</li><li>使用DELETE实现数据的删除</li><li>使用SELECT查询数据以及。</li></ol><h1 id="insert-插入数据"><a href="#insert-插入数据" class="headerlink" title="insert 插入数据"></a>insert 插入数据</h1><h2 id="插入完整数据"><a href="#插入完整数据" class="headerlink" title="插入完整数据"></a>插入完整数据</h2><pre><code>insert into class values(1, &apos;语文&apos;);</code></pre><h2 id="插入指定字段数据"><a href="#插入指定字段数据" class="headerlink" title="插入指定字段数据"></a>插入指定字段数据</h2><pre><code>insert into class(name) values(&apos;数学&apos;);</code></pre><h2 id="插入多条的数据"><a href="#插入多条的数据" class="headerlink" title="插入多条的数据"></a>插入多条的数据</h2><pre><code>insert into class(name) values(&apos;数学&apos;), (&apos;物理&apos;), (&apos;化学&apos;), (&apos;历史&apos;);</code></pre><h2 id="插入查询结果"><a href="#插入查询结果" class="headerlink" title="插入查询结果"></a>插入查询结果</h2><pre><code>insert into student(class_id) select id from class where name = &apos;语文&apos;;</code></pre><h2 id="导入sql文件"><a href="#导入sql文件" class="headerlink" title="导入sql文件"></a>导入sql文件</h2><pre><code>source /root/init.sql</code></pre><h1 id="update-更新数据"><a href="#update-更新数据" class="headerlink" title="update 更新数据"></a>update 更新数据</h1><pre><code>update class set name = &apos; 文学&apos; where id = 1;</code></pre><h1 id="delete-删除数据"><a href="#delete-删除数据" class="headerlink" title="delete 删除数据"></a>delete 删除数据</h1><pre><code>delete from class where id = 1;删除id = 1的数据</code></pre><h1 id="select查询–单表查询"><a href="#select查询–单表查询" class="headerlink" title="select查询–单表查询"></a>select查询–单表查询</h1><h3 id="单表查询的语法"><a href="#单表查询的语法" class="headerlink" title="单表查询的语法"></a>单表查询的语法</h3><pre><code>SELECT 字段1,字段2... FROM 表名                     WHERE 条件                     GROUP BY field                     HAVING 筛选                     ORDER BY field                     LIMIT 限制条数</code></pre><h3 id="关键字执行的优先级"><a href="#关键字执行的优先级" class="headerlink" title="关键字执行的优先级"></a>关键字执行的优先级</h3><pre><code>fromwheregroup byhavingselectdistinctorder bylimit1.找到表:from2.拿着where指定的约束条件，去文件/表中取出一条条记录3.将取出的一条条记录进行分组group by，如果没有group by，则整体作为一组4.将分组的结果进行having过滤5.执行select6.去重7.将结果按条件排序：order by8.限制结果的显示条数</code></pre><h2 id="简单查询"><a href="#简单查询" class="headerlink" title="简单查询"></a>简单查询</h2><h3 id="按字段查找"><a href="#按字段查找" class="headerlink" title="按字段查找"></a>按字段查找</h3><pre><code>select 字段,字段，... from 表;</code></pre><h3 id="查询所有"><a href="#查询所有" class="headerlink" title="查询所有"></a>查询所有</h3><pre><code>select * from 表;</code></pre><h3 id="避免重复-distinct"><a href="#避免重复-distinct" class="headerlink" title="避免重复 distinct"></a>避免重复 distinct</h3><pre><code>select distinct 字段 from 表;</code></pre><h3 id="通过四则运算查询"><a href="#通过四则运算查询" class="headerlink" title="通过四则运算查询"></a>通过四则运算查询</h3><pre><code>1. select 字段, 字段（能进行运算的类型） from 表;2. select 字段, 字段（能进行运算的类型）  as 别名 from 表;</code></pre><h3 id="定义显示格式"><a href="#定义显示格式" class="headerlink" title="定义显示格式"></a>定义显示格式</h3><pre><code>连接字符串 concat()select concat(&apos;姓名:&apos;, emp_name, &apos;年薪:&apos;, salary*12) as Annual_salary from employee;</code></pre><h3 id="以第一个参数为分隔符-concan-ws"><a href="#以第一个参数为分隔符-concan-ws" class="headerlink" title="以第一个参数为分隔符() concan_ws"></a>以第一个参数为分隔符() concan_ws</h3><pre><code>select concat_ws(&apos;:&apos;, emp_name, salary*12) as Annual_salary from employee;</code></pre><h3 id="结合case语句："><a href="#结合case语句：" class="headerlink" title="结合case语句："></a>结合case语句：</h3><pre><code>条件判断符合条件进行字符串拼接SELECT   (       CASE       WHEN emp_name = &apos;jingliyang&apos; THEN           emp_name       WHEN emp_name = &apos;alex&apos; THEN           CONCAT(emp_name,&apos;_BIGSB&apos;)       ELSE           concat(emp_name, &apos;SB&apos;)       END   ) as new_name</code></pre><p>   FROM<br>       employee;</p><h2 id="where约束"><a href="#where约束" class="headerlink" title="where约束"></a>where约束</h2><ol><li>比较运算符：&gt; &lt; &gt;= &lt;= &lt;&gt; !=</li><li>between 80 and 100 值在10到20之间</li><li>in(80,90,100) 值是10或20或30</li><li>like ‘egon%’<br> pattern可以是%或_，<br> %表示任意多字符<br> _表示一个字符 </li><li>逻辑运算符：在多个条件直接可以使用逻辑运算符 and or not<h3 id="单条件查询"><a href="#单条件查询" class="headerlink" title="单条件查询"></a>单条件查询</h3></li></ol><pre><code>查询所以 post =&apos;sale&apos; 数据select emp_name from employee where post =&apos;sale&apos;;</code></pre><h3 id="多条件查询"><a href="#多条件查询" class="headerlink" title="多条件查询"></a>多条件查询</h3><pre><code>and 多条件select emp_name, salary  from employee where post =&apos;teacher&apos; and salary &gt; 1000;between 在指定范围内 and是指定范围not between 不在指定范围select emp_name, salary  from employee where salary between 10000 and 20000;</code></pre><h3 id="关键字IS-NULL-判断某个字段是否为NULL不能用等号，需要用IS"><a href="#关键字IS-NULL-判断某个字段是否为NULL不能用等号，需要用IS" class="headerlink" title="关键字IS NULL(判断某个字段是否为NULL不能用等号，需要用IS)"></a>关键字IS NULL(判断某个字段是否为NULL不能用等号，需要用IS)</h3><pre><code>需要注意 空字符串不是nullselect emp_name, post_comment from employee where post_comment is null;</code></pre><h3 id="关键字IN集合查SELECT-emp-name-salary-FROM-employee"><a href="#关键字IN集合查SELECT-emp-name-salary-FROM-employee" class="headerlink" title="关键字IN集合查SELECT emp_name,salary FROM employee"></a>关键字IN集合查SELECT emp_name,salary FROM employee</h3><pre><code>or 满足一个就行WHERE salary=3000 OR salary=3500 OR salary=4000 OR salary=9000 ;in 代替了 or语句SELECT emp_name,salary FROM employee     WHERE salary IN (3000,3500,4000,9000) ;不在in集合里面SELECT emp_name,salary FROM employee     WHERE salary NOT IN (3000,3500,4000,9000) ;</code></pre><p>###关键字LIKE模糊查询<br>    通配符’%’ 所有<br>    SELECT * FROM employee<br>            WHERE emp_name LIKE ‘eg%’;</p><pre><code>通配符’_’_ 一个占位一个字符SELECT * FROM employee         WHERE emp_name LIKE &apos;al__&apos;;</code></pre><h3 id="group-by"><a href="#group-by" class="headerlink" title="group by"></a>group by</h3><p>单独使用GROUP BY关键字分组<br>    SELECT post FROM employee GROUP BY post;<br>    注意：我们按照post字段分组，那么select查询的字段只能是post，想要获取组内的其他相关信息，需要借助函数</p><h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><p><strong>强调：聚合函数聚合的是组的内容，若是没有分组，则默认一组</strong></p><pre><code>示例：SELECT COUNT(*) FROM employee;SELECT COUNT(*) FROM employee WHERE depart_id=1;SELECT MAX(salary) FROM employee;SELECT MIN(salary) FROM employee;SELECT AVG(salary) FROM employee;SELECT SUM(salary) FROM employee;SELECT SUM(salary) FROM employee WHERE depart_id=3;</code></pre><h3 id="HAVING过滤"><a href="#HAVING过滤" class="headerlink" title="HAVING过滤"></a>HAVING过滤</h3><p>HAVING与WHERE不一样的地方在于!!!!!!</p><pre><code>！！！执行优先级从高到低：where &gt; group by &gt; having 1. Where 发生在分组group by之前，因而Where中可以有任意字段，但是绝对不能使用聚合函数。2. Having发生在分组group by之后，因而Having中可以使用分组的字段，无法直接取到其他字段,可以使用聚合函数</code></pre><h3 id="ORDER-BY-查询排序"><a href="#ORDER-BY-查询排序" class="headerlink" title="ORDER BY 查询排序"></a>ORDER BY 查询排序</h3><pre><code>按单列排序SELECT * FROM employee ORDER BY salary; #默认SELECT * FROM employee ORDER BY salary ASC; #从小到大SELECT * FROM employee ORDER BY salary DESC; #从大到小</code></pre><h3 id="LIMIT-限制查询的记录数"><a href="#LIMIT-限制查询的记录数" class="headerlink" title="LIMIT 限制查询的记录数"></a>LIMIT 限制查询的记录数</h3><pre><code>  SELECT * FROM employee ORDER BY salary DESC     LIMIT 3;      #默认初始位置为0，向后查询3条 SELECT * FROM employee ORDER BY salary DESC    LIMIT 5,5; #从第5开始，即先查询出第一条，然后包含这一条在内往后查5条</code></pre><h3 id="使用正则表达式查询"><a href="#使用正则表达式查询" class="headerlink" title="使用正则表达式查询"></a>使用正则表达式查询</h3><pre><code>SELECT * FROM employee WHERE emp_name REGEXP &apos;^ale&apos;;SELECT * FROM employee WHERE emp_name REGEXP &apos;on$&apos;;SELECT * FROM employee WHERE emp_name REGEXP &apos;m{2}&apos;;小结：对字符串匹配的方式WHERE emp_name = &apos;egon&apos;;WHERE emp_name LIKE &apos;yua%&apos;;WHERE emp_name REGEXP &apos;on$&apos;;</code></pre><h1 id="select查询–多表查询"><a href="#select查询–多表查询" class="headerlink" title="select查询–多表查询"></a>select查询–多表查询</h1><h2 id="交叉连接：不适用任何匹配条件。生成笛卡尔积"><a href="#交叉连接：不适用任何匹配条件。生成笛卡尔积" class="headerlink" title="交叉连接：不适用任何匹配条件。生成笛卡尔积"></a>交叉连接：不适用任何匹配条件。生成笛卡尔积</h2><pre><code>select * from 表一, 表2;</code></pre><h2 id="内连接：只连接匹配的行"><a href="#内连接：只连接匹配的行" class="headerlink" title="内连接：只连接匹配的行"></a>内连接：只连接匹配的行</h2><pre><code>主要语法： 表 inner join  表 （建立连接）  on （条件）**employee inner join departmenton employee.dep_id=department.id;  //可换成where employee.dep_id=department.id**select employee.id,employee.name,employee.age,employee.sex,department.namefrom employee inner join departmenton employee.dep_id=department.id;</code></pre><h2 id="外链接之左连接：优先显示左表全部记录"><a href="#外链接之左连接：优先显示左表全部记录" class="headerlink" title="外链接之左连接：优先显示左表全部记录"></a>外链接之左连接：优先显示左表全部记录</h2><pre><code>#以左表为准，即找出所有员工信息，当然包括没有部门的员工#本质就是：在内连接的基础上增加左边有右边没有的结果mysql&gt; select employee.id,employee.name,department.name as depart_name from employee left join department on  #右边没有的选项也匹配， 以左边为准 employee.dep_id=department.id;</code></pre><h2 id="外链接之右连接：优先显示右表全部记录"><a href="#外链接之右连接：优先显示右表全部记录" class="headerlink" title="外链接之右连接：优先显示右表全部记录"></a>外链接之右连接：优先显示右表全部记录</h2><pre><code>和左连接一样 关键字right</code></pre><h2 id="全外连接：显示左右两个表全部记录"><a href="#全外连接：显示左右两个表全部记录" class="headerlink" title="全外连接：显示左右两个表全部记录"></a>全外连接：显示左右两个表全部记录</h2><p>全外连接：在内连接的基础上增加左边有右边没有的和右边有左边没有的结果<br><strong>注意：mysql不支持全外连接 full JOIN</strong><br><strong>强调：mysql可以使用此种方式间接实现全外连接</strong><br>    思路： 查询两个表用union 连接起来<br>    select <em> from employee left join department on employee.dep_id = department.id<br>    union<br>    select </em> from employee right join department on employee.dep_id = department.id</p><h2 id="符合条件连接查询"><a href="#符合条件连接查询" class="headerlink" title="符合条件连接查询"></a>符合条件连接查询</h2><h3 id="内连接的方式查询加入判断条件"><a href="#内连接的方式查询加入判断条件" class="headerlink" title="内连接的方式查询加入判断条件"></a>内连接的方式查询加入判断条件</h3><pre><code>select employee.name,department.name from employee inner join departmenton employee.dep_id = department.idwhere age &gt; 25;</code></pre><h3 id="内连接-asc-升序排列"><a href="#内连接-asc-升序排列" class="headerlink" title="内连接 asc 升序排列"></a>内连接 asc 升序排列</h3><pre><code>select employee.id,employee.name,employee.age,department.name from employee,departmentwhere employee.dep_id = department.idand age &gt; 25order by age asc;</code></pre><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>1：子查询是将一个查询语句嵌套在另一个查询语句中。<br>2：内层查询语句的查询结果，可以为外层查询语句提供查询条件。<br>3：子查询中可以包含：IN、NOT IN、ANY、ALL、EXISTS 和 NOT EXISTS等关键字<br>4：还可以包含比较运算符：= 、 !=、&gt; 、&lt;等</p><h3 id="带IN关键字的子查询"><a href="#带IN关键字的子查询" class="headerlink" title="带IN关键字的子查询"></a>带IN关键字的子查询</h3><pre><code>avg（求平均值） group by 那个组select id, name from department  where id in (select dep_id  from employee group by dep_id having avg(age) &gt; 25);distinct 不同的 结果是查询人数不足一个也就是没有的人的部门select name from department where id not in (select distinct dep_id from employee);</code></pre><h3 id="带比较运算符的子查询"><a href="#带比较运算符的子查询" class="headerlink" title="带比较运算符的子查询"></a>带比较运算符的子查询</h3><p>比较运算符：=、!=、&gt;、&gt;=、&lt;、&lt;=、&lt;&gt;<br>查询大于所有人平均年龄的员工名与年龄</p><pre><code> select name, age from employee where age &gt; (select avg(age) from employee);select t1.name,t1.age from employee    select t1.name,t1.age from employeeinner join(select dep_id,avg(age) avg_age from employee group by dep_id)on t1.dep_id = t2.dep_idwhere t1.age &gt; t2.avg_age; 查询大于部门内平均年龄的员工名、年龄#语法分析： 1.(select dep_id,avg(age) avg_age from employee group by dep_id) 形成一个新表avg_age2.inner join 连接select employee.name,employee.age from employeeinner join (select dep_id,avg(age) avg_age from employee group by dep_id) departmenton employee.dep_id = department.dep_idwhere employee.age &gt; department.avg_age;  </code></pre><h3 id="带EXISTS关键字的子查询"><a href="#带EXISTS关键字的子查询" class="headerlink" title="带EXISTS关键字的子查询"></a>带EXISTS关键字的子查询</h3><p>EXISTS关字键字表示存在。在使用EXISTS关键字时，内层查询语句不返回查询的记录。<br>而是返回一个真假值。True或False<br>当返回True时，外层查询语句将进行查询；当返回值为False时，外层查询语句不进行查询<br>    当子查询为true 显示结果 否则不显示<br>    select * from employee<br>        where exists<br>        (select id from department where id = 200);</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;MySQL数据操作： DML&lt;br&gt;在MySQL管理软件中，可以通过SQL语句中的DML语言来实现数据的操作，包括&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用INSERT实现数据的插入&lt;/li&gt;
&lt;li&gt;UPDATE实现数据的更新&lt;/li&gt;
&lt;li&gt;使用DELETE实现数据的删除&lt;/l
      
    
    </summary>
    
      <category term="mysql" scheme="http://yoursite.com/categories/mysql/"/>
    
    
      <category term="数据操作" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>PyMysql模块学习</title>
    <link href="http://yoursite.com/2018/10/08/Python_mysql/"/>
    <id>http://yoursite.com/2018/10/08/Python_mysql/</id>
    <published>2018-10-08T06:47:14.000Z</published>
    <updated>2018-10-08T08:01:08.858Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一：连接Mysql数据库"><a href="#一：连接Mysql数据库" class="headerlink" title="一：连接Mysql数据库"></a>一：连接Mysql数据库</h1><p>1.1连接条件：</p><ol><li>首先有个启动的mysql数据</li><li>有连接数据库的账号和密码</li><li>有权限操作数据库</li></ol><p>1.2使用pymysql</p><pre><code>import pymysql  #导入模块conn = pymysql.connect(    host=&apos;127.0.0.1&apos;,  #连接地址    port=&apos;3306&apos;,  #端口    user=&apos;root&apos;,  #mysql用户名    password=&apos;123&apos;,  #密码    database=&apos;db1008&apos;,  #数据库    charset=&apos;utf8&apos;  #编码方式)cursor = conn.cursor()  #获取光标对象，才可以操作数据库cursor.execute(&apos;show tables;&apos;)  #执行sql操作cursor.close()  #关闭光标conn.close()  #关闭连接</code></pre><h1 id="二：使用pymsql增删改查"><a href="#二：使用pymsql增删改查" class="headerlink" title="二：使用pymsql增删改查"></a>二：使用pymsql增删改查</h1><h2 id="2-1增删改（用到的操作相似）"><a href="#2-1增删改（用到的操作相似）" class="headerlink" title="2.1增删改（用到的操作相似）"></a>2.1增删改（用到的操作相似）</h2><pre><code>import pymysqlconn = pymysql.connect(    host=&apos;127.0.0.1&apos;,    port=3306,    user=&apos;root&apos;,    password=&apos;123&apos;,    database=&apos;db1008&apos;,    charset=&apos;utf8&apos;)cursor = conn.cursor()name = input(&apos;input_name:&apos;)pwd = input(&apos;inputZ_pwd:&apos;)#增加操作sql = &apos;insert into userinfo(username, possword) values(%s, %s);&apos;cursor.execute(sql,[name, pwd])  #防止SQL注入问题conn.commit()  #更新数据库 否则添加失败conn.rollback() 回滚取消操作。不进行添加#删除操作sql = &apos;delete from userinfo where username=%s and possword=%s&apos;cursor.execute(sql,[name, pwd])  #防止SQL注入问题#改操作sql = &apos;update userinfo set username=%s  where  possword=%s&apos;cursor.execute(sql,[name, pwd])  #防止SQL注入问题cursor.close()conn.close()</code></pre><h3 id="2-1-1-获取插入数据的ID-关联操作时会用到"><a href="#2-1-1-获取插入数据的ID-关联操作时会用到" class="headerlink" title="2.1.1 获取插入数据的ID(关联操作时会用到)"></a>2.1.1 获取插入数据的ID(关联操作时会用到)</h3><pre><code>import pymysqlconn = pymysql.connect(    host=&apos;127.0.0.1&apos;,    port=3306,    user=&apos;root&apos;,    password=&apos;123&apos;,    database=&apos;db1008&apos;,    charset=&apos;utf8&apos;)cursor = conn.cursor()name = input(&apos;input_name:&apos;)pwd = input(&apos;inputZ_pwd:&apos;)sql = &quot;insert into userinfo values(3,%s,%s);&quot;cursor.execute(sql, [name, pwd])conn.commit()id = cursor.lastrowidprint(id)cursor.close()conn.close()</code></pre><h2 id="2-2查询"><a href="#2-2查询" class="headerlink" title="2.2查询"></a>2.2查询</h2><h3 id="ret-cursor-fetchone-单行查询"><a href="#ret-cursor-fetchone-单行查询" class="headerlink" title="ret = cursor.fetchone()  # 单行查询"></a>ret = cursor.fetchone()  # 单行查询</h3><h3 id="ret-cursor-fetchall-查询所有的条件"><a href="#ret-cursor-fetchall-查询所有的条件" class="headerlink" title="ret = cursor.fetchall()  # 查询所有的条件"></a>ret = cursor.fetchall()  # 查询所有的条件</h3><h3 id="ret-cursor-fetchmany-2-查询2条"><a href="#ret-cursor-fetchmany-2-查询2条" class="headerlink" title="ret = cursor.fetchmany(2)  # 查询2条"></a>ret = cursor.fetchmany(2)  # 查询2条</h3><pre><code>import pymysqlconn = pymysql.connect(    host=&apos;127.0.0.1&apos;,    port=3306,    user=&apos;root&apos;,    password=&apos;123&apos;,    database=&apos;db1008&apos;,    charset=&apos;utf8&apos;)cursor = conn.cursor()name = input(&apos;input_name:&apos;)pwd = input(&apos;inputZ_pwd:&apos;)sql = &quot;select * from userinfo;&quot;cursor.execute(sql)# ret = cursor.fetchone()  # 单行查询# ret = cursor.fetchall()  # 查询所有的条件ret = cursor.fetchmany(2)  # 查询2条print(ret)cursor.close()conn.close()</code></pre><h3 id="2-2-1-进阶用法-移动光标"><a href="#2-2-1-进阶用法-移动光标" class="headerlink" title="2.2.1 进阶用法 移动光标"></a>2.2.1 进阶用法 移动光标</h3><pre><code># 可以获取指定数量的数据cursor.fetchmany(3)# 光标按绝对位置移动1cursor.scroll(1, mode=&quot;absolute&quot;)# 光标按照相对位置(当前位置)移动1cursor.scroll(1, mode=&quot;relative&quot;)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一：连接Mysql数据库&quot;&gt;&lt;a href=&quot;#一：连接Mysql数据库&quot; class=&quot;headerlink&quot; title=&quot;一：连接Mysql数据库&quot;&gt;&lt;/a&gt;一：连接Mysql数据库&lt;/h1&gt;&lt;p&gt;1.1连接条件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先有个启动的m
      
    
    </summary>
    
      <category term="mysql" scheme="http://yoursite.com/categories/mysql/"/>
    
    
      <category term="数据操作Python" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9CPython/"/>
    
  </entry>
  
  <entry>
    <title>多表结构的创建与分析</title>
    <link href="http://yoursite.com/2018/10/04/%E5%A4%9A%E8%A1%A8%E7%BB%93%E6%9E%84%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2018/10/04/多表结构的创建与分析/</id>
    <published>2018-10-04T05:34:28.019Z</published>
    <updated>2018-10-04T05:37:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分析步骤："><a href="#分析步骤：" class="headerlink" title="分析步骤："></a>分析步骤：</h1><h2 id="1、先站在左表的角度去找"><a href="#1、先站在左表的角度去找" class="headerlink" title="1、先站在左表的角度去找"></a>1、先站在左表的角度去找</h2><p>是否左表的多条记录可以对应右表的一条记录，如果是，则证明左表的一个字段foreign key 右表一个字段（通常是id）</p><h2 id="2、再站在右表的角度去找"><a href="#2、再站在右表的角度去找" class="headerlink" title="2、再站在右表的角度去找"></a>2、再站在右表的角度去找</h2><p>是否右表的多条记录可以对应左表的一条记录，如果是，则证明右表的一个字段foreign key 左表一个字段（通常是id）</p><h2 id="3、总结："><a href="#3、总结：" class="headerlink" title="3、总结："></a>3、总结：</h2><h3 id="多对一："><a href="#多对一：" class="headerlink" title="多对一："></a>多对一：</h3><p>如果只有步骤1成立，则是左表多对一右表<br>如果只有步骤2成立，则是右表多对一左表</p><p>###多对多<br>如果步骤1和2同时成立，则证明这两张表时一个双向的多对一，即多对多,需要定义一个这两张表的关系表来专门存放二者的关系</p><p>###一对一:<br>如果1和2都不成立，而是左表的一条记录唯一对应右表的一条记录，反之亦然。这种情况很简单，就是在左表foreign key右表的基础上，将左表的外键字段设置成unique即可</p><h1 id="建立表之间的关系"><a href="#建立表之间的关系" class="headerlink" title="建立表之间的关系"></a>建立表之间的关系</h1><h2 id="一对多或称为多对一"><a href="#一对多或称为多对一" class="headerlink" title="一对多或称为多对一"></a>一对多或称为多对一</h2><pre><code>三张表：出版社，作者信息，书一对多（或多对一）：一个出版社可以出版多本书关联方式：foreign key  references 关联标的字段（ press(id)）</code></pre><h3 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h3><h4 id="创建一个表"><a href="#创建一个表" class="headerlink" title="创建一个表"></a>创建一个表</h4><pre><code>create table press( id int primary key auto_increment, name varchar(20) );</code></pre><h4 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h4><pre><code>create table book(    id int primary key auto_increment,    name varchar(20),    press_id int not null,    foreign key(press_id) references press(id)    on delete cascade    on update cascade    );</code></pre><h3 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h3><pre><code>一个表可以关联多个表， 和多个表建立关系</code></pre><p>####代码实例</p><pre><code>#创建一个表create table class(       id int not null primary key auto_increment,    name varchar(20)    );create table course( cid int not null primary key auto_increment, name varchar(20) );#创建多个连接create table student( s_id int not null primary key auto_increment,     name varchar(20), 、class_id int,foreign key(class_id) references class(id) on delete cascade on update cascade ,course_id int,foreign key(course_id) references course(cid)  on delete cascade on update cascade);</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;分析步骤：&quot;&gt;&lt;a href=&quot;#分析步骤：&quot; class=&quot;headerlink&quot; title=&quot;分析步骤：&quot;&gt;&lt;/a&gt;分析步骤：&lt;/h1&gt;&lt;h2 id=&quot;1、先站在左表的角度去找&quot;&gt;&lt;a href=&quot;#1、先站在左表的角度去找&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="mysql" scheme="http://yoursite.com/categories/mysql/"/>
    
    
      <category term="多表" scheme="http://yoursite.com/tags/%E5%A4%9A%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>mysql基础</title>
    <link href="http://yoursite.com/2018/10/04/Mysql/"/>
    <id>http://yoursite.com/2018/10/04/Mysql/</id>
    <published>2018-10-04T04:31:00.000Z</published>
    <updated>2018-10-04T05:38:57.569Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一：数据库在未来的开发的地位"><a href="#一：数据库在未来的开发的地位" class="headerlink" title="一：数据库在未来的开发的地位"></a>一：数据库在未来的开发的地位</h1><pre><code># 后台/后端    # 复杂的代码 隐藏在后端# 前端    # 返回到前端 装饰一下 给别人看# python基础    # 后端程序的开发        # 数据的处理 （增删改查）# 员工信息表、选课系统    # 使用python和文件一起写程序的弊端：        # 结果不好看 需要在控制台、终端控制        # 文件的处理非常繁琐 ：增加 删除# 帮助你 管理 存储了数据的文件    # 更加方便、快速的实现数据的增 删 改 查# python + 数据库（存取数据） + 文件（记录日志）# 结果不好看 需要在控制台、终端控制</code></pre><h1 id="二：数据库中的几个概念"><a href="#二：数据库中的几个概念" class="headerlink" title="二：数据库中的几个概念"></a>二：数据库中的几个概念</h1><h2 id="记录、数据-data"><a href="#记录、数据-data" class="headerlink" title="记录、数据 data"></a>记录、数据 data</h2><pre><code># id,name,passwd,age,number# 1,alex,alex3714,83,13838384438   # 一条记录# 表 table# userinfo    # 一张表就是一个文件# 1,alex,alex3714,83,13838384438# 1,alex,alex3714,83,13838384438# 1,alex,alex3714,83,13838384438</code></pre><h2 id="库-base"><a href="#库-base" class="headerlink" title="库 base"></a>库 base</h2><pre><code># 选课系统     userinfo/studentinfo/courseinfo# 员工信息表   userinfo# ftp          userinfo# mysql这个软件来管理数据# 只有一个mysql来管理你的程序，# 你的程序之间的数据应该是隔离的# 创建两个文件夹 ：选课系统、员工信息表# 所谓数据库中的库 就是文件夹    # 一般情况下 每个程序使用一个库</code></pre><h2 id="数据库管理系统-dbms"><a href="#数据库管理系统-dbms" class="headerlink" title="数据库管理系统 dbms"></a>数据库管理系统 dbms</h2><pre><code># database management system# 能够通过一个软件来管理文件、文件夹、数据# 数据库服务器# 你把你的数据装在哪台机器上 这台机器就是数据库服务器# 关系型数据库和非关系型数据库# 关系型    # 一条数据包含了一个事物的多条信息，这些信息之间是有关联性的# 非关系型  :存取频繁的，并且要求效率高的，不突出数据之间关联的    # k-v    # id content</code></pre><h2 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h2><pre><code># mysql       开源# oracle      企业级# sqlite      轻量级# sql server  大学</code></pre><h2 id="非关系型数据库-：消息转发"><a href="#非关系型数据库-：消息转发" class="headerlink" title="非关系型数据库  ：消息转发"></a>非关系型数据库  ：消息转发</h2><pre><code># memcache# redis# MongoDB# nosql</code></pre><h1 id="数据库的基本操作"><a href="#数据库的基本操作" class="headerlink" title="数据库的基本操作"></a>数据库的基本操作</h1><h2 id="启动server端-可以在service服务中操作"><a href="#启动server端-可以在service服务中操作" class="headerlink" title="启动server端  - 可以在service服务中操作"></a>启动server端  - 可以在service服务中操作</h2><pre><code># (win)&gt;net start mysql</code></pre><h3 id="使用默认用户启动mysql客户端，默认的用户登录-是没有权限查看所有库的"><a href="#使用默认用户启动mysql客户端，默认的用户登录-是没有权限查看所有库的" class="headerlink" title="使用默认用户启动mysql客户端，默认的用户登录 是没有权限查看所有库的"></a>使用默认用户启动mysql客户端，默认的用户登录 是没有权限查看所有库的</h3><pre><code># &gt;mysql 表示启动mysql 客户端# mysql&gt; select user();  # 查看当前登录的用户    # liqinyang@192.168.16.53 # 用户名@ip地址# mysql&gt; show databases; # 查看所有的库# mysql&gt; exit  # 退出当前的客户端</code></pre><h3 id="指定用户登录-root用户-mysql当中权限最高的-管理员用户"><a href="#指定用户登录-root用户-mysql当中权限最高的-管理员用户" class="headerlink" title="指定用户登录 root用户 mysql当中权限最高的 管理员用户"></a>指定用户登录 root用户 mysql当中权限最高的 管理员用户</h3><h4 id="用户名root登录"><a href="#用户名root登录" class="headerlink" title="用户名root登录"></a>用户名root登录</h4><pre><code># &gt; mysql -uroot -p# 初始化没有密码的时候 直接按回车键进入数据库# mysql&gt; select user();</code></pre><h3 id="在输入sql语句的过程中-如果想要放弃本条语句-c"><a href="#在输入sql语句的过程中-如果想要放弃本条语句-c" class="headerlink" title="在输入sql语句的过程中 如果想要放弃本条语句 \c"></a>在输入sql语句的过程中 如果想要放弃本条语句 \c</h3><h4 id="设置密码"><a href="#设置密码" class="headerlink" title="设置密码"></a>设置密码</h4><pre><code># mysql&gt; set password = password(&apos;123&apos;);</code></pre><h4 id="创建用户-create-user"><a href="#创建用户-create-user" class="headerlink" title="创建用户 create user"></a>创建用户 create user</h4><pre><code># create user &apos;alex&apos;@&apos;192.168.16.*&apos; identified by &apos;123&apos;;# create user &apos;eva&apos;@&apos;%&apos; identified by &apos;123&apos;;# &gt; mysql -ueva -p123 -h 192.168.16.39  远程登录一个mysql服务# 新创建出来的用户eva没有使用数据库的权限</code></pre><h4 id="给新用户授权-grant"><a href="#给新用户授权-grant" class="headerlink" title="给新用户授权 grant"></a>给新用户授权 grant</h4><pre><code># grant 操作(select/all) on &apos;库.表&apos; to &apos;用户&apos;@&apos;ip地址&apos;# grant select on &apos;*.*&apos; to &apos;eva&apos;@&apos;%&apos;</code></pre><h4 id="创建用户并授权-grant"><a href="#创建用户并授权-grant" class="headerlink" title="创建用户并授权 grant"></a>创建用户并授权 grant</h4><pre><code># mysql&gt; grant all on *.* to &apos;eva&apos;@&apos;%&apos; identified by &apos;123</code></pre><h4 id="让公司的DBA给你创建用户并且授权"><a href="#让公司的DBA给你创建用户并且授权" class="headerlink" title="让公司的DBA给你创建用户并且授权"></a>让公司的DBA给你创建用户并且授权</h4><pre><code># 用户名 要哪个库的哪些权限</code></pre><h2 id="3-1处理库"><a href="#3-1处理库" class="headerlink" title="3.1处理库"></a>3.1处理库</h2><h3 id="创建库"><a href="#创建库" class="headerlink" title="创建库"></a>创建库</h3><pre><code>create database 数据库名 [charset utf-8];</code></pre><h3 id="查看库"><a href="#查看库" class="headerlink" title="查看库"></a>查看库</h3><pre><code>show databases;</code></pre><h3 id="修改库"><a href="#修改库" class="headerlink" title="修改库"></a>修改库</h3><pre><code>alter database 数据库的名字  你要修改的内容;</code></pre><h3 id="删除库"><a href="#删除库" class="headerlink" title="删除库"></a>删除库</h3><pre><code>drop database 数据库名;</code></pre><h2 id="3-2-处理表"><a href="#3-2-处理表" class="headerlink" title="3.2 处理表"></a>3.2 处理表</h2><h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><h3 id="mysql-gt-create-table-表的名字"><a href="#mysql-gt-create-table-表的名字" class="headerlink" title="mysql&gt; create table 表的名字 ("></a>mysql&gt; create table 表的名字 (</h3><pre><code>                    # 列1的名字 数据类型，                    # 列2的名字 数据类型，                    # ...                    # );create table class(id int not null unique, caption varchar(20)); </code></pre><h4 id="增加表内容"><a href="#增加表内容" class="headerlink" title="增加表内容"></a>增加表内容</h4><pre><code>1：插入单行insert into staff_info (id,name,age,sex,phone,job) values (1,&apos;Alex&apos;,83,&apos;female&apos;,&apos;13651054608&apos;,&apos;IT&apos;);2：插入多行# mysql&gt; insert into staff_info values -&gt; (2,&apos;Egon&apos;,26,&apos;male&apos;,&apos;13304320533&apos;,&apos;Tearcher&apos;), -&gt; (3,&apos;nezha&apos;,25,&apos;male&apos;,&apos;13332353222&apos;,&apos;IT&apos;), -&gt; (4,&apos;boss_jin&apos;,40,&apos;male&apos;,&apos;13332353333&apos;,&apos;IT&apos;);3: 范围测试 有符号和无符号mysql&gt; create table t6 (id1 int(4),id2 int unsigned);mysql&gt; insert into t6 values (123,2147483648);</code></pre><h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><pre><code>1.1查看表结构mysql&gt; desc staff_info;</code></pre><p>   1.2 查询固定表头<br>     select name,age from staff_info;</p><h1 id="三：数据类型"><a href="#三：数据类型" class="headerlink" title="三：数据类型"></a>三：数据类型</h1><h2 id="时间类型"><a href="#时间类型" class="headerlink" title="时间类型"></a>时间类型</h2><h3 id="date-描述年月日"><a href="#date-描述年月日" class="headerlink" title="date      描述年月日"></a>date      描述年月日</h3><h3 id="datetime-描述年月日时分秒"><a href="#datetime-描述年月日时分秒" class="headerlink" title="datetime  描述年月日时分秒"></a>datetime  描述年月日时分秒</h3><h3 id="timestamp字段默认不为空"><a href="#timestamp字段默认不为空" class="headerlink" title="timestamp字段默认不为空"></a>timestamp字段默认不为空</h3><h3 id="DATETIME、DATE、TIMESTAMP、TIME和YEAR。"><a href="#DATETIME、DATE、TIMESTAMP、TIME和YEAR。" class="headerlink" title="DATETIME、DATE、TIMESTAMP、TIME和YEAR。"></a>DATETIME、DATE、TIMESTAMP、TIME和YEAR。</h3><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="CHAR-0-255字节-定长字符串"><a href="#CHAR-0-255字节-定长字符串" class="headerlink" title="CHAR    0-255字节    定长字符串"></a>CHAR    0-255字节    定长字符串</h3><pre><code>定长 浪费磁盘 存取速度非常快</code></pre><h2 id="VARCHAR-0-65535-字节-变长字符串"><a href="#VARCHAR-0-65535-字节-变长字符串" class="headerlink" title="VARCHAR    0-65535 字节    变长字符串"></a>VARCHAR    0-65535 字节    变长字符串</h2><pre><code>变长 节省磁盘空间 存取速度相对慢char(5)     &apos;  abc&apos;  5   &apos;abcde&apos;  5这一列数据的长度变化小  手机号 身份证号 学号频繁存取、对效率要求高短数据varchar(5)  &apos;3abc&apos;   4   &apos;5abcde&apos; 6这一列的数据长度变化大  name  描述信息对效率要求相对小相对长</code></pre><h2 id="ENUM和SET类型"><a href="#ENUM和SET类型" class="headerlink" title="ENUM和SET类型"></a>ENUM和SET类型</h2><h3 id="ENUM"><a href="#ENUM" class="headerlink" title="ENUM"></a>ENUM</h3><pre><code>大小： 对1-255个成员的枚举需要1个字节存储;对于255-65535个成员，需要2个字节存储;最多允许65535个成员。用途： 单选：选择性别</code></pre><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><pre><code>create table t2 (name char(20),gender enum(&apos;男&apos;, &apos;女&apos;)); 插入gender选项不能插入两个值</code></pre><h3 id="SET"><a href="#SET" class="headerlink" title="SET"></a>SET</h3><pre><code>大小 ：1-8个成员的集合，占1个字节9-16个成员的集合，占2个字节17-24个成员的集合，占3个字节25-32个成员的集合，占4个字节 33-64个成员的集合，占8个字节用途 ：多选：兴趣爱好</code></pre><h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><pre><code>create table t11 (name char(20),hobby set(&apos;抽烟&apos;,&apos;喝酒&apos;,&apos;烫头&apos;,&apos;翻车&apos;));不能插入set 范围外的词 会报错</code></pre><h3 id="表的完整性约束"><a href="#表的完整性约束" class="headerlink" title="表的完整性约束"></a><strong>表的完整性约束</strong></h3><h4 id="not-noll"><a href="#not-noll" class="headerlink" title="not noll"></a>not noll</h4><pre><code>非空约束，指定某列不能为空；create table t12 (id int not null); //若是为空报错</code></pre><h4 id="default"><a href="#default" class="headerlink" title="default"></a>default</h4><pre><code>创建列时可以指定默认值，当插入数据时如果未主动设置，则自动添加默认值create table t13 (id1 int not null,id2 int not null default 222);</code></pre><h4 id="unique"><a href="#unique" class="headerlink" title="unique"></a>unique</h4><h5 id="唯一约束，指定某列或者几列组合不能重复"><a href="#唯一约束，指定某列或者几列组合不能重复" class="headerlink" title="唯一约束，指定某列或者几列组合不能重复"></a>唯一约束，指定某列或者几列组合不能重复</h5><pre><code>create table t3(id int unique, name char(20));插入相同的值会报错</code></pre><h5 id="指定某个属性为唯一"><a href="#指定某个属性为唯一" class="headerlink" title="  指定某个属性为唯一  "></a><strong>  指定某个属性为唯一  </strong></h5><pre><code>create table t4(id int unique, name char(20) unique(name));</code></pre><h5 id="not-null-和-unique-联合"><a href="#not-null-和-unique-联合" class="headerlink" title="not null 和 unique 联合"></a>not null 和 unique 联合</h5><pre><code>create table t1(id int not null unique);</code></pre><h4 id="指定多键联合"><a href="#指定多键联合" class="headerlink" title="指定多键联合"></a><strong>指定多键联合</strong></h4><pre><code>create table t5(id int, name char(20), unique(id, name));</code></pre><h4 id="primary-key"><a href="#primary-key" class="headerlink" title="primary key"></a>primary key</h4><h5 id="主键为了保证表中的每一条数据的该字段都是表格中的唯一值"><a href="#主键为了保证表中的每一条数据的该字段都是表格中的唯一值" class="headerlink" title="主键为了保证表中的每一条数据的该字段都是表格中的唯一值"></a>主键为了保证表中的每一条数据的该字段都是表格中的唯一值</h5><h4 id="第一种："><a href="#第一种：" class="headerlink" title="第一种："></a>第一种：</h4><pre><code>not null+unique</code></pre><h4 id="第二种：-primary-key"><a href="#第二种：-primary-key" class="headerlink" title="第二种： primary key"></a>第二种： primary key</h4><pre><code>create table t7(id int primary key,name char(20));</code></pre><h4 id="第三种：在所有字段后单独定义primary-key"><a href="#第三种：在所有字段后单独定义primary-key" class="headerlink" title="第三种：在所有字段后单独定义primary key"></a>第三种：在所有字段后单独定义primary key</h4><pre><code>create table t6(id int,name char(20), primary key(id));</code></pre><h4 id="第四种：给已建成的表添加主键"><a href="#第四种：给已建成的表添加主键" class="headerlink" title="第四种：给已建成的表添加主键"></a>第四种：给已建成的表添加主键</h4><pre><code>alter table department4 modify id int primary key;</code></pre><h4 id="第五种：多字段主键"><a href="#第五种：多字段主键" class="headerlink" title="第五种：多字段主键"></a>第五种：多字段主键</h4><pre><code>create table t8(id int, name char(20), primary key(id, name));</code></pre><h3 id="AUTO-INCREMENT"><a href="#AUTO-INCREMENT" class="headerlink" title="AUTO_INCREMENT"></a>AUTO_INCREMENT</h3><h5 id="约束字段为自动增长，被约束的字段必须同时被key约束"><a href="#约束字段为自动增长，被约束的字段必须同时被key约束" class="headerlink" title="约束字段为自动增长，被约束的字段必须同时被key约束"></a>约束字段为自动增长，被约束的字段必须同时被key约束</h5><h4 id="不指定id，则自动增长，-对于自增的字段，在用delete删除后，再插入值，该字段仍按照删除前的位置继续增长"><a href="#不指定id，则自动增长，-对于自增的字段，在用delete删除后，再插入值，该字段仍按照删除前的位置继续增长" class="headerlink" title="不指定id，则自动增长， 对于自增的字段，在用delete删除后，再插入值，该字段仍按照删除前的位置继续增长"></a>不指定id，则自动增长， 对于自增的字段，在用delete删除后，再插入值，该字段仍按照删除前的位置继续增长</h4><pre><code>create table student(id int primary key auto_increment,    name varchar(20),    sex enum(&apos;male&apos;,&apos;female&apos;) default &apos;male&apos;    );</code></pre><h4 id="foreign-key"><a href="#foreign-key" class="headerlink" title="foreign key"></a>foreign key</h4><h4 id="当设置字段为unique唯一字段时，设置该字段为外键才可以成功"><a href="#当设置字段为unique唯一字段时，设置该字段为外键才可以成功" class="headerlink" title="当设置字段为unique唯一字段时，设置该字段为外键才可以成功"></a>当设置字段为unique唯一字段时，设置该字段为外键才可以成功</h4><h4 id="设置外键"><a href="#设置外键" class="headerlink" title="设置外键"></a>设置外键</h4><pre><code>create table staff_info (s_id int,    name varchar(20),    dep_id int,    foreign key(dep_id) references departments(dep_id)); #departments(dep_id)) 外表ID</code></pre><h4 id="给予表权限，-外表删除，本表也跟新"><a href="#给予表权限，-外表删除，本表也跟新" class="headerlink" title="给予表权限， 外表删除，本表也跟新"></a>给予表权限， 外表删除，本表也跟新</h4><pre><code>on delete cascade  # 连级删除on update cascade # 连级更新</code></pre><h1 id="表简单增删改查"><a href="#表简单增删改查" class="headerlink" title="表简单增删改查"></a>表简单增删改查</h1><h2 id="表的查看"><a href="#表的查看" class="headerlink" title="表的查看"></a>表的查看</h2><h3 id="describe-staff-info"><a href="#describe-staff-info" class="headerlink" title="describe staff_info;"></a>describe staff_info;</h3><pre><code>查看表结构</code></pre><h3 id="desc-staff-info"><a href="#desc-staff-info" class="headerlink" title="desc staff_info;"></a>desc staff_info;</h3><pre><code>查看表结构</code></pre><h3 id="show-create-table-staff-info-G"><a href="#show-create-table-staff-info-G" class="headerlink" title="show create table staff_info\G;"></a>show create table staff_info\G;</h3><pre><code>查看表结构</code></pre><h2 id="修改表结构"><a href="#修改表结构" class="headerlink" title="修改表结构"></a>修改表结构</h2><h3 id="修改表名字"><a href="#修改表名字" class="headerlink" title="修改表名字"></a>修改表名字</h3><pre><code>alter table t1 rename t4_1;//alter table (修改的表) rename （新的表名字）；</code></pre><h3 id="增加字段"><a href="#增加字段" class="headerlink" title="增加字段"></a>增加字段</h3><pre><code>alter table t4_1 add age int, add sex char(3);//alter table t4_1 add (字段的属性), add (字段属性);</code></pre><h3 id="删除字段"><a href="#删除字段" class="headerlink" title="删除字段"></a>删除字段</h3><pre><code>alter table t4_1 drop sex;//alter table （操作的表） drop （字段名字）;</code></pre><h3 id="修改字段"><a href="#修改字段" class="headerlink" title="修改字段"></a>修改字段</h3><pre><code>alter table t4_1 modiey name char(20) not null;//alter table (表名字) modiey （字段） （数据类型） （约束条件）;#修改字段的名字alter table t4_1 change name myname int not null;//alter table 表名 change 原表名字 新的名字 数据类型 约束条件;</code></pre><h3 id="修改字段排列顺序-在增加的时候指定字段位置"><a href="#修改字段排列顺序-在增加的时候指定字段位置" class="headerlink" title="修改字段排列顺序/在增加的时候指定字段位置"></a>修改字段排列顺序/在增加的时候指定字段位置</h3><h4 id="给表首位字段插入一个"><a href="#给表首位字段插入一个" class="headerlink" title="给表首位字段插入一个"></a>给表首位字段插入一个</h4><pre><code>alter table t4_1 add key_id int not null first;//alter table 表 add 新的字段 数据类型 约束条件 first; #first代表首位</code></pre><h3 id="给表固定位字段插入一个"><a href="#给表固定位字段插入一个" class="headerlink" title="给表固定位字段插入一个"></a>给表固定位字段插入一个</h3><pre><code>alter table t4_1 add key_id int not null after id;//alter table 表 add 新的字段 数据类型 约束条件 after; #after 在那个字段之后</code></pre><h3 id="修改字段名，-并且移动到固定位置"><a href="#修改字段名，-并且移动到固定位置" class="headerlink" title="修改字段名， 并且移动到固定位置"></a>修改字段名， 并且移动到固定位置</h3><pre><code>alter table t4_1 change id_new id_n int first;alter table t4_1 change id_n id_new int after id; #那个字段后面//alter table 表名 change 要修改的字段 新的字段 数据类型 约束条件 first; </code></pre><h3 id="修改字段的位置"><a href="#修改字段的位置" class="headerlink" title="修改字段的位置"></a>修改字段的位置</h3><pre><code>alter table t4_1 modify  age int  after id;//alter table 表名 modify  字段名 属性 after 字段名;</code></pre><h2 id="表的删除"><a href="#表的删除" class="headerlink" title="表的删除"></a>表的删除</h2><pre><code>drop table t4_1;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一：数据库在未来的开发的地位&quot;&gt;&lt;a href=&quot;#一：数据库在未来的开发的地位&quot; class=&quot;headerlink&quot; title=&quot;一：数据库在未来的开发的地位&quot;&gt;&lt;/a&gt;一：数据库在未来的开发的地位&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;# 后台/后端
    # 
      
    
    </summary>
    
      <category term="mysql" scheme="http://yoursite.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>明天会更好</title>
    <link href="http://yoursite.com/2018/10/03/%E5%8A%AA%E5%8A%9B%E5%89%8D%E8%A1%8C/"/>
    <id>http://yoursite.com/2018/10/03/努力前行/</id>
    <published>2018-10-03T13:37:18.000Z</published>
    <updated>2018-10-03T14:08:41.807Z</updated>
    
    <content type="html"><![CDATA[<p>#分析自身现状<br>  最近一直以来状态不太好， 感觉学习没有刚开始学习的时候好了。最要表现在一下几个方面</p><p>1.学习热度没有开始学习的时候好<br>2.学习效率低，分心程序高，不够专注<br>3.个人作息有严重的问题<br>4.上课不注意听讲， 下课总结不到位<br>5.今后的问题应该是多注意总结学习新的知识</p><p>#个人问题<br>一直以来都很胖， 也健过身最后也有好的效果。但是过后又恢复一前模样，总结原因是没有坚持。成功路上的多数难题是不够坚持，这是我发现自身的问题的根本所在。固然懒惰是人的天性， 一直以来自己都想改变自己，我考虑良久想从跑步做起，培养自己的意志力。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#分析自身现状&lt;br&gt;  最近一直以来状态不太好， 感觉学习没有刚开始学习的时候好了。最要表现在一下几个方面&lt;/p&gt;
&lt;p&gt;1.学习热度没有开始学习的时候好&lt;br&gt;2.学习效率低，分心程序高，不够专注&lt;br&gt;3.个人作息有严重的问题&lt;br&gt;4.上课不注意听讲， 下课总结不到
      
    
    </summary>
    
      <category term="个人感想" scheme="http://yoursite.com/categories/%E4%B8%AA%E4%BA%BA%E6%84%9F%E6%83%B3/"/>
    
    
      <category term="珍惜" scheme="http://yoursite.com/tags/%E7%8F%8D%E6%83%9C/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2018/10/02/hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2018/10/02/hexo个人博客搭建整理/</id>
    <published>2018-10-02T13:07:50.989Z</published>
    <updated>2018-10-02T13:56:46.704Z</updated>
    
    <content type="html"><![CDATA[<p>#一什么是 Hexo？<br>    官方解释说Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。<br>    也就是说Hexo是一款能够帮助我们快速构建博客的轻型框架。但是如何使用Hexo呢？<br>    如标题所言，我们是结合GitHub来使用Hexo,因此在创建博客的过程中我们就可以分成两个部分，GitHub准备工作和Hexo搭建工作<br><strong>注：实例运行环境为Windos,教程较为浅显，读者可根据个人实际情况选择性阅读该教程</strong></p><p>##安装主要配置软件<br>1： Node.js :<a href="http://nodejs.cn/download/" title="Node.js" target="_blank" rel="noopener">http://nodejs.cn/download/</a></p><p>2：Git（前往下载）<a href="https://git-scm.com/downloads" title="Git（前往下载）" target="_blank" rel="noopener">https://git-scm.com/downloads</a></p><ol start="3"><li>安装hexo看到这么多安装，千万不要紧张，一定要稳住，别怕，因为后面的东西都是在gitbash中用npm工具安装就好了。先创建一个文件（用来存放所有blog的东西），然后cd到该文件夹下。</li><li>安装hexo命令：npm i -g hexo安装完成后，查看版本：<br> <img src="https://i.imgur.com/FoaoPPl.png" alt=""></li></ol><pre><code>* 解释一下：node_modules：是依赖包        * public：存放的是生成的页面        * scaffolds：命令生成文章等的模板        * source：用命令创建的各种文章        * themes：主题        * _config.yml：整个博客的配置        * db.json：source解析所得到的        * package.json：项目所需模块项目的配置信息</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#一什么是 Hexo？&lt;br&gt;    官方解释说Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。&lt;br&gt;    也就是说Hexo是一款能够帮助我们快速构建博客的轻型框架。但是如
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>操作系统和进程的基础概念</title>
    <link href="http://yoursite.com/2018/10/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <id>http://yoursite.com/2018/10/02/操作系统与进程的基础概念/</id>
    <published>2018-10-02T04:24:39.008Z</published>
    <updated>2018-10-03T10:33:57.030Z</updated>
    
    <content type="html"><![CDATA[<p>#操作系统的发展史</p><p>##手工操作 —— 穿孔卡片      </p><p>###手工操作的两个特点：<br>    1：用户独占全机， 不会出现因资源一杯其他用户占用而等待的现象， 但是资源利用率低<br>    2：cup等待手工操作。 CPU的利用不充分</p><p>##批处理 —— 磁带存储和批处理系统、</p><p>###批处理系统：加载在计算机上的一个系统软件， 在他的控制下， 计算机能够自动的， 成批地处理有个或者多个用户的作业</p><p>###卫星机：<br>    一台不与主机直接相连而用于输出输入设备打交道<br>    其功能：<br>        1：输入机上读取用户作业并放到磁带上<br>        2：从输入磁带上读取执行结果给打印机<br>    不足：每次主机内存中仅存放到一道作业， 每当它运行期间输入、输出请求后， 高速的CPU变处于等待低速的IO完成状态致使CPU空闲</p><p>##多道程序系统<br><img src="https://i.imgur.com/DU9G0m7.png" alt=""></p><p>###所谓的多道程序设计技术， 就是指允许多个程序进入内存并允许。 即把多个程序放入内存。他们在内存中交替运行。共享系统资源。一道程序运行结束立马转向去另一个。</p><p>###单机处理系统中的多道程序运行的特点：<br>    1：多道：计算机内部放入多道程序<br>    2:宏观上的并行： 同时进入系统的几道程序都处于运行过程中，都开始运行，但都为运行完毕<br>    3：微观上串性：各道程序轮流的用CPU， 交替运行</p><p>##多道批处理系统</p><p>##分时系统</p><p>##实时系统</p><p>##通用操作系统</p><p>##操作系统的进一步发展</p><p>##操作系统的作用</p><p>I/O ：input 进入内存的过程就是输入<br>    ：ouput 数据从内存从内存出去的过程就是输出 （写文件， dump， send）</p><p>##多道操作系统<br>    可以有多个程序在操作系统中执行<br>    当一个程序遇到IO操作时候就把CPU让出来给其他程序</p><p>###分时操作系统</p><pre><code>#时间片 特别短的时间#不是遇到IO的时候才让出CPU， 而是时间到了就将CPU让出来#切换要占时间：单纯的分时系统没有提高CPU的利用率                提高了用户体验</code></pre><p>###实时系统</p><p>###个人计算机<br>    python celery 分布式计算</p><p>##进程 Process id = pid<br>程序  进程<br>pid 是全系统</p><p>进程是操作系统最小的资源分配单位</p><p>资源分配  — 内存 寄存器</p><p>多级反馈附列<br>    先把短的执行， 长任务放到队列下面</p><p>同步阻塞： 不能充分利用CPU<br>异步非阻塞： 过度利用CPU</p><p>IO多路复用：比较完善的在网络编程中的解决方案</p><h2 id="if-name-‘name‘"><a href="#if-name-‘name‘" class="headerlink" title="if name == ‘name‘:"></a>if <strong>name</strong> == ‘<strong>name</strong>‘:</h2><pre><code>只有在winds上才需要</code></pre><p>1：父进程和子进程的启动时异步的<br>父进程只负责通知操作系统启动子进程<br>接下来的工作由操作系统接手，父进程继续执行<br>2：父进程执行完毕后并不会直接结束程序<br>而是等待所有的子进程都执行完毕后才结束<br>父进程要负责回收子进程的资源</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#操作系统的发展史&lt;/p&gt;
&lt;p&gt;##手工操作 —— 穿孔卡片      &lt;/p&gt;
&lt;p&gt;###手工操作的两个特点：&lt;br&gt;    1：用户独占全机， 不会出现因资源一杯其他用户占用而等待的现象， 但是资源利用率低&lt;br&gt;    2：cup等待手工操作。 CPU的利用不充分
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>socke</title>
    <link href="http://yoursite.com/2018/10/02/socket/"/>
    <id>http://yoursite.com/2018/10/02/socket/</id>
    <published>2018-10-02T04:24:38.992Z</published>
    <updated>2018-10-03T10:33:43.888Z</updated>
    
    <content type="html"><![CDATA[<p>#1：网络编程之socketserver</p><p>###1:首先socketserver 服务器调用socketserver 模块</p><p>###2:继承了socketserver.BaseRequestHandler</p><p>###3:在父类的基础上重写了handle</p><p>##下面是一个简单的文件登录文件上传的例子</p><p>###server端<br>    import socketserver<br>    import json<br>    import struct<br>    import socket</p><pre><code>class MyTCPHandler(socketserver.BaseRequestHandler):def handle(self):    flag = self.login_check()    while flag:        try:            self.data = self.request.recv(1024).strip()            print(&apos;{} wrote&apos;.format(self.client_address[0]))            print(self.data)            self.request.send(self.data.upper())            print(self.data.decode(&apos;utf-8&apos;))            if self.data.decode(&apos;utf-8&apos;) == &apos;2&apos;:                self.uploading()        except ConnectionResetError as e:            print(&apos;error&apos;, e)            breakdef login_check(self):    dic_user = {        &apos;name&apos;: &apos;qwer&apos;,        &apos;pwad&apos;: &apos;1234&apos;    }    dic_clinet = self.request.recv(1024).strip()    dic_clinet = json.loads(dic_clinet)    print(dic_clinet)    if dic_user[&apos;name&apos;] == dic_clinet[&apos;name&apos;] and \            dic_user[&apos;pwad&apos;] == dic_clinet[&apos;pwad&apos;]:        self.request.send(b&apos;True&apos;)        return Truedef uploading(self):    &apos;&apos;&apos;接受上传文件&apos;&apos;&apos;    ret = self.request.recv(1024)    dic_client = json.loads(ret)    print(dic_client)    self.request.send(b&apos;Start To upload&apos;)    print(&apos;Start the download&apos;)    size = dic_client[&apos;size&apos;]    with open(dic_client[&apos;filename&apos;],&apos;wb&apos;) as f:        while size:            ret = self.request.recv(1024)            f.write(ret)            size -= len(ret)    print(&apos;下载完毕！&apos;)if __name__ == &apos;__main__&apos;:    Host, port = &apos;127.0.0.1&apos;, 9999    # sever = socketserver.TCPServer((Host, port), MyTCPHandler)    sever = socketserver.ThreadingTCPServer((Host, port), MyTCPHandler)    sever.serve_forever()</code></pre><p>###client端</p><pre><code>import socketimport jsonimport osimport sysimport time#进度条import timefrom tqdm import tqdm# for i in tqdm(range(100)):#     time.sleep(0.05)def processBar(num, total):    rate = num / total    rate_num = int(rate * 100)    if rate_num == 100:        r = &apos;\r%s&gt;%d%%\n&apos; % (&apos;|&apos; * rate_num, rate_num,)    else:        r = &apos;\r%s&gt;%d%%&apos; % (&apos;|&apos; * rate_num, rate_num,)    sys.stdout.write(r)    sys.stdout.flushclass Client():    &apos;&apos;&apos;客户端&apos;&apos;&apos;    cmd_list = [        (&apos;下载文件&apos;, &apos;ncftpget&apos;),        (&apos;上传文件&apos;, &apos;upload&apos;),        (&apos;切换目录&apos;, &apos;chdir&apos;),        (&apos;创建目录&apos;, &apos;create_directory&apos;),        (&apos;删除文件或者目录&apos;,&apos;expurgate &apos;),    ]    def __init__(self):        self.client = socket.socket() #实例socket对象    def connect(self, ip, port):        &apos;&apos;&apos;绑定端口&apos;&apos;&apos;        self.client.connect((ip, port))    def logon(self):        &apos;&apos;&apos;用户登录&apos;&apos;&apos;        name = input(&apos;user_name:&apos;)        pawd = input(&apos;passwork:&apos;)        user_dic = {            &apos;name&apos;: name,            &apos;pwad&apos;: pawd        }        self.client.send(json.dumps(user_dic).encode(&apos;utf-8&apos;))        ret = self.client.recv(1024).decode(&apos;utf-8&apos;)        print(ret)        return ret    def User_input(self):        flag = self.logon()        name_path = &apos;/home/&apos;        while flag:            for index, val in enumerate(self.cmd_list, 1):                print(&apos;%s  %s&apos;%(index, val[0]))            inp = input(&apos;%s:&apos;%name_path)            self.client.send(inp.encode(&apos;utf-8&apos;))            ret = self.client.recv(1024).decode(&apos;utf-8&apos;)            if inp == &apos;2&apos;:                self.upload()        else:            print(&apos;密码错误！&apos;)    def ncftpget(self):        &apos;&apos;&apos;下载文件&apos;&apos;&apos;    def upload(self):        &apos;&apos;&apos;上传文件&apos;&apos;&apos;        path_name = r&apos;G:\python笔记\Pythonjing\day18\video\01 深圳校区 python fullstuck 1期 day18 内容回顾.mp4&apos;        size = os.path.getsize(path_name)        print(size)        total = size        dic_user = {            &apos;means&apos;: &apos;uploading&apos;,            &apos;filename&apos;: &apos;test.mp4&apos;,            &apos;size&apos;: size,        }        self.client.send(json.dumps(dic_user).encode(&apos;utf-8&apos;))        ret = self.client.recv(1024)        print(ret)        with open(path_name, &apos;rb&apos;) as f:            count = 0            time_old = time.clock()            pbar = tqdm(total=size)            while size:                data = f.read(1024)                self.client.send(data)                size -= len(data)                count += len(data)                pbar.update(len(data)) #进度条                # processBar(count, total) #进度条            time_new = time.clock()            pbar.close()            print(&apos;上传完毕！一个用时%s秒&apos;%int(time_new - time_old))    def chdir(self):        &apos;&apos;&apos;切换目录&apos;&apos;&apos;    def create_directory(self):        &apos;&apos;&apos;创建目录&apos;&apos;&apos;    def expurgate(self):        &apos;&apos;&apos;删除文件或者文件夹&apos;&apos;&apos;if __name__ == &apos;__main__&apos;:    # Host, port = &apos;127.0.0.1&apos;, 9999    Host, port = &apos;192.168.16.46&apos;, 9999    cl = Client()    cl.connect(Host, port)    cl.User_input()</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#1：网络编程之socketserver&lt;/p&gt;
&lt;p&gt;###1:首先socketserver 服务器调用socketserver 模块&lt;/p&gt;
&lt;p&gt;###2:继承了socketserver.BaseRequestHandler&lt;/p&gt;
&lt;p&gt;###3:在父类的基础上重写
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>multiprocessing模块</title>
    <link href="http://yoursite.com/2018/10/02/multiprocess%E8%BF%9B%E7%A8%8B-%E9%94%81-%E4%BF%A1%E5%8F%B7%E9%87%8F-%E4%BA%8B%E4%BB%B6/"/>
    <id>http://yoursite.com/2018/10/02/multiprocess进程-锁-信号量-事件/</id>
    <published>2018-10-02T04:24:38.979Z</published>
    <updated>2018-10-03T10:32:42.931Z</updated>
    
    <content type="html"><![CDATA[<p>##1.1：process模块介绍</p><p>###具体方法<br>    p.start()：启动进程，并调用该子进程中的p.run()<br>    p.run():进程启动时运行的方法，正是它去调用target指定的函数，我们自定义类的类中一定要实现该方法<br>    p.terminate():强制终止进程p，不会进行任何清理操作，如果p创建了子进程，该子进程就成<br>    了僵尸进程，使用该方法需要特别小心这种情况。如果p还保存了一个锁那么也将不会被释放，进而导致死锁<br>    p.is_alive():如果p仍然运行，返回True<br>    p.join([timeout]):主线程等待p终止（强调：是主线程处于等的状态，而p是处于运行的状态）。<br>    timeout是可选的超时时间，需要强调的是，p.join只能join住start开启的进程，而不能join住run开启的进程  </p><p>###具体实现<br>    p.daemon：默认值为False，如果设为True，代表p为后台运行的守护进程，当p的父进程终止时，p也随之终止，并且设定为True后，p不能创建自己的新进程，必须在p.start()之前设置<br>    p.name:进程的名称<br>    p.pid：进程的pid<br>    p.exitcode:进程在运行时为None、如果为–N，表示被信号N结束(了解即可)<br>    p.authkey:进程的身份验证键,默认是由os.urandom()随机生成的32字符的字符串。这个键的用途是为涉及网络连接的底层进程间通信提供安全性，这类连接只有在具有相同的身份验证键时才能成功（了解即可）</p><p>###具体代码<br>    import os<br>    from multiprocessing import Process</p><pre><code>def f(x):    print(&apos;子进程id ：&apos;,os.getpid(),&apos;父进程id ：&apos;,os.getppid())    #查看主进程和子进程的进程号    return x*xif __name__ == &apos;__main__&apos;:    print(&apos;主进程id ：&apos;, os.getpid())    p_lst = []    for i in range(5):        p = Process(target=f, args=(i,))        p.start()</code></pre><p>##1.2：守护进程</p><pre><code>会随着主进程的结束而结束。主进程创建守护进程　　其一：守护进程会在主进程代码执行结束后就终止　　其二：守护进程内无法再开启子进程,否则抛出异常：AssertionError: daemonic processes are not allowed to have children注意：进程之间是互相独立的，主进程代码运行结束，守护进程随即终止</code></pre><p>###具体代码<br>    from multiprocessing import Process<br>    import time<br>    def fun():<br>        while 1:<br>            print(‘守护进程’)<br>            time.sleep(1)<br>    if <strong>name</strong> == ‘<strong>main</strong>‘:<br>        p = Process(target= fun)<br>        p.daemon = True<br>        p.start()<br>        time.sleep(5) #主进程结束守护进程结束</p><p>##1.3：multiprocess.Lock</p><pre><code>#加锁可以保证多个进程修改同一块数据时，同一时间只能有一个任务可以进行修改，即串行的修改，没错，速度是慢了，但牺牲了速度却保证了数据安全。虽然可以用文件共享数据实现进程间通信，但问题是：1.效率低（共享数据基于文件，而文件是硬盘上的数据）2.需要自己加锁处理#因此我们最好找寻一种解决方案能够兼顾：1、效率高（多个进程共享一块内存的数据）2，我们处理好锁问题。这就是mutiprocessing模块为我们提供的基于消息的IPC通信机制：队列和管道。队列和管道都是将数据存放于内存中队列又是基于（管道+锁）实现的，可以让我们从复杂的锁问题中解脱出来，我们应该尽量避免使用共享数据，尽可能使用消息传递和队列，避免处理复杂的同步和锁问题，而且在进程数目增多时，往往可以获得更好的可获展性。</code></pre><p>###抢票的例子</p><pre><code>#文件db的内容为：{&quot;count&quot;:1}#注意一定要用双引号，不然json无法识别#并发运行，效率高，但竞争写同一文件，数据写入错乱from multiprocessing import Process,Lockimport time,json,randomdef search():    dic=json.load(open(&apos;db&apos;))    print(&apos;\033[43m剩余票数%s\033[0m&apos; %dic[&apos;count&apos;])def get():    dic=json.load(open(&apos;db&apos;))    time.sleep(0.1) #模拟读数据的网络延迟    if dic[&apos;count&apos;] &gt;0:        dic[&apos;count&apos;]-=1        time.sleep(0.2) #模拟写数据的网络延迟        json.dump(dic,open(&apos;db&apos;,&apos;w&apos;))        print(&apos;\033[43m购票成功\033[0m&apos;)def task():    search()    get()if __name__ == &apos;__main__&apos;:    for i in range(100): #模拟并发100个客户端抢票        p=Process(target=task)        p.start()</code></pre><p>##multiprocess.Semaphore<br>    斥锁同时只允许一个线程更改数据，而信号量Semaphore是同时允许一定数量的线程更改数据 。<br>    假设商场里有4个迷你唱吧，所以同时可以进去4个人，如果来了第五个人就要在外面等待，等到有人出来才能再进去玩。<br>    实现：<br>    信号量同步基于内部计数器，每调用一次acquire()，计数器减1；每调用一次release()，计数器加1.<br>    当计数器为0时，acquire()调用被阻塞。这是迪科斯彻（Dijkstra）信号量概念P()和V()Python实现。信号量同步机制适用于访问像服务器这样的有限资源。<br>    信号量与进程池的概念很像，但是要区分开，信号量涉及到加锁的概念</p><p>###具体例子（进KTV）<br>    from multiprocessing import Process,Semaphore<br>    import time,random</p><pre><code>def go_ktv(sem,user):    sem.acquire()    print(&apos;%s 占到一间ktv小屋&apos; %user)    time.sleep(random.randint(0,3)) #模拟每个人在ktv中待的时间不同    sem.release()if __name__ == &apos;__main__&apos;:    sem=Semaphore(4)    p_l=[]    for i in range(13):        p=Process(target=go_ktv,args=(sem,&apos;user%s&apos; %i,))        p.start()        p_l.append(p)    for i in p_l:        i.join()    print(&apos;============》&apos;)</code></pre><p>##multiprocess.Event</p><p>###介绍<br>    python线程的事件用于主线程控制其他线程的执行，事件主要提供了三个方法 set、wait、clear。</p><pre><code>事件处理的机制：全局定义了一个“Flag”，如果“Flag”值为 False，那么当程序执行 event.wait 方法时就会阻塞，如果“Flag”值为True，那么event.wait 方法时便不再阻塞。clear：将“Flag”设置为Falseset：将“Flag”设置为True</code></pre><p>###红绿灯例子<br>    import time<br>    import random<br>    from multiprocessing import Process,Event<br>    def traffic_light(e):<br>        print(‘\033[31m红灯亮\033[0m’)<br>        while True:<br>            if e.is_set():<br>                time.sleep(2)<br>                print(‘\033[31m红灯亮\033[0m’)<br>                e.clear()<br>            else:<br>                time.sleep(2)<br>                print(‘\033[32m绿灯亮\033[0m’)<br>                e.set()</p><pre><code>def car(e,i):    if not e.is_set():        print(&apos;car %s 在等待&apos; % i)        e.wait()    print(&apos;car %s 通过了&apos;%i)if __name__ == &apos;__main__&apos;:    e = Event()    p = Process(target=traffic_light,args=(e,))    p.daemon = True    p.start()    p_lst = []    for i in  range(20):        time.sleep(random.randrange(0,3,2))        p = Process(target=car,args=(e,i))        p.start()  # car19        p_lst.append(p)    for p in p_lst:p.join()</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##1.1：process模块介绍&lt;/p&gt;
&lt;p&gt;###具体方法&lt;br&gt;    p.start()：启动进程，并调用该子进程中的p.run()&lt;br&gt;    p.run():进程启动时运行的方法，正是它去调用target指定的函数，我们自定义类的类中一定要实现该方法&lt;br&gt;
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>multiprocess进程-锁-信号量-事件</title>
    <link href="http://yoursite.com/2018/10/02/multiprocessing%E6%A8%A1%E5%9D%97/"/>
    <id>http://yoursite.com/2018/10/02/multiprocessing模块/</id>
    <published>2018-10-02T04:24:38.971Z</published>
    <updated>2018-10-03T10:32:34.045Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建共享的进程队列，Queue是多进程安全的队列，可以使用Queue实现多进程之间的数据传递。"><a href="#创建共享的进程队列，Queue是多进程安全的队列，可以使用Queue实现多进程之间的数据传递。" class="headerlink" title="创建共享的进程队列，Queue是多进程安全的队列，可以使用Queue实现多进程之间的数据传递。"></a>创建共享的进程队列，Queue是多进程安全的队列，可以使用Queue实现多进程之间的数据传递。</h2><pre><code>Queue([maxsize]) 创建共享的进程队列。maxsize是队列中允许的最大项数。如果省略此参数，则无大小限制。底层队列使用管道和锁定实现。另外，还需要运行支持线程以便队列中的数据传输到底层管道中。 Queue的实例q具有以下方法：q.get( [ block [ ,timeout ] ] ) 返回q中的一个项目。如果q为空，此方法将阻塞，直到队列中有项目可用为止。block用于控制阻塞行为，默认为True. 如果设置为False，将引发Queue.Empty异常（定义在Queue模块中）。timeout是可选超时时间，用在阻塞模式中。如果在制定的时间间隔内没有项目变为可用，将引发Queue.Empty异常。q.get_nowait( ) 同q.get(False)方法。q.put(item [, block [,timeout ] ] ) 将item放入队列。如果队列已满，此方法将阻塞至有空间可用为止。block控制阻塞行为，默认为True。如果设置为False，将引发Queue.Empty异常（定义在Queue库模块中）。timeout指定在阻塞模式中等待可用空间的时间长短。超时后将引发Queue.Full异常。q.qsize() 返回队列中目前项目的正确数量。此函数的结果并不可靠，因为在返回结果和在稍后程序中使用结果之间，队列中可能添加或删除了项目。在某些系统上，此方法可能引发NotImplementedError异常。q.empty() 如果调用此方法时 q为空，返回True。如果其他进程或线程正在往队列中添加项目，结果不可靠的。也就是说，在返回和使用结果之间，队列中可能已经加入新的项目。q.full() 如果q已满，返回为True. 由于线程的存在，结果也可能是不可靠的（参考q.empty（）方法）。。方法介绍</code></pre><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><pre><code>from multiprocessing import Process, Queueimport timedef fun(q):    print(&apos;my name is li&apos;)    q.put([&apos;lei&apos;, 1, 2, 3, 4])if __name__ == &apos;__main__&apos;:    q = Queue()    p = Process(target=fun, args=(q,))    p.start()    time.sleep(1)    print(q.get())</code></pre><h2 id="队里问题，-消费者生产模型"><a href="#队里问题，-消费者生产模型" class="headerlink" title="队里问题， 消费者生产模型"></a>队里问题， 消费者生产模型</h2><pre><code>from multiprocessing import Process, Queueimport timedef producer(q, name, food):    for i in range(10):        time.sleep(0.0005)        print(&apos;%s生产了%s%s&apos; % (name, food,i))        q.put(food + str(i))def consume(q, name):    while 1:        food = q.get()        if food is None:break        print(&apos;%s吃了%s&apos;%(name, food))if __name__ == &apos;__main__&apos;:    q = Queue()    p1 = Process(target=producer, args=(q,&apos;li&apos;,&apos;包子&apos;))    p1.start()    p2 = Process(target=consume, args=(q,&apos;alex&apos;))    p2.daemon = True    p2.start()    p1.join() #等p1的原因是先让生产完，防止生产来不及队列里面为空    q.put(None)</code></pre><p>#<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></p><p>##JoinableQueue 类</p><p>###put</p><p>###get</p><p>###task_done 通知队列已经有一个数据被处理了</p><p>###q.join() # 阻塞直到放入队列中所有的数据都被处理掉(有多少个数据就接收到了多少taskdone)</p><pre><code>import timeimport randomfrom multiprocessing import Process,JoinableQueuedef consumer(q,name):    #处理数据    while 1:        food = q.get()        time.sleep(random.uniform(0, 1))        print(&apos;%s吃了%s&apos;%(name, food))        q.task_done()def producer(q, name, food):    for i in range(10):        time.sleep(random.uniform(0,1))        print(&quot;%s生产了%s%s&quot;%(name, food, i))        q.put(food + str(i))if __name__ == &apos;__main__&apos;:    q = JoinableQueue()    c1 = Process(target=consumer, args=(q, &apos;lei&apos;))    c1.daemon = True #创建了一个守护进程    c1.start()    p1 = Process(target=producer, args=(q, &apos;wuyan&apos;, &apos;煎饼&apos;))    p1.start()    p1.join() #等待生产完毕， 保证了队列里面有全部的数据    q.join() #每次取出数据调用 q.task_done() 当为数据取玩阻塞消失</code></pre><p>#<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></p><h2 id="pipe的端口管理不会随着某一个进程的关闭就关闭"><a href="#pipe的端口管理不会随着某一个进程的关闭就关闭" class="headerlink" title="pipe的端口管理不会随着某一个进程的关闭就关闭"></a>pipe的端口管理不会随着某一个进程的关闭就关闭</h2><h3 id="操作系统来管理进程对这些端口的使用"><a href="#操作系统来管理进程对这些端口的使用" class="headerlink" title="操作系统来管理进程对这些端口的使用"></a>操作系统来管理进程对这些端口的使用</h3><h3 id="left-right"><a href="#left-right" class="headerlink" title="left,right"></a>left,right</h3><h3 id="left-right-1"><a href="#left-right-1" class="headerlink" title="left,right"></a>left,right</h3><h3 id="操作系统管理4个端口-每关闭一个端口计数-1，直到所有的端口都关闭了，"><a href="#操作系统管理4个端口-每关闭一个端口计数-1，直到所有的端口都关闭了，" class="headerlink" title="操作系统管理4个端口  每关闭一个端口计数-1，直到所有的端口都关闭了，"></a>操作系统管理4个端口  每关闭一个端口计数-1，直到所有的端口都关闭了，</h3><h3 id="剩余1个端口的时候-recv就会报错"><a href="#剩余1个端口的时候-recv就会报错" class="headerlink" title="剩余1个端口的时候 recv就会报错"></a>剩余1个端口的时候 recv就会报错</h3><pre><code>from multiprocessing import Pipe, Processdef pipeline(left, right):    ret = right.recv() #右边接受    print(&apos;%s&apos;%(ret))if __name__ == &apos;__main__&apos;:    left, right = Pipe()    p = Process(target=pipeline, args=(left, right))    left.send(&apos;你好，保重&apos;) #左边发送    p.start()def pipeline(left, right):    left.close()    while 1:        try:            print(right.recv())        except EOFError:            breakif __name__ == &apos;__main__&apos;:    left, right = Pipe()    p = Process(target=pipeline, args=(left, right))    p.start()    right.close()    for i in range(10):        left.send(i)    left.close()</code></pre><p>#<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></p><h3 id="为什么要有进程池？"><a href="#为什么要有进程池？" class="headerlink" title="为什么要有进程池？"></a>为什么要有进程池？</h3><pre><code>开启过多的进程并不能提高你的效率，反而会降低效率</code></pre><h3 id="计算密集型-充分占用CPU-多进程可以充分利用多核"><a href="#计算密集型-充分占用CPU-多进程可以充分利用多核" class="headerlink" title="计算密集型  充分占用CPU 多进程可以充分利用多核"></a>计算密集型  充分占用CPU 多进程可以充分利用多核</h3><pre><code>适合开启多进程，但是不适合开启很多多进程</code></pre><h3 id="IO密集型-大部分时间都在阻塞队列，而不是在运行状态中"><a href="#IO密集型-大部分时间都在阻塞队列，而不是在运行状态中" class="headerlink" title="IO密集型    大部分时间都在阻塞队列，而不是在运行状态中"></a>IO密集型    大部分时间都在阻塞队列，而不是在运行状态中</h3><pre><code>根本不太适合开启多进程</code></pre><p><strong>实例化 传参数 进程的个数 cpu/cpu+1<br>提交任务<br>同步提交 apply<br>    返回值 ： 子进程对应函数的返回值<br>    一个一个顺序执行的，并没有任何并发效果<br>异步提交 apply_async<br>    没有返回值，要想所有任务能够顺利的执行完毕<br>        p.close()<br>        p.join() # 必须先close再join，阻塞直到进程池中的所有任务都执行完毕<br>    有返回值的情况下<br>        res.get() # get不能再提交任务之后立刻执行，应该是先提交所有的任务再通过get获取结果<br>    map()方法<br>        异步提交的简化版本<br>        自带close和join方法</strong></p><p> #<strong>*</strong><br>    from multiprocessing import Pool<br>    import time<br>    def fun(i):<br>        print(i)<br>    if <strong>name</strong> == ‘<strong>main</strong>‘:<br>        p = Pool(5)<br>        start = time.clock()<br>        for i in range(10000):</p><pre><code>    # p.apply_async(func=fun, args=(i,)) #异步提交 1.3874192285529539(时间)    p.apply(fun, args=(i,)) #通同步提交2.2022746500453803(时间)p.close() # 关闭进程池，用户不能再向这个池中提交任务了p.join() # 阻塞，直到进程池中所有的任务都被执行完end = time.clock()print(end - start)</code></pre><p>#<strong>*</strong></p><pre><code>from multiprocessing import Poolimport timedef fun(i):    print(i)    return i*2if __name__ == &apos;__main__&apos;:    p = Pool(5)    start = time.clock()    p_lis = []    for i in range(10000):        ret = p.apply_async(func=fun, args=(i,)) #异步提交 1.3874192285529539(时间)        p_lis.append(ret)         # p.apply(fun, args=(i,)) #通同步提交2.2022746500453803(时间)    p.close() # 关闭进程池，用户不能再向这个池中提交任务了    p.join() # 阻塞，直到进程池中所有的任务都被执行完    for ret in p_lis:        print(ret.get()) #取出进程里面的返回值    end = time.clock()    print(end - start)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;创建共享的进程队列，Queue是多进程安全的队列，可以使用Queue实现多进程之间的数据传递。&quot;&gt;&lt;a href=&quot;#创建共享的进程队列，Queue是多进程安全的队列，可以使用Queue实现多进程之间的数据传递。&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>异常处理</title>
    <link href="http://yoursite.com/2018/10/02/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2018/10/02/异常处理/</id>
    <published>2018-10-02T04:24:38.954Z</published>
    <updated>2018-10-03T10:32:13.985Z</updated>
    
    <content type="html"><![CDATA[<p>##1：初始异常</p><p>###即便是放在try语句中的内容，在遇到报错之后也会中断这段语句的执行</p><p>####1.1 类型异常<br>    l = [‘登录’, ‘注册’]<br>    try:<br>        num = int(input(‘input :’)) #输入：非数字报错 invalid literal for int() with base 10: ‘j’<br>    except ValueError:<br>        print(‘异常：num’)</p><p>####1.2列表索引异常<br>    try:<br>        num = int(input(‘input:’))<br>        print(l[num -1]) #输入数字大于2 IndexError: list index out of range<br>    except IndexError:<br>        print(‘异常：索引超标!’)</p><p>####1.3多分支异常<br>    try:<br>        num = int(input(‘input: ‘))<br>        print(l[num-1])<br>    except IndexError:<br>        print(‘索引越界！’)<br>    except ValueError:<br>        print(‘类型有误！’)</p><p>####1.4多异常<br>    try:<br>           num = int(input(‘input:’))<br>          print(l[num -1])<br>    except (ValueError, IndexError):<br>          print(‘报错！’)</p><p>####1.5万能异常</p><pre><code>try:    l = []    # l[3]    open(&apos;aaa&apos;)except Exception:    print(&apos;异常！&apos;)</code></pre><p>####1.6 as 异常<br>    try:<br>        l[3] #list index out of range<br>        name #name ‘name’ is not defined<br>    except Exception as e:<br>        print(e) #抛出异常的内容</p><p>####1.7 多异常加万能异常<br>    try:<br>        num = int(input(‘input :’))<br>        print(l[num -1])<br>    except (ValueError, IndexError):<br>        print(‘异常！’) #持性了这里下面的将不在执行<br>    except Exception as e:<br>        print(e)</p><p>##2：异常的其他处理机制</p><p>####2.1 else 机制<br>    try:<br>        print(‘My name is Dan’)<br>    except ValueError:<br>        print(‘name is leiwenxuan’)<br>    else:<br>        print(‘出错了’) #报错将不执行, 没触发异常将执行</p><p>###2.2finally</p><pre><code>try:    name #异常    print(&apos;hello !&apos;)except NameError:    print(&apos;报错！&apos;)finally:    print(&apos;你好！&apos;) #无论异常处不触发都执行# finally 无论如何都要执行# 收尾工作，打开了一个文件，占用了一个网络资源，打开了一个和数据库的链接try:    f = open(&apos;content&apos;)    name #即使报错了，也执行finallyfinally:    f.close()    print(&apos;执行了！&apos;)</code></pre><p>###2.3 强制异常<br>    raise NameError(‘name’)<br>    raise NameError</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##1：初始异常&lt;/p&gt;
&lt;p&gt;###即便是放在try语句中的内容，在遇到报错之后也会中断这段语句的执行&lt;/p&gt;
&lt;p&gt;####1.1 类型异常&lt;br&gt;    l = [‘登录’, ‘注册’]&lt;br&gt;    try:&lt;br&gt;        num = int(input(‘
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>协程，线程池</title>
    <link href="http://yoursite.com/2018/10/02/%E5%8D%8F%E7%A8%8B%EF%BC%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://yoursite.com/2018/10/02/协程，线程池/</id>
    <published>2018-10-02T04:24:38.924Z</published>
    <updated>2018-10-03T10:34:27.305Z</updated>
    
    <content type="html"><![CDATA[<p>标签（空格分隔）：线程池/协程</p><p>#线程池</p><p>###concurrent.futures模块提供了一个用于异步执行callables的高级接口。</p><p>##<strong>concurrent.futures.ThreadPoolExecutor</strong></p><p>###submit（fn，* args，** kwargs ）<br>将可调用的fn调度为执行， 并返回表示可调用执行的对象</p><pre><code>from concurrent.futures import ThreadPoolExecutordef fun(i):    print(&apos;my name is %s&apos;%i)t = ThreadPoolExecutor(5)for i in range(10):    ret = t.submit(fun, i)    #返回一个可执行的对象 &lt;Future at 0x7f2da90c3e10 state=pending&gt;</code></pre><p>###<strong>shutdown(wait=True) </strong><br>相当于进程池的pool.close()+pool.join()操作<br>wait=True，等待池内所有任务执行完毕回收完资源后才继续<br>wait=False，立即返回，并不会等待池内的任务执行完毕<br>但不管wait参数为何值，整个程序都会等到所有任务执行完毕<br>submit和map必须在shutdown之前</p><p>####具体代码</p><pre><code>def fun(i):print(&apos;my name is %s&apos;%i)return i*2t = ThreadPoolExecutor(5)for i in range(10):    ret = t.submit(fun, i)    print(ret.result()) #查看返回的结果t.shutdown() #表示线程都执行完毕print(&apos;主进程结束&apos;)</code></pre><p>###map  取代for循环submit的操作</p><pre><code>from concurrent.futures import ThreadPoolExecutordef fun(i):    print(&apos;my name is %s&apos;%i)    return i*2t = ThreadPoolExecutor(5)res = map(fun, range(20))for i in res:print(i)</code></pre><p>##ProcessPoolExecutor<br>它是Executor使用的过程池异步执行调用子类。 ProcessPoolExecutor使用该multiprocessing模块，它允许它侧向全局解释器锁定，但也意味着只能执行和返回可选对象。<br>该<strong>main</strong>模块必须可由工作程序子进程导入。这意味着ProcessPoolExecutor在交互式解释器中不起作用。</p><p>###简单的回调函数</p><pre><code>from concurrent.futures import ProcessPoolExecutordef fun(i):    print(i)    return i*2def call_back(arg):    print(&apos;call back:&apos;, arg.result())if __name__ == &apos;__main__&apos;:    p = ProcessPoolExecutor()    for i in range(20):        p.submit(fun, i).add_done_callback(call_back)    print(&apos;主线程&apos;)</code></pre><p>##××××××××××××××××××××××××××××××××××××××</p><p>##<strong>协程</strong></p><p>###协程的优势：<br>    线程： 计算机中能被cpu执行的最小单位<br>        一条线程在多个任务之间来回切换，切换这个动作是浪费时间的<br>        对与cpu， 操作系统来说协程是不存在的# 一个任务不得不陷入阻塞， 在这个任务的过程中切换到另一个任务继续执行<br>    你的程序的只要还需要执行， 你的当前线程永远不会阻塞<br>    同时做几件事件，在做一件事件的时候还可以做其他的事件，比如做饭的时候，煮粥的时候可以切菜，炒菜，干一些其他事件，等待煮粥事件<br>    合理的利用时间， 不要等待一个事件， 比如程序的时候，在阻塞的时候干一些其他啊的事件</p><p>###协程模块：<br>    利用协程来进行多个任务陷入阻塞的时候进行切换来保证在处理多个任务的时候总是忙<br>    无论是进程还是线程都是有操作系统来切换的，开启的线程，进程会给操作系统的调动带来压力<br>    如果我们使用的是协程，协程在程序之间的切换操作系统感知不到，无论开启多个协程对操作系统的调用不会带来压力</p><p> spawn(函数名) 产生了一个协程任物在遇到IO操作的时候帮助我们在多任务之&gt; 间自动切换<br>    join()        阻塞 直到某个任务被执行完毕<br>    join_all()<br>    value属性      获取返回值</p><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><pre><code>from gevent import monkeymonkey.patch_all() #dimport threadingimport timeimport geventdef fun1():    print(&apos;1111&apos;)    gevent.sleep(1)    print(&apos;2222&apos;)    g1_id = threading.current_thread().getName()    print(g1_id)def fun2():    print(&apos;3333&apos;)    gevent.sleep(1)    print(&apos;44444&apos;)    #查看进程ID    g2_id = threading.current_thread().getName()    print(g2_id) #假的线程g1 = gevent.spawn(fun1)#遇到阻塞就回切换g2 = gevent.spawn(fun2)gevent.joinall([g1, g2]) #等待子线程结束</code></pre><p>###<strong>爬虫示例代码</strong></p><p>###具体的示例</p><pre><code>from gevent import monkeymonkey.patch_all()import timeimport geventimport requestsusl_list = [        &apos;http://www.baidu.com&apos;,        &apos;http://www.4399.com&apos;,        &apos;http://www.7k7k.com&apos;,        &apos;http://www.sogou.com&apos;,        &apos;http://www.sohu.com&apos;,        &apos;http://www.sina.com&apos;,        &apos;http://www.jd.com&apos;,        &apos;https://www.luffycity.com/home&apos;,        &apos;https://www.douban.com&apos;,        &apos;http://www.cnblogs.com/Eva-J/articles/8324673.html&apos;,        &apos;http://www.baidu.com&apos;,        &apos;http://www.7k7k.com&apos;,        &apos;http://www.sogou.com&apos;,        &apos;http://www.sohu.com&apos;,        &apos;https://www.luffycity.com/home&apos;,    ]def get_url(url):    response = requests.get(url)    if response.status_code == 200: #查看验证网页是否通        print(url, len(response.text)) #response.text网页的信息        passstart = time.time()for url in usl_list:    get_url(url)print(time.time() - start) #7.55start = time.time()g_lis = []for url in usl_list:    g = gevent.spawn(get_url, url)    #响应网页有延迟， 在延迟期间切换其他任务执行    g_lis.append(g)gevent.joinall(g_lis)print(time.time() - start) # 1.7</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;标签（空格分隔）：线程池/协程&lt;/p&gt;
&lt;p&gt;#线程池&lt;/p&gt;
&lt;p&gt;###concurrent.futures模块提供了一个用于异步执行callables的高级接口。&lt;/p&gt;
&lt;p&gt;##&lt;strong&gt;concurrent.futures.ThreadPoolExecut
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>线程知识点</title>
    <link href="http://yoursite.com/2018/10/02/%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://yoursite.com/2018/10/02/线程知识点/</id>
    <published>2018-10-02T04:24:38.895Z</published>
    <updated>2018-10-03T10:34:20.567Z</updated>
    
    <content type="html"><![CDATA[<p>#线程知识点</p><p>##1线程锁</p><p>###1.1GIL</p><p>###1.2线程之间的数据安全问题<br>    例如：多个线程对同一块数据进行操作；<br>            比如赋值运算， 一个线程那到数据还没有返回数据结果时间片轮转，引起数据的不安全；<br>        pop, append 操作是安全的，<br>        队列也是安全的</p><p>####具体操作<br>    <code>此处输入代码    from threading import Thread, Lock</code><br>    lock.acquire()<br>    ‘’’<br>        对数据的操作<br>    ‘’’<br>    lock.release()</p><p>###1.3递归锁和死锁现象</p><p>####死锁<br>     是指两个或两个以上的进程或线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程，如下就是死锁</p><p>#####死锁现象<br>        两把锁<br>        异步的<br>        操作的时候 抢到一把锁之后还要再去抢第二把锁<br>        一个线程抢到一把锁<br>        另一个线程抢到了另一把锁</p><p>####解决办法<br>    解决方法，递归锁，在Python中为了支持在同一线程中多次请求同一资源，python提供了可重入锁RLock。这个RLock内部维护着一个Lock和一个counter变量，counter记录了acquire的次数，从而使得资源可以被多次require。直到一个线程所有的acquire都被release，其他的线程才能获得资源。上面的例子如果使用RLock代替Lock，则不会发生死锁：</p><p>####示例代码<br>    import time<br>    def fun(lock):<br>        lock.acquire()<br>        print(‘我还活着’)<br>        lock.release()<br>        time.sleep(1)<br>        lock.acquire()<br>        print(‘你还没死’)<br>        lock.release()<br>    def func(lock):<br>        lock.acquire()<br>        lock.acquire()<br>        print(‘没死’)<br>        lock.release()<br>        lock.release()                           </p><pre><code>if __name__ == &apos;__main__&apos;:                       lock = Lock()                                # for i in range(10):                        t1 = Thread(target=fun, args=(lock,))        t1.start()                                   t2 = Thread(target=func, args=(lock,))       t2.start()      </code></pre><p>###递归锁<br>    在Python中为了支持在同一线程中多次请求同一资源，python提供了可重入锁RLock。这个RLock内部维护着一个Lock和一个counter变量，counter记录了acquire的次数，从而使得资源可以被多次require。直到一个线程所有的acquire都被release，其他的线程才能获得资源。上面的例子如果使用RLock代替Lock，则不会发生生死锁</p><p>####具体代码<br>    from threading import Thread, RLock<br>    fork_lock = noodle_lock = RLock()# 一把锁<br>    def fun1(*args):<br>        noodle_lock.acquire()                   </p><pre><code>#具体操作                                   fork_lock.acquire()                     # 具体操作                                  fork_lock.release()                     noodle_lock.release()  #只有当锁释放后才能执行其他操作</code></pre><h3 id="递归锁可以解决互斥锁的死锁问题"><a href="#递归锁可以解决互斥锁的死锁问题" class="headerlink" title="递归锁可以解决互斥锁的死锁问题"></a>递归锁可以解决互斥锁的死锁问题</h3><pre><code># 互斥锁 ¦   # 两把锁 ¦   # 多个线程抢 # 递归锁 ¦   # 一把锁 ¦   # 多个线程抢</code></pre><h4 id="递归锁能够快速的解决死锁问题"><a href="#递归锁能够快速的解决死锁问题" class="headerlink" title="递归锁能够快速的解决死锁问题"></a>递归锁能够快速的解决死锁问题</h4><pre><code>  # 递归锁好不好？  不好， 出现死锁，肯定是程序的逻辑有问题， 在快速解决死锁的情况下， 修改程序的逻辑。 递归锁 迅速恢复服务 递归锁替换互斥锁     在接下来的时间中慢慢把递归锁替换成互斥锁     能够完善代码的逻辑     提高代码的效率多个线程之间，用完一个资源再用另外一个资源先释放一个资源，再去获取一个资源的锁</code></pre><p>###信号量<br>    与进程的的信号量用法一样</p><p>###<strong>事件Event</strong><br>    wait() 等待 事件内的信号编程True<br>    set()  把信号变成True<br>    clear  把信号变成False<br>    is_set 查看信号状态是否为True</p><p>###示例代码<br>    from threading import<br>    import time          </p><pre><code>def fun1(e):             e.wait()   #在set没有调用之前下面的语句不执行     print(&apos;你好呀，我来了&apos;) def fun2(e):             time.sleep(5)        e.set()          if __name__ == &apos;__mai    e = Event()          t1 = Thread(targe    t1.start()           t2 = Thread(targe    t2.start()       </code></pre><p>###<strong>条件 Condition</strong><br>    Python提供的Condition对象提供了对复杂线程同步问题的支持。Condition被称为条件变量，除了提供与Lock类似的acquire和release方法外，还提供了wait和notify方法。线程首先acquire一个条件变量，然后判断一些条件。如果条件不满足则wait；如果条件满足，进行一些处理改变条件后，通过notify方法通知其他线程，其他处于wait状态的线程接到通知后会重新判断条件。不断的重复这一过程，从而解决复杂的同步问题<br>    from threading import Condition, Thread<br>    def fun(con, name):<br>        print(‘欢迎光临’)<br>        con.acquire()<br>        con.wait()     #使用前后都需要加锁<br>        print(‘%s go to school’%name)<br>        con.release()<br>    if <strong>name</strong> == ‘<strong>main</strong>‘:<br>        con = Condition()<br>        for i in range(10):<br>            t = Thread(target=fun, args=(con, i))<br>            t.start()<br>        con.acquire()                                                                      </p><pre><code># con.notify(4)   #使用前后都需要加锁  每次默认一个，参数代表通过的次数                                     # con.notify_all()                                                                 con.notifyAll()                                                                    con.release()       </code></pre><p>###定时器 Timer<br>定时器，指定n秒后执行某个操作</p><pre><code>from threading import Thread, Timer                       def func():                                                   print(&apos;Timer: going to &apos;)                             if __name__ == &apos;__main__&apos;:                                    t = Timer(5, func)                                        t.start()                                   </code></pre><p>###线程队列 queue队列<br>跟队列进程队列一样的用法</p><pre><code>q = queue.Queue()         q.put(1)                  q.put(2)                  q.put(3)                  #先进先出原则                   print(q.get())    #1      print(q.get())    #2      print(q.get())    #3      </code></pre><p>###<strong>线程队列 LifoQueue</strong><br>和栈类似先进后出</p><pre><code>from queue import LifoQueueq = LifoQueue()q.put(1)q.put(2)q.put(3)print(q.get()) #3print(q.get()) #2print(q.get()) #1</code></pre><p>###<strong>PriorityQueue</strong><br>存储数据时可设置优先级的队列</p><pre><code>from queue import PriorityQueueq = PriorityQueue()q.put((3,&apos;lei&apos;))q.put((2,&apos;wen&apos;))q.put((1,&apos;xuan&apos;))print(q.get())print(q.get())print(q.get())</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#线程知识点&lt;/p&gt;
&lt;p&gt;##1线程锁&lt;/p&gt;
&lt;p&gt;###1.1GIL&lt;/p&gt;
&lt;p&gt;###1.2线程之间的数据安全问题&lt;br&gt;    例如：多个线程对同一块数据进行操作；&lt;br&gt;            比如赋值运算， 一个线程那到数据还没有返回数据结果时间片轮转，引起
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>网络编程</title>
    <link href="http://yoursite.com/2018/10/02/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/10/02/网络编程/</id>
    <published>2018-10-02T04:24:38.864Z</published>
    <updated>2018-10-03T10:34:13.019Z</updated>
    
    <content type="html"><![CDATA[<p>##1：软件开发的架构</p><p>###两件程序之间通讯的应用大致可以分为两种：<br>    第一种：qq. 微信，网盘，优酷 这一类是属于需要安装的桌面应用<br>    第二种：比如百度， 知乎，博客园之类</p><p>####c/s架构<br>    即Client 与 Server， 客户端与服务器的端架构</p><p>####b/s架构<br>    Browser 与 Serverm 浏览器与服务端架构</p><p>##IP地址</p><pre><code>1: 网卡 ：身份证 mac地址 计算机在网络上的身份证2: 交换机 ：负责一个网络内的多台机器之间的信息交换3: mac地址 ：16进制的数  全球唯一1: 127.0.0.1 ：本地回环地址 本机的地址2: 0.0.0.0 ： ip地址的、回环地址的所有的用户都能找到你这台机器</code></pre><p>####局域网</p><pre><code># 局域网1: 网关ip    不同局域网之间通信依赖的ip地址2: 子网掩码  判断两个ip地址是否在同一个网段内3：网段# 0.0.0.0 - 255.255.255.255# 局域网的概念# 外网ip 我们谁都能访问# 内网ip 从外部不能访问，只能在内部环境中互相访问# 外网ip永远不会和内网ip冲突？# 0.0.0.0 - 255.255.255.255中间为内网保留了一些字段# 192.168.0.0 - 192.168.255.255# 10.0.0.0 - 10.255.255.255# 172.16.0.0 - 172.31.255.255</code></pre><p>###局域网中两台机器的通信原理</p><h1 id="局域网中两台机器的通信原理"><a href="#局域网中两台机器的通信原理" class="headerlink" title="局域网中两台机器的通信原理"></a>局域网中两台机器的通信原理</h1><pre><code># 交换机# ip地址# ip地址 -arp协议-&gt; mac地址# mac地址 ： 全球唯一# arp协议 ： 广播 和 单播    # 通过ip地址获取mac地址    # 一台机器A发起一个arp请求（只包含ip地址），发送给交换机    # 交换机接收到请求，广播这条消息    # 所有的机器都会接收到这个请求，只有和要寻找ip地址吻合的机器B    # 才会回应交换机的广播，（带着自己的mac地址）    # 交换机通过单播的形式将回复的B的mac地址发送给A# 判断两台机器是不是在同一个局域网内：    # 子网掩码    # A机器的ip地址和A的子网掩码 按位与    # B机器的ip地址和B的子网掩码 按位与    # 得到的结果如果一致 那么说明两台机器是在一个网段内的</code></pre><p>####端口</p><pre><code># 端口的概念 —— 帮助你找到一个应用# 每一个网络服务都会占用计算机上的一个端口# 计算机上的端口范围 0-65535# 在同一时刻 同一台计算机上 不同的网络应用 占用的端口一定是不同的</code></pre><p>##2：OSI 七层模型</p><p>####在7层的基础上简化为5层</p><pre><code># 应用层 http、https ftp smtp# 传输层 TCP、UDP协议  4层路由器， 4层交换机        # 端口 ：找到某一台机器上的具体的网络应用        # tcp 面向连接 可靠 慢 全双工            # 三次握手 建立tcp连接的过程            # 发消息            # 四次挥手 断开tcp连接的过程           # udp 无连接 不可靠 快# 网络层 ip协议  3层交换机 3层路由器# 数据链路层 arp协议 / mac地址 网卡，交换机        arp协议：根据ip地址找mac地址 ----交换机（广播， 单播）# 物理层</code></pre><p>##Tcp 和 Udp</p><h4 id="tcp-面向连接的-可靠的-但是慢"><a href="#tcp-面向连接的-可靠的-但是慢" class="headerlink" title="tcp 面向连接的 可靠的 但是慢"></a>tcp 面向连接的 可靠的 但是慢</h4><pre><code># tcp协议# 两个应用之间要想通信 必须先建立连接# 然后基于连接来通信# 比较重要的文件 邮件的发送 下载安装包#比较可靠的长数据</code></pre><h4 id="udp-无连接的-快-能够发送的信息长度是有限的"><a href="#udp-无连接的-快-能够发送的信息长度是有限的" class="headerlink" title="udp 无连接的 快 能够发送的信息长度是有限的"></a>udp 无连接的 快 能够发送的信息长度是有限的</h4><pre><code># 快 但 不可靠 不能发送过长的数据# 即时通讯类的程序#高并发的短消息</code></pre><p>###tcp和udp 的区别<br>     tcp、udp是通过网络通信的两种方式<br>       tcp 先建立连接再通信</p><pre><code>    # 可靠    # 慢， 流式传输udp 不需要建立连接直接通信    # 快    # 不可靠</code></pre><p>###<strong>TCP协议中的数据传递</strong></p><p>###tcp协议的拆包机制</p><pre><code>当发送端缓冲区的长度大于网卡的MTU时，tcp会将这次发送的数据拆成几个数据包发送出去。 MTU是Maximum Transmission Unit的缩写。意思是网络上传送的最大数据包。MTU的单位是字节。 大部分网络设备的MTU都是1500。如果本机的MTU比网关的MTU大，大的数据包就会被拆开来传送，这样会产生很多数据包碎片，增加丢包率，降低网络速度。</code></pre><p>###面向流的通信特点和Nagle算法</p><pre><code>TCP（transport control protocol，传输控制协议）是面向连接的，面向流的，提供高可靠性服务。收发两端（客户端和服务器端）都要有一一成对的socket，因此，发送端为了将多个发往接收端的包，更有效的发到对方，使用了优化方法（Nagle算法），将多次间隔较小且数据量小的数据，合并成一个大的数据块，然后进行封包。这样，接收端，就难于分辨出来了，必须提供科学的拆包机制。 即面向流的通信是无消息保护边界的。 对于空消息：tcp是基于数据流的，于是收发的消息不能为空，这就需要在客户端和服务端都添加空消息的处理机制，防止程序卡住，而udp是基于数据报的，即便是你输入的是空内容（直接回车），也可以被发送，udp协议会帮你封装上消息头发送过去。 可靠黏包的tcp协议：tcp的协议数据不会丢，没有收完包，下次接收，会继续上次继续接收，己端总是在收到ack时才会清除缓冲区内容。数据是可靠的，但是会粘包。</code></pre><p>###一个简单的tcp： server 和 client</p><p>####sever<br>    from socket import *<br>    ip_port = (‘127.0.0.1’, 9514)</p><pre><code>sk = socket(AF_INET, SOCK_STREAM)sk.bind(ip_port)sk.listen()sk_cl, addr = sk.accept()data1 = sk_cl.recv(10)data2 = sk_cl.recv(10)print(&apos;-----&gt;&apos;, data1.decode(&apos;utf-8&apos;))print(&apos;-----&gt;&apos;, data2.decode(&apos;utf-8&apos;))sk_cl.close()</code></pre><p>####client<br>    from socket import *<br>    ip_port = (‘127.0.0.1’, 9514)</p><pre><code>sk = socket(AF_INET, SOCK_STREAM)sk.connect(ip_port)sk.send(b&apos;my name is leiwenxuan&apos;)sk.send(b&apos;nsdfasfdsf&apos;)</code></pre><p>####udp的简单程序</p><p>###sever<br>    import socket<br>    sk = socket.socket(type=socket.SOCK_DGRAM)</p><pre><code>sk.bind((&apos;127.0.0.1&apos;, 9000))while 1:    msg,addr = sk.recvfrom(1024)    print(msg.decode(&apos;utf-8&apos;), addr)    # sk.sendto(&apos;正在发送...&apos;.encode(&apos;utf-8&apos;), addr)    inp = input(&apos;input :&apos;)</code></pre><p>###client<br>    import socket</p><pre><code>sk = socket.socket(type=socket.SOCK_DGRAM)sk.bind((&apos;127.0.0.1&apos;, 9001))while 1:    # sk.sendto(&apos;正在发送...&apos;.encode(&apos;utf-8&apos;), (&apos;127.0.0.1&apos;, 9000))    inp = input(&apos;input:&apos;)    sk.sendto(inp.encode(&apos;utf-8&apos;),(&apos;127.0.0.1&apos;, 9000) )    msg, addr = sk.recvfrom(1024)    print(msg.decode(&apos;utf-8&apos;), addr[1])</code></pre><p>##一个重要的黏包处理</p><p>###server<br>    import json, struct<br>    ‘’’传输一个简单的文件’’’<br>    import os<br>    from socket import *<br>    path_name = r’G:\python笔记\Pythonjing\day31\video\1.内容回顾和作业讲解.mp4’<br>    path_name = os.path.realpath(path_name)<br>    size = str(os.path.getsize(path_name))</p><pre><code>ip_port = (&apos;127.0.0.1&apos;, 9514)sk = socket(AF_INET, SOCK_STREAM)sk.bind(ip_port)sk.listen()sk_cl, addr = sk.accept()sk_cl.send(size.encode(&apos;utf-8&apos;))with open(path_name, &apos;rb&apos;) as f:    while 1:        data = f.read(2048)        pack_num = struct.pack(&apos;i&apos;, len(data))        sk_cl.send(pack_num)        sk_cl.send(data)        if not data:            pack_num = struct.pack(&apos;i&apos;, len(&apos;&apos;))            sk_cl.send(pack_num)            print(len(data))            break</code></pre><p>##client<br>    from socket import *<br>    import struct<br>    import sys</p><pre><code>def processBar(num, total):    &apos;&apos;&apos;进度条&apos;&apos;&apos;    rate = num / total    rate_num = int(rate * 100)    if rate_num == 100:        r = &apos;\r%s&gt;%d%%\n&apos; % (&apos;|&apos; * rate_num, rate_num,)    else:        r = &apos;\r%s&gt;%d%%&apos; % (&apos;|&apos; * rate_num, rate_num,)    sys.stdout.write(r)    sys.stdout.fluship_port = (&apos;127.0.0.1&apos;, 9514)sk = socket(AF_INET, SOCK_STREAM)sk.connect(ip_port)size = int(sk.recv(1024).decode(&apos;utf-8&apos;))# processBar(2048, size)num_size = 0with open(&apos;lw.mp4&apos;,&apos;wb&apos;) as f:    while 1:        pack_num = sk.recv(4)        num = struct.unpack(&apos;i&apos;, pack_num)[0]        # print(num)        if not num:            break        ret = sk.recv(num)        f.write(ret)        num_size += num        processBar(num_size, size)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##1：软件开发的架构&lt;/p&gt;
&lt;p&gt;###两件程序之间通讯的应用大致可以分为两种：&lt;br&gt;    第一种：qq. 微信，网盘，优酷 这一类是属于需要安装的桌面应用&lt;br&gt;    第二种：比如百度， 知乎，博客园之类&lt;/p&gt;
&lt;p&gt;####c/s架构&lt;br&gt;    即Cli
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
  </entry>
  
</feed>
