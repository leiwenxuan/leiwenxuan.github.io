<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Leiwenxuan</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-10-05T06:26:05.542Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Leiwenxuan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mysql增删改查</title>
    <link href="http://yoursite.com/2018/10/05/Mysql%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/"/>
    <id>http://yoursite.com/2018/10/05/Mysql增删改查/</id>
    <published>2018-10-05T06:26:05.532Z</published>
    <updated>2018-10-05T06:26:05.542Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL数据操作： DML<br>在MySQL管理软件中，可以通过SQL语句中的DML语言来实现数据的操作，包括</p><ol><li>使用INSERT实现数据的插入</li><li>UPDATE实现数据的更新</li><li>使用DELETE实现数据的删除</li><li>使用SELECT查询数据以及。</li></ol><h1 id="insert-插入数据"><a href="#insert-插入数据" class="headerlink" title="insert 插入数据"></a>insert 插入数据</h1><h2 id="插入完整数据"><a href="#插入完整数据" class="headerlink" title="插入完整数据"></a>插入完整数据</h2><pre><code>insert into class values(1, &apos;语文&apos;);</code></pre><h2 id="插入指定字段数据"><a href="#插入指定字段数据" class="headerlink" title="插入指定字段数据"></a>插入指定字段数据</h2><pre><code>insert into class(name) values(&apos;数学&apos;);</code></pre><h2 id="插入多条的数据"><a href="#插入多条的数据" class="headerlink" title="插入多条的数据"></a>插入多条的数据</h2><pre><code>insert into class(name) values(&apos;数学&apos;), (&apos;物理&apos;), (&apos;化学&apos;), (&apos;历史&apos;);</code></pre><h2 id="插入查询结果"><a href="#插入查询结果" class="headerlink" title="插入查询结果"></a>插入查询结果</h2><pre><code>insert into student(class_id) select id from class where name = &apos;语文&apos;;</code></pre><h1 id="update-更新数据"><a href="#update-更新数据" class="headerlink" title="update 更新数据"></a>update 更新数据</h1><pre><code>update class set name = &apos; 文学&apos; where id = 1;</code></pre><h1 id="delete-删除数据"><a href="#delete-删除数据" class="headerlink" title="delete 删除数据"></a>delete 删除数据</h1><pre><code>delete from class where id = 1;删除id = 1的数据</code></pre><h1 id="select查询–单表查询"><a href="#select查询–单表查询" class="headerlink" title="select查询–单表查询"></a>select查询–单表查询</h1><h3 id="单表查询的语法"><a href="#单表查询的语法" class="headerlink" title="单表查询的语法"></a>单表查询的语法</h3><pre><code>SELECT 字段1,字段2... FROM 表名                     WHERE 条件                     GROUP BY field                     HAVING 筛选                     ORDER BY field                     LIMIT 限制条数</code></pre><h3 id="关键字执行的优先级"><a href="#关键字执行的优先级" class="headerlink" title="关键字执行的优先级"></a>关键字执行的优先级</h3><pre><code>fromwheregroup byhavingselectdistinctorder bylimit1.找到表:from2.拿着where指定的约束条件，去文件/表中取出一条条记录3.将取出的一条条记录进行分组group by，如果没有group by，则整体作为一组4.将分组的结果进行having过滤5.执行select6.去重7.将结果按条件排序：order by8.限制结果的显示条数</code></pre><h2 id="简单查询"><a href="#简单查询" class="headerlink" title="简单查询"></a>简单查询</h2><h3 id="按字段查找"><a href="#按字段查找" class="headerlink" title="按字段查找"></a>按字段查找</h3><pre><code>select 字段,字段，... from 表;</code></pre><h3 id="查询所有"><a href="#查询所有" class="headerlink" title="查询所有"></a>查询所有</h3><pre><code>select * from 表;</code></pre><h3 id="避免重复-distinct"><a href="#避免重复-distinct" class="headerlink" title="避免重复 distinct"></a>避免重复 distinct</h3><pre><code>select distinct 字段 from 表;</code></pre><h3 id="通过四则运算查询"><a href="#通过四则运算查询" class="headerlink" title="通过四则运算查询"></a>通过四则运算查询</h3><pre><code>1. select 字段, 字段（能进行运算的类型） from 表;2. select 字段, 字段（能进行运算的类型）  as 别名 from 表;</code></pre><h3 id="定义显示格式"><a href="#定义显示格式" class="headerlink" title="定义显示格式"></a>定义显示格式</h3><pre><code>连接字符串 concat()select concat(&apos;姓名:&apos;, emp_name, &apos;年薪:&apos;, salary*12) as Annual_salary from employee;</code></pre><h3 id="以第一个参数为分隔符-concan-ws"><a href="#以第一个参数为分隔符-concan-ws" class="headerlink" title="以第一个参数为分隔符() concan_ws"></a>以第一个参数为分隔符() concan_ws</h3><pre><code>select concat_ws(&apos;:&apos;, emp_name, salary*12) as Annual_salary from employee;</code></pre><h3 id="结合case语句："><a href="#结合case语句：" class="headerlink" title="结合case语句："></a>结合case语句：</h3><pre><code>条件判断符合条件进行字符串拼接SELECT   (       CASE       WHEN emp_name = &apos;jingliyang&apos; THEN           emp_name       WHEN emp_name = &apos;alex&apos; THEN           CONCAT(emp_name,&apos;_BIGSB&apos;)       ELSE           concat(emp_name, &apos;SB&apos;)       END   ) as new_name</code></pre><p>   FROM<br>       employee;</p><h2 id="where约束"><a href="#where约束" class="headerlink" title="where约束"></a>where约束</h2><ol><li>比较运算符：&gt; &lt; &gt;= &lt;= &lt;&gt; !=</li><li>between 80 and 100 值在10到20之间</li><li>in(80,90,100) 值是10或20或30</li><li>like ‘egon%’<br> pattern可以是%或_，<br> %表示任意多字符<br> _表示一个字符 </li><li>逻辑运算符：在多个条件直接可以使用逻辑运算符 and or not<h3 id="单条件查询"><a href="#单条件查询" class="headerlink" title="单条件查询"></a>单条件查询</h3></li></ol><pre><code>查询所以 post =&apos;sale&apos; 数据select emp_name from employee where post =&apos;sale&apos;;</code></pre><h3 id="多条件查询"><a href="#多条件查询" class="headerlink" title="多条件查询"></a>多条件查询</h3><pre><code>and 多条件select emp_name, salary  from employee where post =&apos;teacher&apos; and salary &gt; 1000;between 在指定范围内 and是指定范围not between 不在指定范围select emp_name, salary  from employee where salary between 10000 and 20000;</code></pre><h3 id="关键字IS-NULL-判断某个字段是否为NULL不能用等号，需要用IS"><a href="#关键字IS-NULL-判断某个字段是否为NULL不能用等号，需要用IS" class="headerlink" title="关键字IS NULL(判断某个字段是否为NULL不能用等号，需要用IS)"></a>关键字IS NULL(判断某个字段是否为NULL不能用等号，需要用IS)</h3><pre><code>需要注意 空字符串不是nullselect emp_name, post_comment from employee where post_comment is null;</code></pre><h3 id="关键字IN集合查SELECT-emp-name-salary-FROM-employee"><a href="#关键字IN集合查SELECT-emp-name-salary-FROM-employee" class="headerlink" title="关键字IN集合查SELECT emp_name,salary FROM employee"></a>关键字IN集合查SELECT emp_name,salary FROM employee</h3><pre><code>or 满足一个就行WHERE salary=3000 OR salary=3500 OR salary=4000 OR salary=9000 ;in 代替了 or语句SELECT emp_name,salary FROM employee     WHERE salary IN (3000,3500,4000,9000) ;不在in集合里面SELECT emp_name,salary FROM employee     WHERE salary NOT IN (3000,3500,4000,9000) ;</code></pre><p>###关键字LIKE模糊查询<br>    通配符’%’ 所有<br>    SELECT * FROM employee<br>            WHERE emp_name LIKE ‘eg%’;</p><pre><code>通配符’_’_ 一个占位一个字符SELECT * FROM employee         WHERE emp_name LIKE &apos;al__&apos;;</code></pre><h1 id="select查询–多表查询"><a href="#select查询–多表查询" class="headerlink" title="select查询–多表查询"></a>select查询–多表查询</h1><h2 id="交叉连接：不适用任何匹配条件。生成笛卡尔积"><a href="#交叉连接：不适用任何匹配条件。生成笛卡尔积" class="headerlink" title="交叉连接：不适用任何匹配条件。生成笛卡尔积"></a>交叉连接：不适用任何匹配条件。生成笛卡尔积</h2><pre><code>select * from 表一, 表2;</code></pre><h2 id="内连接：只连接匹配的行"><a href="#内连接：只连接匹配的行" class="headerlink" title="内连接：只连接匹配的行"></a>内连接：只连接匹配的行</h2><pre><code>主要语法： 表 inner join  表 （建立连接）  on （条件）**employee inner join departmenton employee.dep_id=department.id;  //可换成where employee.dep_id=department.id**select employee.id,employee.name,employee.age,employee.sex,department.namefrom employee inner join departmenton employee.dep_id=department.id;</code></pre><h2 id="外链接之左连接：优先显示左表全部记录"><a href="#外链接之左连接：优先显示左表全部记录" class="headerlink" title="外链接之左连接：优先显示左表全部记录"></a>外链接之左连接：优先显示左表全部记录</h2><pre><code>#以左表为准，即找出所有员工信息，当然包括没有部门的员工#本质就是：在内连接的基础上增加左边有右边没有的结果mysql&gt; select employee.id,employee.name,department.name as depart_name from employee left join department on  #右边没有的选项也匹配， 以左边为准 employee.dep_id=department.id;</code></pre><h2 id="外链接之右连接：优先显示右表全部记录"><a href="#外链接之右连接：优先显示右表全部记录" class="headerlink" title="外链接之右连接：优先显示右表全部记录"></a>外链接之右连接：优先显示右表全部记录</h2><pre><code>和左连接一样 关键字right</code></pre><h2 id="全外连接：显示左右两个表全部记录"><a href="#全外连接：显示左右两个表全部记录" class="headerlink" title="全外连接：显示左右两个表全部记录"></a>全外连接：显示左右两个表全部记录</h2><p>全外连接：在内连接的基础上增加左边有右边没有的和右边有左边没有的结果<br><strong>注意：mysql不支持全外连接 full JOIN</strong><br><strong>强调：mysql可以使用此种方式间接实现全外连接</strong><br>    思路： 查询两个表用union 连接起来<br>    select <em> from employee left join department on employee.dep_id = department.id<br>    union<br>    select </em> from employee right join department on employee.dep_id = department.id</p><h2 id="符合条件连接查询"><a href="#符合条件连接查询" class="headerlink" title="符合条件连接查询"></a>符合条件连接查询</h2><h3 id="内连接的方式查询加入判断条件"><a href="#内连接的方式查询加入判断条件" class="headerlink" title="内连接的方式查询加入判断条件"></a>内连接的方式查询加入判断条件</h3><pre><code>select employee.name,department.name from employee inner join departmenton employee.dep_id = department.idwhere age &gt; 25;</code></pre><h3 id="内连接-asc-升序排列"><a href="#内连接-asc-升序排列" class="headerlink" title="内连接 asc 升序排列"></a>内连接 asc 升序排列</h3><pre><code>select employee.id,employee.name,employee.age,department.name from employee,departmentwhere employee.dep_id = department.idand age &gt; 25order by age asc;</code></pre><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>1：子查询是将一个查询语句嵌套在另一个查询语句中。<br>2：内层查询语句的查询结果，可以为外层查询语句提供查询条件。<br>3：子查询中可以包含：IN、NOT IN、ANY、ALL、EXISTS 和 NOT EXISTS等关键字<br>4：还可以包含比较运算符：= 、 !=、&gt; 、&lt;等</p><h3 id="带IN关键字的子查询"><a href="#带IN关键字的子查询" class="headerlink" title="带IN关键字的子查询"></a>带IN关键字的子查询</h3><pre><code>avg（求平均值） group by 那个组select id, name from department  where id in (select dep_id  from employee group by dep_id having avg(age) &gt; 25);distinct 不同的 结果是查询人数不足一个也就是没有的人的部门select name from department where id not in (select distinct dep_id from employee);</code></pre><h3 id="带比较运算符的子查询"><a href="#带比较运算符的子查询" class="headerlink" title="带比较运算符的子查询"></a>带比较运算符的子查询</h3><p>比较运算符：=、!=、&gt;、&gt;=、&lt;、&lt;=、&lt;&gt;<br>查询大于所有人平均年龄的员工名与年龄</p><pre><code> select name, age from employee where age &gt; (select avg(age) from employee);select t1.name,t1.age from employee    select t1.name,t1.age from employeeinner join(select dep_id,avg(age) avg_age from employee group by dep_id)on t1.dep_id = t2.dep_idwhere t1.age &gt; t2.avg_age; 查询大于部门内平均年龄的员工名、年龄#语法分析： 1.(select dep_id,avg(age) avg_age from employee group by dep_id) 形成一个新表avg_age2.inner join 连接select employee.name,employee.age from employeeinner join (select dep_id,avg(age) avg_age from employee group by dep_id) departmenton employee.dep_id = department.dep_idwhere employee.age &gt; department.avg_age;  </code></pre><h3 id="带EXISTS关键字的子查询"><a href="#带EXISTS关键字的子查询" class="headerlink" title="带EXISTS关键字的子查询"></a>带EXISTS关键字的子查询</h3><p>EXISTS关字键字表示存在。在使用EXISTS关键字时，内层查询语句不返回查询的记录。<br>而是返回一个真假值。True或False<br>当返回True时，外层查询语句将进行查询；当返回值为False时，外层查询语句不进行查询<br>    当子查询为true 显示结果 否则不显示<br>    select * from employee<br>        where exists<br>        (select id from department where id = 200);</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;MySQL数据操作： DML&lt;br&gt;在MySQL管理软件中，可以通过SQL语句中的DML语言来实现数据的操作，包括&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用INSERT实现数据的插入&lt;/li&gt;
&lt;li&gt;UPDATE实现数据的更新&lt;/li&gt;
&lt;li&gt;使用DELETE实现数据的删除&lt;/l
      
    
    </summary>
    
      <category term="mysql" scheme="http://yoursite.com/categories/mysql/"/>
    
    
      <category term="数据操作" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>多表结构的创建与分析</title>
    <link href="http://yoursite.com/2018/10/04/%E5%A4%9A%E8%A1%A8%E7%BB%93%E6%9E%84%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2018/10/04/多表结构的创建与分析/</id>
    <published>2018-10-04T05:34:28.019Z</published>
    <updated>2018-10-04T05:37:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分析步骤："><a href="#分析步骤：" class="headerlink" title="分析步骤："></a>分析步骤：</h1><h2 id="1、先站在左表的角度去找"><a href="#1、先站在左表的角度去找" class="headerlink" title="1、先站在左表的角度去找"></a>1、先站在左表的角度去找</h2><p>是否左表的多条记录可以对应右表的一条记录，如果是，则证明左表的一个字段foreign key 右表一个字段（通常是id）</p><h2 id="2、再站在右表的角度去找"><a href="#2、再站在右表的角度去找" class="headerlink" title="2、再站在右表的角度去找"></a>2、再站在右表的角度去找</h2><p>是否右表的多条记录可以对应左表的一条记录，如果是，则证明右表的一个字段foreign key 左表一个字段（通常是id）</p><h2 id="3、总结："><a href="#3、总结：" class="headerlink" title="3、总结："></a>3、总结：</h2><h3 id="多对一："><a href="#多对一：" class="headerlink" title="多对一："></a>多对一：</h3><p>如果只有步骤1成立，则是左表多对一右表<br>如果只有步骤2成立，则是右表多对一左表</p><p>###多对多<br>如果步骤1和2同时成立，则证明这两张表时一个双向的多对一，即多对多,需要定义一个这两张表的关系表来专门存放二者的关系</p><p>###一对一:<br>如果1和2都不成立，而是左表的一条记录唯一对应右表的一条记录，反之亦然。这种情况很简单，就是在左表foreign key右表的基础上，将左表的外键字段设置成unique即可</p><h1 id="建立表之间的关系"><a href="#建立表之间的关系" class="headerlink" title="建立表之间的关系"></a>建立表之间的关系</h1><h2 id="一对多或称为多对一"><a href="#一对多或称为多对一" class="headerlink" title="一对多或称为多对一"></a>一对多或称为多对一</h2><pre><code>三张表：出版社，作者信息，书一对多（或多对一）：一个出版社可以出版多本书关联方式：foreign key  references 关联标的字段（ press(id)）</code></pre><h3 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h3><h4 id="创建一个表"><a href="#创建一个表" class="headerlink" title="创建一个表"></a>创建一个表</h4><pre><code>create table press( id int primary key auto_increment, name varchar(20) );</code></pre><h4 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h4><pre><code>create table book(    id int primary key auto_increment,    name varchar(20),    press_id int not null,    foreign key(press_id) references press(id)    on delete cascade    on update cascade    );</code></pre><h3 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h3><pre><code>一个表可以关联多个表， 和多个表建立关系</code></pre><p>####代码实例</p><pre><code>#创建一个表create table class(       id int not null primary key auto_increment,    name varchar(20)    );create table course( cid int not null primary key auto_increment, name varchar(20) );#创建多个连接create table student( s_id int not null primary key auto_increment,     name varchar(20), 、class_id int,foreign key(class_id) references class(id) on delete cascade on update cascade ,course_id int,foreign key(course_id) references course(cid)  on delete cascade on update cascade);</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;分析步骤：&quot;&gt;&lt;a href=&quot;#分析步骤：&quot; class=&quot;headerlink&quot; title=&quot;分析步骤：&quot;&gt;&lt;/a&gt;分析步骤：&lt;/h1&gt;&lt;h2 id=&quot;1、先站在左表的角度去找&quot;&gt;&lt;a href=&quot;#1、先站在左表的角度去找&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="mysql" scheme="http://yoursite.com/categories/mysql/"/>
    
    
      <category term="多表" scheme="http://yoursite.com/tags/%E5%A4%9A%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>mysql基础</title>
    <link href="http://yoursite.com/2018/10/04/Mysql/"/>
    <id>http://yoursite.com/2018/10/04/Mysql/</id>
    <published>2018-10-04T04:31:00.000Z</published>
    <updated>2018-10-04T05:38:57.569Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一：数据库在未来的开发的地位"><a href="#一：数据库在未来的开发的地位" class="headerlink" title="一：数据库在未来的开发的地位"></a>一：数据库在未来的开发的地位</h1><pre><code># 后台/后端    # 复杂的代码 隐藏在后端# 前端    # 返回到前端 装饰一下 给别人看# python基础    # 后端程序的开发        # 数据的处理 （增删改查）# 员工信息表、选课系统    # 使用python和文件一起写程序的弊端：        # 结果不好看 需要在控制台、终端控制        # 文件的处理非常繁琐 ：增加 删除# 帮助你 管理 存储了数据的文件    # 更加方便、快速的实现数据的增 删 改 查# python + 数据库（存取数据） + 文件（记录日志）# 结果不好看 需要在控制台、终端控制</code></pre><h1 id="二：数据库中的几个概念"><a href="#二：数据库中的几个概念" class="headerlink" title="二：数据库中的几个概念"></a>二：数据库中的几个概念</h1><h2 id="记录、数据-data"><a href="#记录、数据-data" class="headerlink" title="记录、数据 data"></a>记录、数据 data</h2><pre><code># id,name,passwd,age,number# 1,alex,alex3714,83,13838384438   # 一条记录# 表 table# userinfo    # 一张表就是一个文件# 1,alex,alex3714,83,13838384438# 1,alex,alex3714,83,13838384438# 1,alex,alex3714,83,13838384438</code></pre><h2 id="库-base"><a href="#库-base" class="headerlink" title="库 base"></a>库 base</h2><pre><code># 选课系统     userinfo/studentinfo/courseinfo# 员工信息表   userinfo# ftp          userinfo# mysql这个软件来管理数据# 只有一个mysql来管理你的程序，# 你的程序之间的数据应该是隔离的# 创建两个文件夹 ：选课系统、员工信息表# 所谓数据库中的库 就是文件夹    # 一般情况下 每个程序使用一个库</code></pre><h2 id="数据库管理系统-dbms"><a href="#数据库管理系统-dbms" class="headerlink" title="数据库管理系统 dbms"></a>数据库管理系统 dbms</h2><pre><code># database management system# 能够通过一个软件来管理文件、文件夹、数据# 数据库服务器# 你把你的数据装在哪台机器上 这台机器就是数据库服务器# 关系型数据库和非关系型数据库# 关系型    # 一条数据包含了一个事物的多条信息，这些信息之间是有关联性的# 非关系型  :存取频繁的，并且要求效率高的，不突出数据之间关联的    # k-v    # id content</code></pre><h2 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h2><pre><code># mysql       开源# oracle      企业级# sqlite      轻量级# sql server  大学</code></pre><h2 id="非关系型数据库-：消息转发"><a href="#非关系型数据库-：消息转发" class="headerlink" title="非关系型数据库  ：消息转发"></a>非关系型数据库  ：消息转发</h2><pre><code># memcache# redis# MongoDB# nosql</code></pre><h1 id="数据库的基本操作"><a href="#数据库的基本操作" class="headerlink" title="数据库的基本操作"></a>数据库的基本操作</h1><h2 id="启动server端-可以在service服务中操作"><a href="#启动server端-可以在service服务中操作" class="headerlink" title="启动server端  - 可以在service服务中操作"></a>启动server端  - 可以在service服务中操作</h2><pre><code># (win)&gt;net start mysql</code></pre><h3 id="使用默认用户启动mysql客户端，默认的用户登录-是没有权限查看所有库的"><a href="#使用默认用户启动mysql客户端，默认的用户登录-是没有权限查看所有库的" class="headerlink" title="使用默认用户启动mysql客户端，默认的用户登录 是没有权限查看所有库的"></a>使用默认用户启动mysql客户端，默认的用户登录 是没有权限查看所有库的</h3><pre><code># &gt;mysql 表示启动mysql 客户端# mysql&gt; select user();  # 查看当前登录的用户    # liqinyang@192.168.16.53 # 用户名@ip地址# mysql&gt; show databases; # 查看所有的库# mysql&gt; exit  # 退出当前的客户端</code></pre><h3 id="指定用户登录-root用户-mysql当中权限最高的-管理员用户"><a href="#指定用户登录-root用户-mysql当中权限最高的-管理员用户" class="headerlink" title="指定用户登录 root用户 mysql当中权限最高的 管理员用户"></a>指定用户登录 root用户 mysql当中权限最高的 管理员用户</h3><h4 id="用户名root登录"><a href="#用户名root登录" class="headerlink" title="用户名root登录"></a>用户名root登录</h4><pre><code># &gt; mysql -uroot -p# 初始化没有密码的时候 直接按回车键进入数据库# mysql&gt; select user();</code></pre><h3 id="在输入sql语句的过程中-如果想要放弃本条语句-c"><a href="#在输入sql语句的过程中-如果想要放弃本条语句-c" class="headerlink" title="在输入sql语句的过程中 如果想要放弃本条语句 \c"></a>在输入sql语句的过程中 如果想要放弃本条语句 \c</h3><h4 id="设置密码"><a href="#设置密码" class="headerlink" title="设置密码"></a>设置密码</h4><pre><code># mysql&gt; set password = password(&apos;123&apos;);</code></pre><h4 id="创建用户-create-user"><a href="#创建用户-create-user" class="headerlink" title="创建用户 create user"></a>创建用户 create user</h4><pre><code># create user &apos;alex&apos;@&apos;192.168.16.*&apos; identified by &apos;123&apos;;# create user &apos;eva&apos;@&apos;%&apos; identified by &apos;123&apos;;# &gt; mysql -ueva -p123 -h 192.168.16.39  远程登录一个mysql服务# 新创建出来的用户eva没有使用数据库的权限</code></pre><h4 id="给新用户授权-grant"><a href="#给新用户授权-grant" class="headerlink" title="给新用户授权 grant"></a>给新用户授权 grant</h4><pre><code># grant 操作(select/all) on &apos;库.表&apos; to &apos;用户&apos;@&apos;ip地址&apos;# grant select on &apos;*.*&apos; to &apos;eva&apos;@&apos;%&apos;</code></pre><h4 id="创建用户并授权-grant"><a href="#创建用户并授权-grant" class="headerlink" title="创建用户并授权 grant"></a>创建用户并授权 grant</h4><pre><code># mysql&gt; grant all on *.* to &apos;eva&apos;@&apos;%&apos; identified by &apos;123</code></pre><h4 id="让公司的DBA给你创建用户并且授权"><a href="#让公司的DBA给你创建用户并且授权" class="headerlink" title="让公司的DBA给你创建用户并且授权"></a>让公司的DBA给你创建用户并且授权</h4><pre><code># 用户名 要哪个库的哪些权限</code></pre><h2 id="3-1处理库"><a href="#3-1处理库" class="headerlink" title="3.1处理库"></a>3.1处理库</h2><h3 id="创建库"><a href="#创建库" class="headerlink" title="创建库"></a>创建库</h3><pre><code>create database 数据库名 [charset utf-8];</code></pre><h3 id="查看库"><a href="#查看库" class="headerlink" title="查看库"></a>查看库</h3><pre><code>show databases;</code></pre><h3 id="修改库"><a href="#修改库" class="headerlink" title="修改库"></a>修改库</h3><pre><code>alter database 数据库的名字  你要修改的内容;</code></pre><h3 id="删除库"><a href="#删除库" class="headerlink" title="删除库"></a>删除库</h3><pre><code>drop database 数据库名;</code></pre><h2 id="3-2-处理表"><a href="#3-2-处理表" class="headerlink" title="3.2 处理表"></a>3.2 处理表</h2><h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><h3 id="mysql-gt-create-table-表的名字"><a href="#mysql-gt-create-table-表的名字" class="headerlink" title="mysql&gt; create table 表的名字 ("></a>mysql&gt; create table 表的名字 (</h3><pre><code>                    # 列1的名字 数据类型，                    # 列2的名字 数据类型，                    # ...                    # );create table class(id int not null unique, caption varchar(20)); </code></pre><h4 id="增加表内容"><a href="#增加表内容" class="headerlink" title="增加表内容"></a>增加表内容</h4><pre><code>1：插入单行insert into staff_info (id,name,age,sex,phone,job) values (1,&apos;Alex&apos;,83,&apos;female&apos;,&apos;13651054608&apos;,&apos;IT&apos;);2：插入多行# mysql&gt; insert into staff_info values -&gt; (2,&apos;Egon&apos;,26,&apos;male&apos;,&apos;13304320533&apos;,&apos;Tearcher&apos;), -&gt; (3,&apos;nezha&apos;,25,&apos;male&apos;,&apos;13332353222&apos;,&apos;IT&apos;), -&gt; (4,&apos;boss_jin&apos;,40,&apos;male&apos;,&apos;13332353333&apos;,&apos;IT&apos;);3: 范围测试 有符号和无符号mysql&gt; create table t6 (id1 int(4),id2 int unsigned);mysql&gt; insert into t6 values (123,2147483648);</code></pre><h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><pre><code>1.1查看表结构mysql&gt; desc staff_info;</code></pre><p>   1.2 查询固定表头<br>     select name,age from staff_info;</p><h1 id="三：数据类型"><a href="#三：数据类型" class="headerlink" title="三：数据类型"></a>三：数据类型</h1><h2 id="时间类型"><a href="#时间类型" class="headerlink" title="时间类型"></a>时间类型</h2><h3 id="date-描述年月日"><a href="#date-描述年月日" class="headerlink" title="date      描述年月日"></a>date      描述年月日</h3><h3 id="datetime-描述年月日时分秒"><a href="#datetime-描述年月日时分秒" class="headerlink" title="datetime  描述年月日时分秒"></a>datetime  描述年月日时分秒</h3><h3 id="timestamp字段默认不为空"><a href="#timestamp字段默认不为空" class="headerlink" title="timestamp字段默认不为空"></a>timestamp字段默认不为空</h3><h3 id="DATETIME、DATE、TIMESTAMP、TIME和YEAR。"><a href="#DATETIME、DATE、TIMESTAMP、TIME和YEAR。" class="headerlink" title="DATETIME、DATE、TIMESTAMP、TIME和YEAR。"></a>DATETIME、DATE、TIMESTAMP、TIME和YEAR。</h3><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="CHAR-0-255字节-定长字符串"><a href="#CHAR-0-255字节-定长字符串" class="headerlink" title="CHAR    0-255字节    定长字符串"></a>CHAR    0-255字节    定长字符串</h3><pre><code>定长 浪费磁盘 存取速度非常快</code></pre><h2 id="VARCHAR-0-65535-字节-变长字符串"><a href="#VARCHAR-0-65535-字节-变长字符串" class="headerlink" title="VARCHAR    0-65535 字节    变长字符串"></a>VARCHAR    0-65535 字节    变长字符串</h2><pre><code>变长 节省磁盘空间 存取速度相对慢char(5)     &apos;  abc&apos;  5   &apos;abcde&apos;  5这一列数据的长度变化小  手机号 身份证号 学号频繁存取、对效率要求高短数据varchar(5)  &apos;3abc&apos;   4   &apos;5abcde&apos; 6这一列的数据长度变化大  name  描述信息对效率要求相对小相对长</code></pre><h2 id="ENUM和SET类型"><a href="#ENUM和SET类型" class="headerlink" title="ENUM和SET类型"></a>ENUM和SET类型</h2><h3 id="ENUM"><a href="#ENUM" class="headerlink" title="ENUM"></a>ENUM</h3><pre><code>大小： 对1-255个成员的枚举需要1个字节存储;对于255-65535个成员，需要2个字节存储;最多允许65535个成员。用途： 单选：选择性别</code></pre><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><pre><code>create table t2 (name char(20),gender enum(&apos;男&apos;, &apos;女&apos;)); 插入gender选项不能插入两个值</code></pre><h3 id="SET"><a href="#SET" class="headerlink" title="SET"></a>SET</h3><pre><code>大小 ：1-8个成员的集合，占1个字节9-16个成员的集合，占2个字节17-24个成员的集合，占3个字节25-32个成员的集合，占4个字节 33-64个成员的集合，占8个字节用途 ：多选：兴趣爱好</code></pre><h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><pre><code>create table t11 (name char(20),hobby set(&apos;抽烟&apos;,&apos;喝酒&apos;,&apos;烫头&apos;,&apos;翻车&apos;));不能插入set 范围外的词 会报错</code></pre><h3 id="表的完整性约束"><a href="#表的完整性约束" class="headerlink" title="表的完整性约束"></a><strong>表的完整性约束</strong></h3><h4 id="not-noll"><a href="#not-noll" class="headerlink" title="not noll"></a>not noll</h4><pre><code>非空约束，指定某列不能为空；create table t12 (id int not null); //若是为空报错</code></pre><h4 id="default"><a href="#default" class="headerlink" title="default"></a>default</h4><pre><code>创建列时可以指定默认值，当插入数据时如果未主动设置，则自动添加默认值create table t13 (id1 int not null,id2 int not null default 222);</code></pre><h4 id="unique"><a href="#unique" class="headerlink" title="unique"></a>unique</h4><h5 id="唯一约束，指定某列或者几列组合不能重复"><a href="#唯一约束，指定某列或者几列组合不能重复" class="headerlink" title="唯一约束，指定某列或者几列组合不能重复"></a>唯一约束，指定某列或者几列组合不能重复</h5><pre><code>create table t3(id int unique, name char(20));插入相同的值会报错</code></pre><h5 id="指定某个属性为唯一"><a href="#指定某个属性为唯一" class="headerlink" title="  指定某个属性为唯一  "></a><strong>  指定某个属性为唯一  </strong></h5><pre><code>create table t4(id int unique, name char(20) unique(name));</code></pre><h5 id="not-null-和-unique-联合"><a href="#not-null-和-unique-联合" class="headerlink" title="not null 和 unique 联合"></a>not null 和 unique 联合</h5><pre><code>create table t1(id int not null unique);</code></pre><h4 id="指定多键联合"><a href="#指定多键联合" class="headerlink" title="指定多键联合"></a><strong>指定多键联合</strong></h4><pre><code>create table t5(id int, name char(20), unique(id, name));</code></pre><h4 id="primary-key"><a href="#primary-key" class="headerlink" title="primary key"></a>primary key</h4><h5 id="主键为了保证表中的每一条数据的该字段都是表格中的唯一值"><a href="#主键为了保证表中的每一条数据的该字段都是表格中的唯一值" class="headerlink" title="主键为了保证表中的每一条数据的该字段都是表格中的唯一值"></a>主键为了保证表中的每一条数据的该字段都是表格中的唯一值</h5><h4 id="第一种："><a href="#第一种：" class="headerlink" title="第一种："></a>第一种：</h4><pre><code>not null+unique</code></pre><h4 id="第二种：-primary-key"><a href="#第二种：-primary-key" class="headerlink" title="第二种： primary key"></a>第二种： primary key</h4><pre><code>create table t7(id int primary key,name char(20));</code></pre><h4 id="第三种：在所有字段后单独定义primary-key"><a href="#第三种：在所有字段后单独定义primary-key" class="headerlink" title="第三种：在所有字段后单独定义primary key"></a>第三种：在所有字段后单独定义primary key</h4><pre><code>create table t6(id int,name char(20), primary key(id));</code></pre><h4 id="第四种：给已建成的表添加主键"><a href="#第四种：给已建成的表添加主键" class="headerlink" title="第四种：给已建成的表添加主键"></a>第四种：给已建成的表添加主键</h4><pre><code>alter table department4 modify id int primary key;</code></pre><h4 id="第五种：多字段主键"><a href="#第五种：多字段主键" class="headerlink" title="第五种：多字段主键"></a>第五种：多字段主键</h4><pre><code>create table t8(id int, name char(20), primary key(id, name));</code></pre><h3 id="AUTO-INCREMENT"><a href="#AUTO-INCREMENT" class="headerlink" title="AUTO_INCREMENT"></a>AUTO_INCREMENT</h3><h5 id="约束字段为自动增长，被约束的字段必须同时被key约束"><a href="#约束字段为自动增长，被约束的字段必须同时被key约束" class="headerlink" title="约束字段为自动增长，被约束的字段必须同时被key约束"></a>约束字段为自动增长，被约束的字段必须同时被key约束</h5><h4 id="不指定id，则自动增长，-对于自增的字段，在用delete删除后，再插入值，该字段仍按照删除前的位置继续增长"><a href="#不指定id，则自动增长，-对于自增的字段，在用delete删除后，再插入值，该字段仍按照删除前的位置继续增长" class="headerlink" title="不指定id，则自动增长， 对于自增的字段，在用delete删除后，再插入值，该字段仍按照删除前的位置继续增长"></a>不指定id，则自动增长， 对于自增的字段，在用delete删除后，再插入值，该字段仍按照删除前的位置继续增长</h4><pre><code>create table student(id int primary key auto_increment,    name varchar(20),    sex enum(&apos;male&apos;,&apos;female&apos;) default &apos;male&apos;    );</code></pre><h4 id="foreign-key"><a href="#foreign-key" class="headerlink" title="foreign key"></a>foreign key</h4><h4 id="当设置字段为unique唯一字段时，设置该字段为外键才可以成功"><a href="#当设置字段为unique唯一字段时，设置该字段为外键才可以成功" class="headerlink" title="当设置字段为unique唯一字段时，设置该字段为外键才可以成功"></a>当设置字段为unique唯一字段时，设置该字段为外键才可以成功</h4><h4 id="设置外键"><a href="#设置外键" class="headerlink" title="设置外键"></a>设置外键</h4><pre><code>create table staff_info (s_id int,    name varchar(20),    dep_id int,    foreign key(dep_id) references departments(dep_id)); #departments(dep_id)) 外表ID</code></pre><h4 id="给予表权限，-外表删除，本表也跟新"><a href="#给予表权限，-外表删除，本表也跟新" class="headerlink" title="给予表权限， 外表删除，本表也跟新"></a>给予表权限， 外表删除，本表也跟新</h4><pre><code>on delete cascade  # 连级删除on update cascade # 连级更新</code></pre><h1 id="表简单增删改查"><a href="#表简单增删改查" class="headerlink" title="表简单增删改查"></a>表简单增删改查</h1><h2 id="表的查看"><a href="#表的查看" class="headerlink" title="表的查看"></a>表的查看</h2><h3 id="describe-staff-info"><a href="#describe-staff-info" class="headerlink" title="describe staff_info;"></a>describe staff_info;</h3><pre><code>查看表结构</code></pre><h3 id="desc-staff-info"><a href="#desc-staff-info" class="headerlink" title="desc staff_info;"></a>desc staff_info;</h3><pre><code>查看表结构</code></pre><h3 id="show-create-table-staff-info-G"><a href="#show-create-table-staff-info-G" class="headerlink" title="show create table staff_info\G;"></a>show create table staff_info\G;</h3><pre><code>查看表结构</code></pre><h2 id="修改表结构"><a href="#修改表结构" class="headerlink" title="修改表结构"></a>修改表结构</h2><h3 id="修改表名字"><a href="#修改表名字" class="headerlink" title="修改表名字"></a>修改表名字</h3><pre><code>alter table t1 rename t4_1;//alter table (修改的表) rename （新的表名字）；</code></pre><h3 id="增加字段"><a href="#增加字段" class="headerlink" title="增加字段"></a>增加字段</h3><pre><code>alter table t4_1 add age int, add sex char(3);//alter table t4_1 add (字段的属性), add (字段属性);</code></pre><h3 id="删除字段"><a href="#删除字段" class="headerlink" title="删除字段"></a>删除字段</h3><pre><code>alter table t4_1 drop sex;//alter table （操作的表） drop （字段名字）;</code></pre><h3 id="修改字段"><a href="#修改字段" class="headerlink" title="修改字段"></a>修改字段</h3><pre><code>alter table t4_1 modiey name char(20) not null;//alter table (表名字) modiey （字段） （数据类型） （约束条件）;#修改字段的名字alter table t4_1 change name myname int not null;//alter table 表名 change 原表名字 新的名字 数据类型 约束条件;</code></pre><h3 id="修改字段排列顺序-在增加的时候指定字段位置"><a href="#修改字段排列顺序-在增加的时候指定字段位置" class="headerlink" title="修改字段排列顺序/在增加的时候指定字段位置"></a>修改字段排列顺序/在增加的时候指定字段位置</h3><h4 id="给表首位字段插入一个"><a href="#给表首位字段插入一个" class="headerlink" title="给表首位字段插入一个"></a>给表首位字段插入一个</h4><pre><code>alter table t4_1 add key_id int not null first;//alter table 表 add 新的字段 数据类型 约束条件 first; #first代表首位</code></pre><h3 id="给表固定位字段插入一个"><a href="#给表固定位字段插入一个" class="headerlink" title="给表固定位字段插入一个"></a>给表固定位字段插入一个</h3><pre><code>alter table t4_1 add key_id int not null after id;//alter table 表 add 新的字段 数据类型 约束条件 after; #after 在那个字段之后</code></pre><h3 id="修改字段名，-并且移动到固定位置"><a href="#修改字段名，-并且移动到固定位置" class="headerlink" title="修改字段名， 并且移动到固定位置"></a>修改字段名， 并且移动到固定位置</h3><pre><code>alter table t4_1 change id_new id_n int first;alter table t4_1 change id_n id_new int after id; #那个字段后面//alter table 表名 change 要修改的字段 新的字段 数据类型 约束条件 first; </code></pre><h3 id="修改字段的位置"><a href="#修改字段的位置" class="headerlink" title="修改字段的位置"></a>修改字段的位置</h3><pre><code>alter table t4_1 modify  age int  after id;//alter table 表名 modify  字段名 属性 after 字段名;</code></pre><h2 id="表的删除"><a href="#表的删除" class="headerlink" title="表的删除"></a>表的删除</h2><pre><code>drop table t4_1;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一：数据库在未来的开发的地位&quot;&gt;&lt;a href=&quot;#一：数据库在未来的开发的地位&quot; class=&quot;headerlink&quot; title=&quot;一：数据库在未来的开发的地位&quot;&gt;&lt;/a&gt;一：数据库在未来的开发的地位&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;# 后台/后端
    # 
      
    
    </summary>
    
      <category term="mysql" scheme="http://yoursite.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>明天会更好</title>
    <link href="http://yoursite.com/2018/10/03/%E5%8A%AA%E5%8A%9B%E5%89%8D%E8%A1%8C/"/>
    <id>http://yoursite.com/2018/10/03/努力前行/</id>
    <published>2018-10-03T13:37:18.000Z</published>
    <updated>2018-10-03T14:08:41.807Z</updated>
    
    <content type="html"><![CDATA[<p>#分析自身现状<br>  最近一直以来状态不太好， 感觉学习没有刚开始学习的时候好了。最要表现在一下几个方面</p><p>1.学习热度没有开始学习的时候好<br>2.学习效率低，分心程序高，不够专注<br>3.个人作息有严重的问题<br>4.上课不注意听讲， 下课总结不到位<br>5.今后的问题应该是多注意总结学习新的知识</p><p>#个人问题<br>一直以来都很胖， 也健过身最后也有好的效果。但是过后又恢复一前模样，总结原因是没有坚持。成功路上的多数难题是不够坚持，这是我发现自身的问题的根本所在。固然懒惰是人的天性， 一直以来自己都想改变自己，我考虑良久想从跑步做起，培养自己的意志力。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#分析自身现状&lt;br&gt;  最近一直以来状态不太好， 感觉学习没有刚开始学习的时候好了。最要表现在一下几个方面&lt;/p&gt;
&lt;p&gt;1.学习热度没有开始学习的时候好&lt;br&gt;2.学习效率低，分心程序高，不够专注&lt;br&gt;3.个人作息有严重的问题&lt;br&gt;4.上课不注意听讲， 下课总结不到
      
    
    </summary>
    
      <category term="个人感想" scheme="http://yoursite.com/categories/%E4%B8%AA%E4%BA%BA%E6%84%9F%E6%83%B3/"/>
    
    
      <category term="珍惜" scheme="http://yoursite.com/tags/%E7%8F%8D%E6%83%9C/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2018/10/02/hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2018/10/02/hexo个人博客搭建整理/</id>
    <published>2018-10-02T13:07:50.989Z</published>
    <updated>2018-10-02T13:56:46.704Z</updated>
    
    <content type="html"><![CDATA[<p>#一什么是 Hexo？<br>    官方解释说Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。<br>    也就是说Hexo是一款能够帮助我们快速构建博客的轻型框架。但是如何使用Hexo呢？<br>    如标题所言，我们是结合GitHub来使用Hexo,因此在创建博客的过程中我们就可以分成两个部分，GitHub准备工作和Hexo搭建工作<br><strong>注：实例运行环境为Windos,教程较为浅显，读者可根据个人实际情况选择性阅读该教程</strong></p><p>##安装主要配置软件<br>1： Node.js :<a href="http://nodejs.cn/download/" title="Node.js" target="_blank" rel="noopener">http://nodejs.cn/download/</a></p><p>2：Git（前往下载）<a href="https://git-scm.com/downloads" title="Git（前往下载）" target="_blank" rel="noopener">https://git-scm.com/downloads</a></p><ol start="3"><li>安装hexo看到这么多安装，千万不要紧张，一定要稳住，别怕，因为后面的东西都是在gitbash中用npm工具安装就好了。先创建一个文件（用来存放所有blog的东西），然后cd到该文件夹下。</li><li>安装hexo命令：npm i -g hexo安装完成后，查看版本：<br> <img src="https://i.imgur.com/FoaoPPl.png" alt=""></li></ol><pre><code>* 解释一下：node_modules：是依赖包        * public：存放的是生成的页面        * scaffolds：命令生成文章等的模板        * source：用命令创建的各种文章        * themes：主题        * _config.yml：整个博客的配置        * db.json：source解析所得到的        * package.json：项目所需模块项目的配置信息</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#一什么是 Hexo？&lt;br&gt;    官方解释说Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。&lt;br&gt;    也就是说Hexo是一款能够帮助我们快速构建博客的轻型框架。但是如
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>操作系统和进程的基础概念</title>
    <link href="http://yoursite.com/2018/10/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <id>http://yoursite.com/2018/10/02/操作系统与进程的基础概念/</id>
    <published>2018-10-02T04:24:39.008Z</published>
    <updated>2018-10-03T10:33:57.030Z</updated>
    
    <content type="html"><![CDATA[<p>#操作系统的发展史</p><p>##手工操作 —— 穿孔卡片      </p><p>###手工操作的两个特点：<br>    1：用户独占全机， 不会出现因资源一杯其他用户占用而等待的现象， 但是资源利用率低<br>    2：cup等待手工操作。 CPU的利用不充分</p><p>##批处理 —— 磁带存储和批处理系统、</p><p>###批处理系统：加载在计算机上的一个系统软件， 在他的控制下， 计算机能够自动的， 成批地处理有个或者多个用户的作业</p><p>###卫星机：<br>    一台不与主机直接相连而用于输出输入设备打交道<br>    其功能：<br>        1：输入机上读取用户作业并放到磁带上<br>        2：从输入磁带上读取执行结果给打印机<br>    不足：每次主机内存中仅存放到一道作业， 每当它运行期间输入、输出请求后， 高速的CPU变处于等待低速的IO完成状态致使CPU空闲</p><p>##多道程序系统<br><img src="https://i.imgur.com/DU9G0m7.png" alt=""></p><p>###所谓的多道程序设计技术， 就是指允许多个程序进入内存并允许。 即把多个程序放入内存。他们在内存中交替运行。共享系统资源。一道程序运行结束立马转向去另一个。</p><p>###单机处理系统中的多道程序运行的特点：<br>    1：多道：计算机内部放入多道程序<br>    2:宏观上的并行： 同时进入系统的几道程序都处于运行过程中，都开始运行，但都为运行完毕<br>    3：微观上串性：各道程序轮流的用CPU， 交替运行</p><p>##多道批处理系统</p><p>##分时系统</p><p>##实时系统</p><p>##通用操作系统</p><p>##操作系统的进一步发展</p><p>##操作系统的作用</p><p>I/O ：input 进入内存的过程就是输入<br>    ：ouput 数据从内存从内存出去的过程就是输出 （写文件， dump， send）</p><p>##多道操作系统<br>    可以有多个程序在操作系统中执行<br>    当一个程序遇到IO操作时候就把CPU让出来给其他程序</p><p>###分时操作系统</p><pre><code>#时间片 特别短的时间#不是遇到IO的时候才让出CPU， 而是时间到了就将CPU让出来#切换要占时间：单纯的分时系统没有提高CPU的利用率                提高了用户体验</code></pre><p>###实时系统</p><p>###个人计算机<br>    python celery 分布式计算</p><p>##进程 Process id = pid<br>程序  进程<br>pid 是全系统</p><p>进程是操作系统最小的资源分配单位</p><p>资源分配  — 内存 寄存器</p><p>多级反馈附列<br>    先把短的执行， 长任务放到队列下面</p><p>同步阻塞： 不能充分利用CPU<br>异步非阻塞： 过度利用CPU</p><p>IO多路复用：比较完善的在网络编程中的解决方案</p><h2 id="if-name-‘name‘"><a href="#if-name-‘name‘" class="headerlink" title="if name == ‘name‘:"></a>if <strong>name</strong> == ‘<strong>name</strong>‘:</h2><pre><code>只有在winds上才需要</code></pre><p>1：父进程和子进程的启动时异步的<br>父进程只负责通知操作系统启动子进程<br>接下来的工作由操作系统接手，父进程继续执行<br>2：父进程执行完毕后并不会直接结束程序<br>而是等待所有的子进程都执行完毕后才结束<br>父进程要负责回收子进程的资源</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#操作系统的发展史&lt;/p&gt;
&lt;p&gt;##手工操作 —— 穿孔卡片      &lt;/p&gt;
&lt;p&gt;###手工操作的两个特点：&lt;br&gt;    1：用户独占全机， 不会出现因资源一杯其他用户占用而等待的现象， 但是资源利用率低&lt;br&gt;    2：cup等待手工操作。 CPU的利用不充分
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>socke</title>
    <link href="http://yoursite.com/2018/10/02/socket/"/>
    <id>http://yoursite.com/2018/10/02/socket/</id>
    <published>2018-10-02T04:24:38.992Z</published>
    <updated>2018-10-03T10:33:43.888Z</updated>
    
    <content type="html"><![CDATA[<p>#1：网络编程之socketserver</p><p>###1:首先socketserver 服务器调用socketserver 模块</p><p>###2:继承了socketserver.BaseRequestHandler</p><p>###3:在父类的基础上重写了handle</p><p>##下面是一个简单的文件登录文件上传的例子</p><p>###server端<br>    import socketserver<br>    import json<br>    import struct<br>    import socket</p><pre><code>class MyTCPHandler(socketserver.BaseRequestHandler):def handle(self):    flag = self.login_check()    while flag:        try:            self.data = self.request.recv(1024).strip()            print(&apos;{} wrote&apos;.format(self.client_address[0]))            print(self.data)            self.request.send(self.data.upper())            print(self.data.decode(&apos;utf-8&apos;))            if self.data.decode(&apos;utf-8&apos;) == &apos;2&apos;:                self.uploading()        except ConnectionResetError as e:            print(&apos;error&apos;, e)            breakdef login_check(self):    dic_user = {        &apos;name&apos;: &apos;qwer&apos;,        &apos;pwad&apos;: &apos;1234&apos;    }    dic_clinet = self.request.recv(1024).strip()    dic_clinet = json.loads(dic_clinet)    print(dic_clinet)    if dic_user[&apos;name&apos;] == dic_clinet[&apos;name&apos;] and \            dic_user[&apos;pwad&apos;] == dic_clinet[&apos;pwad&apos;]:        self.request.send(b&apos;True&apos;)        return Truedef uploading(self):    &apos;&apos;&apos;接受上传文件&apos;&apos;&apos;    ret = self.request.recv(1024)    dic_client = json.loads(ret)    print(dic_client)    self.request.send(b&apos;Start To upload&apos;)    print(&apos;Start the download&apos;)    size = dic_client[&apos;size&apos;]    with open(dic_client[&apos;filename&apos;],&apos;wb&apos;) as f:        while size:            ret = self.request.recv(1024)            f.write(ret)            size -= len(ret)    print(&apos;下载完毕！&apos;)if __name__ == &apos;__main__&apos;:    Host, port = &apos;127.0.0.1&apos;, 9999    # sever = socketserver.TCPServer((Host, port), MyTCPHandler)    sever = socketserver.ThreadingTCPServer((Host, port), MyTCPHandler)    sever.serve_forever()</code></pre><p>###client端</p><pre><code>import socketimport jsonimport osimport sysimport time#进度条import timefrom tqdm import tqdm# for i in tqdm(range(100)):#     time.sleep(0.05)def processBar(num, total):    rate = num / total    rate_num = int(rate * 100)    if rate_num == 100:        r = &apos;\r%s&gt;%d%%\n&apos; % (&apos;|&apos; * rate_num, rate_num,)    else:        r = &apos;\r%s&gt;%d%%&apos; % (&apos;|&apos; * rate_num, rate_num,)    sys.stdout.write(r)    sys.stdout.flushclass Client():    &apos;&apos;&apos;客户端&apos;&apos;&apos;    cmd_list = [        (&apos;下载文件&apos;, &apos;ncftpget&apos;),        (&apos;上传文件&apos;, &apos;upload&apos;),        (&apos;切换目录&apos;, &apos;chdir&apos;),        (&apos;创建目录&apos;, &apos;create_directory&apos;),        (&apos;删除文件或者目录&apos;,&apos;expurgate &apos;),    ]    def __init__(self):        self.client = socket.socket() #实例socket对象    def connect(self, ip, port):        &apos;&apos;&apos;绑定端口&apos;&apos;&apos;        self.client.connect((ip, port))    def logon(self):        &apos;&apos;&apos;用户登录&apos;&apos;&apos;        name = input(&apos;user_name:&apos;)        pawd = input(&apos;passwork:&apos;)        user_dic = {            &apos;name&apos;: name,            &apos;pwad&apos;: pawd        }        self.client.send(json.dumps(user_dic).encode(&apos;utf-8&apos;))        ret = self.client.recv(1024).decode(&apos;utf-8&apos;)        print(ret)        return ret    def User_input(self):        flag = self.logon()        name_path = &apos;/home/&apos;        while flag:            for index, val in enumerate(self.cmd_list, 1):                print(&apos;%s  %s&apos;%(index, val[0]))            inp = input(&apos;%s:&apos;%name_path)            self.client.send(inp.encode(&apos;utf-8&apos;))            ret = self.client.recv(1024).decode(&apos;utf-8&apos;)            if inp == &apos;2&apos;:                self.upload()        else:            print(&apos;密码错误！&apos;)    def ncftpget(self):        &apos;&apos;&apos;下载文件&apos;&apos;&apos;    def upload(self):        &apos;&apos;&apos;上传文件&apos;&apos;&apos;        path_name = r&apos;G:\python笔记\Pythonjing\day18\video\01 深圳校区 python fullstuck 1期 day18 内容回顾.mp4&apos;        size = os.path.getsize(path_name)        print(size)        total = size        dic_user = {            &apos;means&apos;: &apos;uploading&apos;,            &apos;filename&apos;: &apos;test.mp4&apos;,            &apos;size&apos;: size,        }        self.client.send(json.dumps(dic_user).encode(&apos;utf-8&apos;))        ret = self.client.recv(1024)        print(ret)        with open(path_name, &apos;rb&apos;) as f:            count = 0            time_old = time.clock()            pbar = tqdm(total=size)            while size:                data = f.read(1024)                self.client.send(data)                size -= len(data)                count += len(data)                pbar.update(len(data)) #进度条                # processBar(count, total) #进度条            time_new = time.clock()            pbar.close()            print(&apos;上传完毕！一个用时%s秒&apos;%int(time_new - time_old))    def chdir(self):        &apos;&apos;&apos;切换目录&apos;&apos;&apos;    def create_directory(self):        &apos;&apos;&apos;创建目录&apos;&apos;&apos;    def expurgate(self):        &apos;&apos;&apos;删除文件或者文件夹&apos;&apos;&apos;if __name__ == &apos;__main__&apos;:    # Host, port = &apos;127.0.0.1&apos;, 9999    Host, port = &apos;192.168.16.46&apos;, 9999    cl = Client()    cl.connect(Host, port)    cl.User_input()</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#1：网络编程之socketserver&lt;/p&gt;
&lt;p&gt;###1:首先socketserver 服务器调用socketserver 模块&lt;/p&gt;
&lt;p&gt;###2:继承了socketserver.BaseRequestHandler&lt;/p&gt;
&lt;p&gt;###3:在父类的基础上重写
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>multiprocessing模块</title>
    <link href="http://yoursite.com/2018/10/02/multiprocess%E8%BF%9B%E7%A8%8B-%E9%94%81-%E4%BF%A1%E5%8F%B7%E9%87%8F-%E4%BA%8B%E4%BB%B6/"/>
    <id>http://yoursite.com/2018/10/02/multiprocess进程-锁-信号量-事件/</id>
    <published>2018-10-02T04:24:38.979Z</published>
    <updated>2018-10-03T10:32:42.931Z</updated>
    
    <content type="html"><![CDATA[<p>##1.1：process模块介绍</p><p>###具体方法<br>    p.start()：启动进程，并调用该子进程中的p.run()<br>    p.run():进程启动时运行的方法，正是它去调用target指定的函数，我们自定义类的类中一定要实现该方法<br>    p.terminate():强制终止进程p，不会进行任何清理操作，如果p创建了子进程，该子进程就成<br>    了僵尸进程，使用该方法需要特别小心这种情况。如果p还保存了一个锁那么也将不会被释放，进而导致死锁<br>    p.is_alive():如果p仍然运行，返回True<br>    p.join([timeout]):主线程等待p终止（强调：是主线程处于等的状态，而p是处于运行的状态）。<br>    timeout是可选的超时时间，需要强调的是，p.join只能join住start开启的进程，而不能join住run开启的进程  </p><p>###具体实现<br>    p.daemon：默认值为False，如果设为True，代表p为后台运行的守护进程，当p的父进程终止时，p也随之终止，并且设定为True后，p不能创建自己的新进程，必须在p.start()之前设置<br>    p.name:进程的名称<br>    p.pid：进程的pid<br>    p.exitcode:进程在运行时为None、如果为–N，表示被信号N结束(了解即可)<br>    p.authkey:进程的身份验证键,默认是由os.urandom()随机生成的32字符的字符串。这个键的用途是为涉及网络连接的底层进程间通信提供安全性，这类连接只有在具有相同的身份验证键时才能成功（了解即可）</p><p>###具体代码<br>    import os<br>    from multiprocessing import Process</p><pre><code>def f(x):    print(&apos;子进程id ：&apos;,os.getpid(),&apos;父进程id ：&apos;,os.getppid())    #查看主进程和子进程的进程号    return x*xif __name__ == &apos;__main__&apos;:    print(&apos;主进程id ：&apos;, os.getpid())    p_lst = []    for i in range(5):        p = Process(target=f, args=(i,))        p.start()</code></pre><p>##1.2：守护进程</p><pre><code>会随着主进程的结束而结束。主进程创建守护进程　　其一：守护进程会在主进程代码执行结束后就终止　　其二：守护进程内无法再开启子进程,否则抛出异常：AssertionError: daemonic processes are not allowed to have children注意：进程之间是互相独立的，主进程代码运行结束，守护进程随即终止</code></pre><p>###具体代码<br>    from multiprocessing import Process<br>    import time<br>    def fun():<br>        while 1:<br>            print(‘守护进程’)<br>            time.sleep(1)<br>    if <strong>name</strong> == ‘<strong>main</strong>‘:<br>        p = Process(target= fun)<br>        p.daemon = True<br>        p.start()<br>        time.sleep(5) #主进程结束守护进程结束</p><p>##1.3：multiprocess.Lock</p><pre><code>#加锁可以保证多个进程修改同一块数据时，同一时间只能有一个任务可以进行修改，即串行的修改，没错，速度是慢了，但牺牲了速度却保证了数据安全。虽然可以用文件共享数据实现进程间通信，但问题是：1.效率低（共享数据基于文件，而文件是硬盘上的数据）2.需要自己加锁处理#因此我们最好找寻一种解决方案能够兼顾：1、效率高（多个进程共享一块内存的数据）2，我们处理好锁问题。这就是mutiprocessing模块为我们提供的基于消息的IPC通信机制：队列和管道。队列和管道都是将数据存放于内存中队列又是基于（管道+锁）实现的，可以让我们从复杂的锁问题中解脱出来，我们应该尽量避免使用共享数据，尽可能使用消息传递和队列，避免处理复杂的同步和锁问题，而且在进程数目增多时，往往可以获得更好的可获展性。</code></pre><p>###抢票的例子</p><pre><code>#文件db的内容为：{&quot;count&quot;:1}#注意一定要用双引号，不然json无法识别#并发运行，效率高，但竞争写同一文件，数据写入错乱from multiprocessing import Process,Lockimport time,json,randomdef search():    dic=json.load(open(&apos;db&apos;))    print(&apos;\033[43m剩余票数%s\033[0m&apos; %dic[&apos;count&apos;])def get():    dic=json.load(open(&apos;db&apos;))    time.sleep(0.1) #模拟读数据的网络延迟    if dic[&apos;count&apos;] &gt;0:        dic[&apos;count&apos;]-=1        time.sleep(0.2) #模拟写数据的网络延迟        json.dump(dic,open(&apos;db&apos;,&apos;w&apos;))        print(&apos;\033[43m购票成功\033[0m&apos;)def task():    search()    get()if __name__ == &apos;__main__&apos;:    for i in range(100): #模拟并发100个客户端抢票        p=Process(target=task)        p.start()</code></pre><p>##multiprocess.Semaphore<br>    斥锁同时只允许一个线程更改数据，而信号量Semaphore是同时允许一定数量的线程更改数据 。<br>    假设商场里有4个迷你唱吧，所以同时可以进去4个人，如果来了第五个人就要在外面等待，等到有人出来才能再进去玩。<br>    实现：<br>    信号量同步基于内部计数器，每调用一次acquire()，计数器减1；每调用一次release()，计数器加1.<br>    当计数器为0时，acquire()调用被阻塞。这是迪科斯彻（Dijkstra）信号量概念P()和V()Python实现。信号量同步机制适用于访问像服务器这样的有限资源。<br>    信号量与进程池的概念很像，但是要区分开，信号量涉及到加锁的概念</p><p>###具体例子（进KTV）<br>    from multiprocessing import Process,Semaphore<br>    import time,random</p><pre><code>def go_ktv(sem,user):    sem.acquire()    print(&apos;%s 占到一间ktv小屋&apos; %user)    time.sleep(random.randint(0,3)) #模拟每个人在ktv中待的时间不同    sem.release()if __name__ == &apos;__main__&apos;:    sem=Semaphore(4)    p_l=[]    for i in range(13):        p=Process(target=go_ktv,args=(sem,&apos;user%s&apos; %i,))        p.start()        p_l.append(p)    for i in p_l:        i.join()    print(&apos;============》&apos;)</code></pre><p>##multiprocess.Event</p><p>###介绍<br>    python线程的事件用于主线程控制其他线程的执行，事件主要提供了三个方法 set、wait、clear。</p><pre><code>事件处理的机制：全局定义了一个“Flag”，如果“Flag”值为 False，那么当程序执行 event.wait 方法时就会阻塞，如果“Flag”值为True，那么event.wait 方法时便不再阻塞。clear：将“Flag”设置为Falseset：将“Flag”设置为True</code></pre><p>###红绿灯例子<br>    import time<br>    import random<br>    from multiprocessing import Process,Event<br>    def traffic_light(e):<br>        print(‘\033[31m红灯亮\033[0m’)<br>        while True:<br>            if e.is_set():<br>                time.sleep(2)<br>                print(‘\033[31m红灯亮\033[0m’)<br>                e.clear()<br>            else:<br>                time.sleep(2)<br>                print(‘\033[32m绿灯亮\033[0m’)<br>                e.set()</p><pre><code>def car(e,i):    if not e.is_set():        print(&apos;car %s 在等待&apos; % i)        e.wait()    print(&apos;car %s 通过了&apos;%i)if __name__ == &apos;__main__&apos;:    e = Event()    p = Process(target=traffic_light,args=(e,))    p.daemon = True    p.start()    p_lst = []    for i in  range(20):        time.sleep(random.randrange(0,3,2))        p = Process(target=car,args=(e,i))        p.start()  # car19        p_lst.append(p)    for p in p_lst:p.join()</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##1.1：process模块介绍&lt;/p&gt;
&lt;p&gt;###具体方法&lt;br&gt;    p.start()：启动进程，并调用该子进程中的p.run()&lt;br&gt;    p.run():进程启动时运行的方法，正是它去调用target指定的函数，我们自定义类的类中一定要实现该方法&lt;br&gt;
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>multiprocess进程-锁-信号量-事件</title>
    <link href="http://yoursite.com/2018/10/02/multiprocessing%E6%A8%A1%E5%9D%97/"/>
    <id>http://yoursite.com/2018/10/02/multiprocessing模块/</id>
    <published>2018-10-02T04:24:38.971Z</published>
    <updated>2018-10-03T10:32:34.045Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建共享的进程队列，Queue是多进程安全的队列，可以使用Queue实现多进程之间的数据传递。"><a href="#创建共享的进程队列，Queue是多进程安全的队列，可以使用Queue实现多进程之间的数据传递。" class="headerlink" title="创建共享的进程队列，Queue是多进程安全的队列，可以使用Queue实现多进程之间的数据传递。"></a>创建共享的进程队列，Queue是多进程安全的队列，可以使用Queue实现多进程之间的数据传递。</h2><pre><code>Queue([maxsize]) 创建共享的进程队列。maxsize是队列中允许的最大项数。如果省略此参数，则无大小限制。底层队列使用管道和锁定实现。另外，还需要运行支持线程以便队列中的数据传输到底层管道中。 Queue的实例q具有以下方法：q.get( [ block [ ,timeout ] ] ) 返回q中的一个项目。如果q为空，此方法将阻塞，直到队列中有项目可用为止。block用于控制阻塞行为，默认为True. 如果设置为False，将引发Queue.Empty异常（定义在Queue模块中）。timeout是可选超时时间，用在阻塞模式中。如果在制定的时间间隔内没有项目变为可用，将引发Queue.Empty异常。q.get_nowait( ) 同q.get(False)方法。q.put(item [, block [,timeout ] ] ) 将item放入队列。如果队列已满，此方法将阻塞至有空间可用为止。block控制阻塞行为，默认为True。如果设置为False，将引发Queue.Empty异常（定义在Queue库模块中）。timeout指定在阻塞模式中等待可用空间的时间长短。超时后将引发Queue.Full异常。q.qsize() 返回队列中目前项目的正确数量。此函数的结果并不可靠，因为在返回结果和在稍后程序中使用结果之间，队列中可能添加或删除了项目。在某些系统上，此方法可能引发NotImplementedError异常。q.empty() 如果调用此方法时 q为空，返回True。如果其他进程或线程正在往队列中添加项目，结果不可靠的。也就是说，在返回和使用结果之间，队列中可能已经加入新的项目。q.full() 如果q已满，返回为True. 由于线程的存在，结果也可能是不可靠的（参考q.empty（）方法）。。方法介绍</code></pre><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><pre><code>from multiprocessing import Process, Queueimport timedef fun(q):    print(&apos;my name is li&apos;)    q.put([&apos;lei&apos;, 1, 2, 3, 4])if __name__ == &apos;__main__&apos;:    q = Queue()    p = Process(target=fun, args=(q,))    p.start()    time.sleep(1)    print(q.get())</code></pre><h2 id="队里问题，-消费者生产模型"><a href="#队里问题，-消费者生产模型" class="headerlink" title="队里问题， 消费者生产模型"></a>队里问题， 消费者生产模型</h2><pre><code>from multiprocessing import Process, Queueimport timedef producer(q, name, food):    for i in range(10):        time.sleep(0.0005)        print(&apos;%s生产了%s%s&apos; % (name, food,i))        q.put(food + str(i))def consume(q, name):    while 1:        food = q.get()        if food is None:break        print(&apos;%s吃了%s&apos;%(name, food))if __name__ == &apos;__main__&apos;:    q = Queue()    p1 = Process(target=producer, args=(q,&apos;li&apos;,&apos;包子&apos;))    p1.start()    p2 = Process(target=consume, args=(q,&apos;alex&apos;))    p2.daemon = True    p2.start()    p1.join() #等p1的原因是先让生产完，防止生产来不及队列里面为空    q.put(None)</code></pre><p>#<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></p><p>##JoinableQueue 类</p><p>###put</p><p>###get</p><p>###task_done 通知队列已经有一个数据被处理了</p><p>###q.join() # 阻塞直到放入队列中所有的数据都被处理掉(有多少个数据就接收到了多少taskdone)</p><pre><code>import timeimport randomfrom multiprocessing import Process,JoinableQueuedef consumer(q,name):    #处理数据    while 1:        food = q.get()        time.sleep(random.uniform(0, 1))        print(&apos;%s吃了%s&apos;%(name, food))        q.task_done()def producer(q, name, food):    for i in range(10):        time.sleep(random.uniform(0,1))        print(&quot;%s生产了%s%s&quot;%(name, food, i))        q.put(food + str(i))if __name__ == &apos;__main__&apos;:    q = JoinableQueue()    c1 = Process(target=consumer, args=(q, &apos;lei&apos;))    c1.daemon = True #创建了一个守护进程    c1.start()    p1 = Process(target=producer, args=(q, &apos;wuyan&apos;, &apos;煎饼&apos;))    p1.start()    p1.join() #等待生产完毕， 保证了队列里面有全部的数据    q.join() #每次取出数据调用 q.task_done() 当为数据取玩阻塞消失</code></pre><p>#<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></p><h2 id="pipe的端口管理不会随着某一个进程的关闭就关闭"><a href="#pipe的端口管理不会随着某一个进程的关闭就关闭" class="headerlink" title="pipe的端口管理不会随着某一个进程的关闭就关闭"></a>pipe的端口管理不会随着某一个进程的关闭就关闭</h2><h3 id="操作系统来管理进程对这些端口的使用"><a href="#操作系统来管理进程对这些端口的使用" class="headerlink" title="操作系统来管理进程对这些端口的使用"></a>操作系统来管理进程对这些端口的使用</h3><h3 id="left-right"><a href="#left-right" class="headerlink" title="left,right"></a>left,right</h3><h3 id="left-right-1"><a href="#left-right-1" class="headerlink" title="left,right"></a>left,right</h3><h3 id="操作系统管理4个端口-每关闭一个端口计数-1，直到所有的端口都关闭了，"><a href="#操作系统管理4个端口-每关闭一个端口计数-1，直到所有的端口都关闭了，" class="headerlink" title="操作系统管理4个端口  每关闭一个端口计数-1，直到所有的端口都关闭了，"></a>操作系统管理4个端口  每关闭一个端口计数-1，直到所有的端口都关闭了，</h3><h3 id="剩余1个端口的时候-recv就会报错"><a href="#剩余1个端口的时候-recv就会报错" class="headerlink" title="剩余1个端口的时候 recv就会报错"></a>剩余1个端口的时候 recv就会报错</h3><pre><code>from multiprocessing import Pipe, Processdef pipeline(left, right):    ret = right.recv() #右边接受    print(&apos;%s&apos;%(ret))if __name__ == &apos;__main__&apos;:    left, right = Pipe()    p = Process(target=pipeline, args=(left, right))    left.send(&apos;你好，保重&apos;) #左边发送    p.start()def pipeline(left, right):    left.close()    while 1:        try:            print(right.recv())        except EOFError:            breakif __name__ == &apos;__main__&apos;:    left, right = Pipe()    p = Process(target=pipeline, args=(left, right))    p.start()    right.close()    for i in range(10):        left.send(i)    left.close()</code></pre><p>#<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></p><h3 id="为什么要有进程池？"><a href="#为什么要有进程池？" class="headerlink" title="为什么要有进程池？"></a>为什么要有进程池？</h3><pre><code>开启过多的进程并不能提高你的效率，反而会降低效率</code></pre><h3 id="计算密集型-充分占用CPU-多进程可以充分利用多核"><a href="#计算密集型-充分占用CPU-多进程可以充分利用多核" class="headerlink" title="计算密集型  充分占用CPU 多进程可以充分利用多核"></a>计算密集型  充分占用CPU 多进程可以充分利用多核</h3><pre><code>适合开启多进程，但是不适合开启很多多进程</code></pre><h3 id="IO密集型-大部分时间都在阻塞队列，而不是在运行状态中"><a href="#IO密集型-大部分时间都在阻塞队列，而不是在运行状态中" class="headerlink" title="IO密集型    大部分时间都在阻塞队列，而不是在运行状态中"></a>IO密集型    大部分时间都在阻塞队列，而不是在运行状态中</h3><pre><code>根本不太适合开启多进程</code></pre><p><strong>实例化 传参数 进程的个数 cpu/cpu+1<br>提交任务<br>同步提交 apply<br>    返回值 ： 子进程对应函数的返回值<br>    一个一个顺序执行的，并没有任何并发效果<br>异步提交 apply_async<br>    没有返回值，要想所有任务能够顺利的执行完毕<br>        p.close()<br>        p.join() # 必须先close再join，阻塞直到进程池中的所有任务都执行完毕<br>    有返回值的情况下<br>        res.get() # get不能再提交任务之后立刻执行，应该是先提交所有的任务再通过get获取结果<br>    map()方法<br>        异步提交的简化版本<br>        自带close和join方法</strong></p><p> #<strong>*</strong><br>    from multiprocessing import Pool<br>    import time<br>    def fun(i):<br>        print(i)<br>    if <strong>name</strong> == ‘<strong>main</strong>‘:<br>        p = Pool(5)<br>        start = time.clock()<br>        for i in range(10000):</p><pre><code>    # p.apply_async(func=fun, args=(i,)) #异步提交 1.3874192285529539(时间)    p.apply(fun, args=(i,)) #通同步提交2.2022746500453803(时间)p.close() # 关闭进程池，用户不能再向这个池中提交任务了p.join() # 阻塞，直到进程池中所有的任务都被执行完end = time.clock()print(end - start)</code></pre><p>#<strong>*</strong></p><pre><code>from multiprocessing import Poolimport timedef fun(i):    print(i)    return i*2if __name__ == &apos;__main__&apos;:    p = Pool(5)    start = time.clock()    p_lis = []    for i in range(10000):        ret = p.apply_async(func=fun, args=(i,)) #异步提交 1.3874192285529539(时间)        p_lis.append(ret)         # p.apply(fun, args=(i,)) #通同步提交2.2022746500453803(时间)    p.close() # 关闭进程池，用户不能再向这个池中提交任务了    p.join() # 阻塞，直到进程池中所有的任务都被执行完    for ret in p_lis:        print(ret.get()) #取出进程里面的返回值    end = time.clock()    print(end - start)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;创建共享的进程队列，Queue是多进程安全的队列，可以使用Queue实现多进程之间的数据传递。&quot;&gt;&lt;a href=&quot;#创建共享的进程队列，Queue是多进程安全的队列，可以使用Queue实现多进程之间的数据传递。&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>异常处理</title>
    <link href="http://yoursite.com/2018/10/02/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2018/10/02/异常处理/</id>
    <published>2018-10-02T04:24:38.954Z</published>
    <updated>2018-10-03T10:32:13.985Z</updated>
    
    <content type="html"><![CDATA[<p>##1：初始异常</p><p>###即便是放在try语句中的内容，在遇到报错之后也会中断这段语句的执行</p><p>####1.1 类型异常<br>    l = [‘登录’, ‘注册’]<br>    try:<br>        num = int(input(‘input :’)) #输入：非数字报错 invalid literal for int() with base 10: ‘j’<br>    except ValueError:<br>        print(‘异常：num’)</p><p>####1.2列表索引异常<br>    try:<br>        num = int(input(‘input:’))<br>        print(l[num -1]) #输入数字大于2 IndexError: list index out of range<br>    except IndexError:<br>        print(‘异常：索引超标!’)</p><p>####1.3多分支异常<br>    try:<br>        num = int(input(‘input: ‘))<br>        print(l[num-1])<br>    except IndexError:<br>        print(‘索引越界！’)<br>    except ValueError:<br>        print(‘类型有误！’)</p><p>####1.4多异常<br>    try:<br>           num = int(input(‘input:’))<br>          print(l[num -1])<br>    except (ValueError, IndexError):<br>          print(‘报错！’)</p><p>####1.5万能异常</p><pre><code>try:    l = []    # l[3]    open(&apos;aaa&apos;)except Exception:    print(&apos;异常！&apos;)</code></pre><p>####1.6 as 异常<br>    try:<br>        l[3] #list index out of range<br>        name #name ‘name’ is not defined<br>    except Exception as e:<br>        print(e) #抛出异常的内容</p><p>####1.7 多异常加万能异常<br>    try:<br>        num = int(input(‘input :’))<br>        print(l[num -1])<br>    except (ValueError, IndexError):<br>        print(‘异常！’) #持性了这里下面的将不在执行<br>    except Exception as e:<br>        print(e)</p><p>##2：异常的其他处理机制</p><p>####2.1 else 机制<br>    try:<br>        print(‘My name is Dan’)<br>    except ValueError:<br>        print(‘name is leiwenxuan’)<br>    else:<br>        print(‘出错了’) #报错将不执行, 没触发异常将执行</p><p>###2.2finally</p><pre><code>try:    name #异常    print(&apos;hello !&apos;)except NameError:    print(&apos;报错！&apos;)finally:    print(&apos;你好！&apos;) #无论异常处不触发都执行# finally 无论如何都要执行# 收尾工作，打开了一个文件，占用了一个网络资源，打开了一个和数据库的链接try:    f = open(&apos;content&apos;)    name #即使报错了，也执行finallyfinally:    f.close()    print(&apos;执行了！&apos;)</code></pre><p>###2.3 强制异常<br>    raise NameError(‘name’)<br>    raise NameError</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##1：初始异常&lt;/p&gt;
&lt;p&gt;###即便是放在try语句中的内容，在遇到报错之后也会中断这段语句的执行&lt;/p&gt;
&lt;p&gt;####1.1 类型异常&lt;br&gt;    l = [‘登录’, ‘注册’]&lt;br&gt;    try:&lt;br&gt;        num = int(input(‘
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>协程，线程池</title>
    <link href="http://yoursite.com/2018/10/02/%E5%8D%8F%E7%A8%8B%EF%BC%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://yoursite.com/2018/10/02/协程，线程池/</id>
    <published>2018-10-02T04:24:38.924Z</published>
    <updated>2018-10-03T10:34:27.305Z</updated>
    
    <content type="html"><![CDATA[<p>标签（空格分隔）：线程池/协程</p><p>#线程池</p><p>###concurrent.futures模块提供了一个用于异步执行callables的高级接口。</p><p>##<strong>concurrent.futures.ThreadPoolExecutor</strong></p><p>###submit（fn，* args，** kwargs ）<br>将可调用的fn调度为执行， 并返回表示可调用执行的对象</p><pre><code>from concurrent.futures import ThreadPoolExecutordef fun(i):    print(&apos;my name is %s&apos;%i)t = ThreadPoolExecutor(5)for i in range(10):    ret = t.submit(fun, i)    #返回一个可执行的对象 &lt;Future at 0x7f2da90c3e10 state=pending&gt;</code></pre><p>###<strong>shutdown(wait=True) </strong><br>相当于进程池的pool.close()+pool.join()操作<br>wait=True，等待池内所有任务执行完毕回收完资源后才继续<br>wait=False，立即返回，并不会等待池内的任务执行完毕<br>但不管wait参数为何值，整个程序都会等到所有任务执行完毕<br>submit和map必须在shutdown之前</p><p>####具体代码</p><pre><code>def fun(i):print(&apos;my name is %s&apos;%i)return i*2t = ThreadPoolExecutor(5)for i in range(10):    ret = t.submit(fun, i)    print(ret.result()) #查看返回的结果t.shutdown() #表示线程都执行完毕print(&apos;主进程结束&apos;)</code></pre><p>###map  取代for循环submit的操作</p><pre><code>from concurrent.futures import ThreadPoolExecutordef fun(i):    print(&apos;my name is %s&apos;%i)    return i*2t = ThreadPoolExecutor(5)res = map(fun, range(20))for i in res:print(i)</code></pre><p>##ProcessPoolExecutor<br>它是Executor使用的过程池异步执行调用子类。 ProcessPoolExecutor使用该multiprocessing模块，它允许它侧向全局解释器锁定，但也意味着只能执行和返回可选对象。<br>该<strong>main</strong>模块必须可由工作程序子进程导入。这意味着ProcessPoolExecutor在交互式解释器中不起作用。</p><p>###简单的回调函数</p><pre><code>from concurrent.futures import ProcessPoolExecutordef fun(i):    print(i)    return i*2def call_back(arg):    print(&apos;call back:&apos;, arg.result())if __name__ == &apos;__main__&apos;:    p = ProcessPoolExecutor()    for i in range(20):        p.submit(fun, i).add_done_callback(call_back)    print(&apos;主线程&apos;)</code></pre><p>##××××××××××××××××××××××××××××××××××××××</p><p>##<strong>协程</strong></p><p>###协程的优势：<br>    线程： 计算机中能被cpu执行的最小单位<br>        一条线程在多个任务之间来回切换，切换这个动作是浪费时间的<br>        对与cpu， 操作系统来说协程是不存在的# 一个任务不得不陷入阻塞， 在这个任务的过程中切换到另一个任务继续执行<br>    你的程序的只要还需要执行， 你的当前线程永远不会阻塞<br>    同时做几件事件，在做一件事件的时候还可以做其他的事件，比如做饭的时候，煮粥的时候可以切菜，炒菜，干一些其他事件，等待煮粥事件<br>    合理的利用时间， 不要等待一个事件， 比如程序的时候，在阻塞的时候干一些其他啊的事件</p><p>###协程模块：<br>    利用协程来进行多个任务陷入阻塞的时候进行切换来保证在处理多个任务的时候总是忙<br>    无论是进程还是线程都是有操作系统来切换的，开启的线程，进程会给操作系统的调动带来压力<br>    如果我们使用的是协程，协程在程序之间的切换操作系统感知不到，无论开启多个协程对操作系统的调用不会带来压力</p><p> spawn(函数名) 产生了一个协程任物在遇到IO操作的时候帮助我们在多任务之&gt; 间自动切换<br>    join()        阻塞 直到某个任务被执行完毕<br>    join_all()<br>    value属性      获取返回值</p><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><pre><code>from gevent import monkeymonkey.patch_all() #dimport threadingimport timeimport geventdef fun1():    print(&apos;1111&apos;)    gevent.sleep(1)    print(&apos;2222&apos;)    g1_id = threading.current_thread().getName()    print(g1_id)def fun2():    print(&apos;3333&apos;)    gevent.sleep(1)    print(&apos;44444&apos;)    #查看进程ID    g2_id = threading.current_thread().getName()    print(g2_id) #假的线程g1 = gevent.spawn(fun1)#遇到阻塞就回切换g2 = gevent.spawn(fun2)gevent.joinall([g1, g2]) #等待子线程结束</code></pre><p>###<strong>爬虫示例代码</strong></p><p>###具体的示例</p><pre><code>from gevent import monkeymonkey.patch_all()import timeimport geventimport requestsusl_list = [        &apos;http://www.baidu.com&apos;,        &apos;http://www.4399.com&apos;,        &apos;http://www.7k7k.com&apos;,        &apos;http://www.sogou.com&apos;,        &apos;http://www.sohu.com&apos;,        &apos;http://www.sina.com&apos;,        &apos;http://www.jd.com&apos;,        &apos;https://www.luffycity.com/home&apos;,        &apos;https://www.douban.com&apos;,        &apos;http://www.cnblogs.com/Eva-J/articles/8324673.html&apos;,        &apos;http://www.baidu.com&apos;,        &apos;http://www.7k7k.com&apos;,        &apos;http://www.sogou.com&apos;,        &apos;http://www.sohu.com&apos;,        &apos;https://www.luffycity.com/home&apos;,    ]def get_url(url):    response = requests.get(url)    if response.status_code == 200: #查看验证网页是否通        print(url, len(response.text)) #response.text网页的信息        passstart = time.time()for url in usl_list:    get_url(url)print(time.time() - start) #7.55start = time.time()g_lis = []for url in usl_list:    g = gevent.spawn(get_url, url)    #响应网页有延迟， 在延迟期间切换其他任务执行    g_lis.append(g)gevent.joinall(g_lis)print(time.time() - start) # 1.7</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;标签（空格分隔）：线程池/协程&lt;/p&gt;
&lt;p&gt;#线程池&lt;/p&gt;
&lt;p&gt;###concurrent.futures模块提供了一个用于异步执行callables的高级接口。&lt;/p&gt;
&lt;p&gt;##&lt;strong&gt;concurrent.futures.ThreadPoolExecut
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>线程知识点</title>
    <link href="http://yoursite.com/2018/10/02/%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://yoursite.com/2018/10/02/线程知识点/</id>
    <published>2018-10-02T04:24:38.895Z</published>
    <updated>2018-10-03T10:34:20.567Z</updated>
    
    <content type="html"><![CDATA[<p>#线程知识点</p><p>##1线程锁</p><p>###1.1GIL</p><p>###1.2线程之间的数据安全问题<br>    例如：多个线程对同一块数据进行操作；<br>            比如赋值运算， 一个线程那到数据还没有返回数据结果时间片轮转，引起数据的不安全；<br>        pop, append 操作是安全的，<br>        队列也是安全的</p><p>####具体操作<br>    <code>此处输入代码    from threading import Thread, Lock</code><br>    lock.acquire()<br>    ‘’’<br>        对数据的操作<br>    ‘’’<br>    lock.release()</p><p>###1.3递归锁和死锁现象</p><p>####死锁<br>     是指两个或两个以上的进程或线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程，如下就是死锁</p><p>#####死锁现象<br>        两把锁<br>        异步的<br>        操作的时候 抢到一把锁之后还要再去抢第二把锁<br>        一个线程抢到一把锁<br>        另一个线程抢到了另一把锁</p><p>####解决办法<br>    解决方法，递归锁，在Python中为了支持在同一线程中多次请求同一资源，python提供了可重入锁RLock。这个RLock内部维护着一个Lock和一个counter变量，counter记录了acquire的次数，从而使得资源可以被多次require。直到一个线程所有的acquire都被release，其他的线程才能获得资源。上面的例子如果使用RLock代替Lock，则不会发生死锁：</p><p>####示例代码<br>    import time<br>    def fun(lock):<br>        lock.acquire()<br>        print(‘我还活着’)<br>        lock.release()<br>        time.sleep(1)<br>        lock.acquire()<br>        print(‘你还没死’)<br>        lock.release()<br>    def func(lock):<br>        lock.acquire()<br>        lock.acquire()<br>        print(‘没死’)<br>        lock.release()<br>        lock.release()                           </p><pre><code>if __name__ == &apos;__main__&apos;:                       lock = Lock()                                # for i in range(10):                        t1 = Thread(target=fun, args=(lock,))        t1.start()                                   t2 = Thread(target=func, args=(lock,))       t2.start()      </code></pre><p>###递归锁<br>    在Python中为了支持在同一线程中多次请求同一资源，python提供了可重入锁RLock。这个RLock内部维护着一个Lock和一个counter变量，counter记录了acquire的次数，从而使得资源可以被多次require。直到一个线程所有的acquire都被release，其他的线程才能获得资源。上面的例子如果使用RLock代替Lock，则不会发生生死锁</p><p>####具体代码<br>    from threading import Thread, RLock<br>    fork_lock = noodle_lock = RLock()# 一把锁<br>    def fun1(*args):<br>        noodle_lock.acquire()                   </p><pre><code>#具体操作                                   fork_lock.acquire()                     # 具体操作                                  fork_lock.release()                     noodle_lock.release()  #只有当锁释放后才能执行其他操作</code></pre><h3 id="递归锁可以解决互斥锁的死锁问题"><a href="#递归锁可以解决互斥锁的死锁问题" class="headerlink" title="递归锁可以解决互斥锁的死锁问题"></a>递归锁可以解决互斥锁的死锁问题</h3><pre><code># 互斥锁 ¦   # 两把锁 ¦   # 多个线程抢 # 递归锁 ¦   # 一把锁 ¦   # 多个线程抢</code></pre><h4 id="递归锁能够快速的解决死锁问题"><a href="#递归锁能够快速的解决死锁问题" class="headerlink" title="递归锁能够快速的解决死锁问题"></a>递归锁能够快速的解决死锁问题</h4><pre><code>  # 递归锁好不好？  不好， 出现死锁，肯定是程序的逻辑有问题， 在快速解决死锁的情况下， 修改程序的逻辑。 递归锁 迅速恢复服务 递归锁替换互斥锁     在接下来的时间中慢慢把递归锁替换成互斥锁     能够完善代码的逻辑     提高代码的效率多个线程之间，用完一个资源再用另外一个资源先释放一个资源，再去获取一个资源的锁</code></pre><p>###信号量<br>    与进程的的信号量用法一样</p><p>###<strong>事件Event</strong><br>    wait() 等待 事件内的信号编程True<br>    set()  把信号变成True<br>    clear  把信号变成False<br>    is_set 查看信号状态是否为True</p><p>###示例代码<br>    from threading import<br>    import time          </p><pre><code>def fun1(e):             e.wait()   #在set没有调用之前下面的语句不执行     print(&apos;你好呀，我来了&apos;) def fun2(e):             time.sleep(5)        e.set()          if __name__ == &apos;__mai    e = Event()          t1 = Thread(targe    t1.start()           t2 = Thread(targe    t2.start()       </code></pre><p>###<strong>条件 Condition</strong><br>    Python提供的Condition对象提供了对复杂线程同步问题的支持。Condition被称为条件变量，除了提供与Lock类似的acquire和release方法外，还提供了wait和notify方法。线程首先acquire一个条件变量，然后判断一些条件。如果条件不满足则wait；如果条件满足，进行一些处理改变条件后，通过notify方法通知其他线程，其他处于wait状态的线程接到通知后会重新判断条件。不断的重复这一过程，从而解决复杂的同步问题<br>    from threading import Condition, Thread<br>    def fun(con, name):<br>        print(‘欢迎光临’)<br>        con.acquire()<br>        con.wait()     #使用前后都需要加锁<br>        print(‘%s go to school’%name)<br>        con.release()<br>    if <strong>name</strong> == ‘<strong>main</strong>‘:<br>        con = Condition()<br>        for i in range(10):<br>            t = Thread(target=fun, args=(con, i))<br>            t.start()<br>        con.acquire()                                                                      </p><pre><code># con.notify(4)   #使用前后都需要加锁  每次默认一个，参数代表通过的次数                                     # con.notify_all()                                                                 con.notifyAll()                                                                    con.release()       </code></pre><p>###定时器 Timer<br>定时器，指定n秒后执行某个操作</p><pre><code>from threading import Thread, Timer                       def func():                                                   print(&apos;Timer: going to &apos;)                             if __name__ == &apos;__main__&apos;:                                    t = Timer(5, func)                                        t.start()                                   </code></pre><p>###线程队列 queue队列<br>跟队列进程队列一样的用法</p><pre><code>q = queue.Queue()         q.put(1)                  q.put(2)                  q.put(3)                  #先进先出原则                   print(q.get())    #1      print(q.get())    #2      print(q.get())    #3      </code></pre><p>###<strong>线程队列 LifoQueue</strong><br>和栈类似先进后出</p><pre><code>from queue import LifoQueueq = LifoQueue()q.put(1)q.put(2)q.put(3)print(q.get()) #3print(q.get()) #2print(q.get()) #1</code></pre><p>###<strong>PriorityQueue</strong><br>存储数据时可设置优先级的队列</p><pre><code>from queue import PriorityQueueq = PriorityQueue()q.put((3,&apos;lei&apos;))q.put((2,&apos;wen&apos;))q.put((1,&apos;xuan&apos;))print(q.get())print(q.get())print(q.get())</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#线程知识点&lt;/p&gt;
&lt;p&gt;##1线程锁&lt;/p&gt;
&lt;p&gt;###1.1GIL&lt;/p&gt;
&lt;p&gt;###1.2线程之间的数据安全问题&lt;br&gt;    例如：多个线程对同一块数据进行操作；&lt;br&gt;            比如赋值运算， 一个线程那到数据还没有返回数据结果时间片轮转，引起
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>网络编程</title>
    <link href="http://yoursite.com/2018/10/02/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/10/02/网络编程/</id>
    <published>2018-10-02T04:24:38.864Z</published>
    <updated>2018-10-03T10:34:13.019Z</updated>
    
    <content type="html"><![CDATA[<p>##1：软件开发的架构</p><p>###两件程序之间通讯的应用大致可以分为两种：<br>    第一种：qq. 微信，网盘，优酷 这一类是属于需要安装的桌面应用<br>    第二种：比如百度， 知乎，博客园之类</p><p>####c/s架构<br>    即Client 与 Server， 客户端与服务器的端架构</p><p>####b/s架构<br>    Browser 与 Serverm 浏览器与服务端架构</p><p>##IP地址</p><pre><code>1: 网卡 ：身份证 mac地址 计算机在网络上的身份证2: 交换机 ：负责一个网络内的多台机器之间的信息交换3: mac地址 ：16进制的数  全球唯一1: 127.0.0.1 ：本地回环地址 本机的地址2: 0.0.0.0 ： ip地址的、回环地址的所有的用户都能找到你这台机器</code></pre><p>####局域网</p><pre><code># 局域网1: 网关ip    不同局域网之间通信依赖的ip地址2: 子网掩码  判断两个ip地址是否在同一个网段内3：网段# 0.0.0.0 - 255.255.255.255# 局域网的概念# 外网ip 我们谁都能访问# 内网ip 从外部不能访问，只能在内部环境中互相访问# 外网ip永远不会和内网ip冲突？# 0.0.0.0 - 255.255.255.255中间为内网保留了一些字段# 192.168.0.0 - 192.168.255.255# 10.0.0.0 - 10.255.255.255# 172.16.0.0 - 172.31.255.255</code></pre><p>###局域网中两台机器的通信原理</p><h1 id="局域网中两台机器的通信原理"><a href="#局域网中两台机器的通信原理" class="headerlink" title="局域网中两台机器的通信原理"></a>局域网中两台机器的通信原理</h1><pre><code># 交换机# ip地址# ip地址 -arp协议-&gt; mac地址# mac地址 ： 全球唯一# arp协议 ： 广播 和 单播    # 通过ip地址获取mac地址    # 一台机器A发起一个arp请求（只包含ip地址），发送给交换机    # 交换机接收到请求，广播这条消息    # 所有的机器都会接收到这个请求，只有和要寻找ip地址吻合的机器B    # 才会回应交换机的广播，（带着自己的mac地址）    # 交换机通过单播的形式将回复的B的mac地址发送给A# 判断两台机器是不是在同一个局域网内：    # 子网掩码    # A机器的ip地址和A的子网掩码 按位与    # B机器的ip地址和B的子网掩码 按位与    # 得到的结果如果一致 那么说明两台机器是在一个网段内的</code></pre><p>####端口</p><pre><code># 端口的概念 —— 帮助你找到一个应用# 每一个网络服务都会占用计算机上的一个端口# 计算机上的端口范围 0-65535# 在同一时刻 同一台计算机上 不同的网络应用 占用的端口一定是不同的</code></pre><p>##2：OSI 七层模型</p><p>####在7层的基础上简化为5层</p><pre><code># 应用层 http、https ftp smtp# 传输层 TCP、UDP协议  4层路由器， 4层交换机        # 端口 ：找到某一台机器上的具体的网络应用        # tcp 面向连接 可靠 慢 全双工            # 三次握手 建立tcp连接的过程            # 发消息            # 四次挥手 断开tcp连接的过程           # udp 无连接 不可靠 快# 网络层 ip协议  3层交换机 3层路由器# 数据链路层 arp协议 / mac地址 网卡，交换机        arp协议：根据ip地址找mac地址 ----交换机（广播， 单播）# 物理层</code></pre><p>##Tcp 和 Udp</p><h4 id="tcp-面向连接的-可靠的-但是慢"><a href="#tcp-面向连接的-可靠的-但是慢" class="headerlink" title="tcp 面向连接的 可靠的 但是慢"></a>tcp 面向连接的 可靠的 但是慢</h4><pre><code># tcp协议# 两个应用之间要想通信 必须先建立连接# 然后基于连接来通信# 比较重要的文件 邮件的发送 下载安装包#比较可靠的长数据</code></pre><h4 id="udp-无连接的-快-能够发送的信息长度是有限的"><a href="#udp-无连接的-快-能够发送的信息长度是有限的" class="headerlink" title="udp 无连接的 快 能够发送的信息长度是有限的"></a>udp 无连接的 快 能够发送的信息长度是有限的</h4><pre><code># 快 但 不可靠 不能发送过长的数据# 即时通讯类的程序#高并发的短消息</code></pre><p>###tcp和udp 的区别<br>     tcp、udp是通过网络通信的两种方式<br>       tcp 先建立连接再通信</p><pre><code>    # 可靠    # 慢， 流式传输udp 不需要建立连接直接通信    # 快    # 不可靠</code></pre><p>###<strong>TCP协议中的数据传递</strong></p><p>###tcp协议的拆包机制</p><pre><code>当发送端缓冲区的长度大于网卡的MTU时，tcp会将这次发送的数据拆成几个数据包发送出去。 MTU是Maximum Transmission Unit的缩写。意思是网络上传送的最大数据包。MTU的单位是字节。 大部分网络设备的MTU都是1500。如果本机的MTU比网关的MTU大，大的数据包就会被拆开来传送，这样会产生很多数据包碎片，增加丢包率，降低网络速度。</code></pre><p>###面向流的通信特点和Nagle算法</p><pre><code>TCP（transport control protocol，传输控制协议）是面向连接的，面向流的，提供高可靠性服务。收发两端（客户端和服务器端）都要有一一成对的socket，因此，发送端为了将多个发往接收端的包，更有效的发到对方，使用了优化方法（Nagle算法），将多次间隔较小且数据量小的数据，合并成一个大的数据块，然后进行封包。这样，接收端，就难于分辨出来了，必须提供科学的拆包机制。 即面向流的通信是无消息保护边界的。 对于空消息：tcp是基于数据流的，于是收发的消息不能为空，这就需要在客户端和服务端都添加空消息的处理机制，防止程序卡住，而udp是基于数据报的，即便是你输入的是空内容（直接回车），也可以被发送，udp协议会帮你封装上消息头发送过去。 可靠黏包的tcp协议：tcp的协议数据不会丢，没有收完包，下次接收，会继续上次继续接收，己端总是在收到ack时才会清除缓冲区内容。数据是可靠的，但是会粘包。</code></pre><p>###一个简单的tcp： server 和 client</p><p>####sever<br>    from socket import *<br>    ip_port = (‘127.0.0.1’, 9514)</p><pre><code>sk = socket(AF_INET, SOCK_STREAM)sk.bind(ip_port)sk.listen()sk_cl, addr = sk.accept()data1 = sk_cl.recv(10)data2 = sk_cl.recv(10)print(&apos;-----&gt;&apos;, data1.decode(&apos;utf-8&apos;))print(&apos;-----&gt;&apos;, data2.decode(&apos;utf-8&apos;))sk_cl.close()</code></pre><p>####client<br>    from socket import *<br>    ip_port = (‘127.0.0.1’, 9514)</p><pre><code>sk = socket(AF_INET, SOCK_STREAM)sk.connect(ip_port)sk.send(b&apos;my name is leiwenxuan&apos;)sk.send(b&apos;nsdfasfdsf&apos;)</code></pre><p>####udp的简单程序</p><p>###sever<br>    import socket<br>    sk = socket.socket(type=socket.SOCK_DGRAM)</p><pre><code>sk.bind((&apos;127.0.0.1&apos;, 9000))while 1:    msg,addr = sk.recvfrom(1024)    print(msg.decode(&apos;utf-8&apos;), addr)    # sk.sendto(&apos;正在发送...&apos;.encode(&apos;utf-8&apos;), addr)    inp = input(&apos;input :&apos;)</code></pre><p>###client<br>    import socket</p><pre><code>sk = socket.socket(type=socket.SOCK_DGRAM)sk.bind((&apos;127.0.0.1&apos;, 9001))while 1:    # sk.sendto(&apos;正在发送...&apos;.encode(&apos;utf-8&apos;), (&apos;127.0.0.1&apos;, 9000))    inp = input(&apos;input:&apos;)    sk.sendto(inp.encode(&apos;utf-8&apos;),(&apos;127.0.0.1&apos;, 9000) )    msg, addr = sk.recvfrom(1024)    print(msg.decode(&apos;utf-8&apos;), addr[1])</code></pre><p>##一个重要的黏包处理</p><p>###server<br>    import json, struct<br>    ‘’’传输一个简单的文件’’’<br>    import os<br>    from socket import *<br>    path_name = r’G:\python笔记\Pythonjing\day31\video\1.内容回顾和作业讲解.mp4’<br>    path_name = os.path.realpath(path_name)<br>    size = str(os.path.getsize(path_name))</p><pre><code>ip_port = (&apos;127.0.0.1&apos;, 9514)sk = socket(AF_INET, SOCK_STREAM)sk.bind(ip_port)sk.listen()sk_cl, addr = sk.accept()sk_cl.send(size.encode(&apos;utf-8&apos;))with open(path_name, &apos;rb&apos;) as f:    while 1:        data = f.read(2048)        pack_num = struct.pack(&apos;i&apos;, len(data))        sk_cl.send(pack_num)        sk_cl.send(data)        if not data:            pack_num = struct.pack(&apos;i&apos;, len(&apos;&apos;))            sk_cl.send(pack_num)            print(len(data))            break</code></pre><p>##client<br>    from socket import *<br>    import struct<br>    import sys</p><pre><code>def processBar(num, total):    &apos;&apos;&apos;进度条&apos;&apos;&apos;    rate = num / total    rate_num = int(rate * 100)    if rate_num == 100:        r = &apos;\r%s&gt;%d%%\n&apos; % (&apos;|&apos; * rate_num, rate_num,)    else:        r = &apos;\r%s&gt;%d%%&apos; % (&apos;|&apos; * rate_num, rate_num,)    sys.stdout.write(r)    sys.stdout.fluship_port = (&apos;127.0.0.1&apos;, 9514)sk = socket(AF_INET, SOCK_STREAM)sk.connect(ip_port)size = int(sk.recv(1024).decode(&apos;utf-8&apos;))# processBar(2048, size)num_size = 0with open(&apos;lw.mp4&apos;,&apos;wb&apos;) as f:    while 1:        pack_num = sk.recv(4)        num = struct.unpack(&apos;i&apos;, pack_num)[0]        # print(num)        if not num:            break        ret = sk.recv(num)        f.write(ret)        num_size += num        processBar(num_size, size)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##1：软件开发的架构&lt;/p&gt;
&lt;p&gt;###两件程序之间通讯的应用大致可以分为两种：&lt;br&gt;    第一种：qq. 微信，网盘，优酷 这一类是属于需要安装的桌面应用&lt;br&gt;    第二种：比如百度， 知乎，博客园之类&lt;/p&gt;
&lt;p&gt;####c/s架构&lt;br&gt;    即Cli
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="http://yoursite.com/2018/10/01/re%E6%A8%A1%E5%9D%97/"/>
    <id>http://yoursite.com/2018/10/01/re模块/</id>
    <published>2018-10-01T06:45:16.865Z</published>
    <updated>2018-10-03T10:33:25.736Z</updated>
    
    <content type="html"><![CDATA[<p>###正则表达式的常见使用场景<br>    1：判断某一个字符串是否符合规则 #注册页-判断手机号-身份证<br>    2：将符合规则的内容从一个庞大的字符串体系中提取出来</p><pre><code>#爬虫日志分析</code></pre><p>###什么是正则表达式？<br>    1：是一种规则</p><h2 id="一正则表达式步骤"><a href="#一正则表达式步骤" class="headerlink" title="一正则表达式步骤"></a>一正则表达式步骤</h2><pre><code>1.用 import re 导入正则表达式模块。2.用 re.compile()函数创建一个 regex 对象（记得使用原始字符串）。3.向 regex 对象的 search()方法传入想查找的字符串。它返回一个 match 对象4.调用 match 对象的 group()方法，返回实际匹配文本的字符串。补充：regex 对象的 search()方法查找传入的字符串， 寻找该正则表达式的所有匹配。如果字符串中没有找到该正则表达式模式，search()方法将返回 none。如果找到了该模式，search()方法将返回一个 match 对象。</code></pre><h2 id="二用正则表达式匹配更多模式"><a href="#二用正则表达式匹配更多模式" class="headerlink" title="二用正则表达式匹配更多模式"></a>二用正则表达式匹配更多模式</h2><h4 id="2-1：利用括号分组"><a href="#2-1：利用括号分组" class="headerlink" title="2.1：利用括号分组"></a>2.1：利用括号分组</h4><pre><code>phonenumregex = re.compile(&apos;(\d{3})-(\d{3})-(\d{4})&apos;)mo = phonenumregex.search(&apos;my number is 444-333-3333&apos;)print(mo.group(1)) #444print(mo.group(0)) #444-333-3333print(mo.group()) #向group传0或者不传值匹配的都是字符串print(mo.groups())#(&apos;444&apos;, &apos;333&apos;, &apos;3333&apos;)</code></pre><h3 id="2-2：用管道匹配多个分组"><a href="#2-2：用管道匹配多个分组" class="headerlink" title="2.2：用管道匹配多个分组"></a>2.2：用管道匹配多个分组</h3><pre><code>heroregex = re.compile(r&apos;batman|雷文轩&apos;)mo = heroregex.search(&apos;雷文轩 and batman&apos;)print(mo.group())#雷文轩 匹配一个就退出heroregex = re.compile(r&apos;雷(文轩|一鸣|英)&apos;)mo = heroregex.search(&apos; 雷文轩， 雷文轩and 雷英&apos;)print(mo.group()) #匹配其中一个</code></pre><h3 id="2-3：用问好实现可选匹配"><a href="#2-3：用问好实现可选匹配" class="headerlink" title="2.3：用问好实现可选匹配"></a>2.3：用问好实现可选匹配</h3><p>#####正则表达式中的(文)?部分表明， 模式 wo 是可选的分组。该正则表达式匹配的文本中， 文将出现零次或一次。<br>    batregex = re.compile(r’雷(文)?轩’)<br>    mo = batregex.search(‘my name is 雷轩’)<br>    print(mo.group()) #雷轩</p><h3 id="2-4：用星号匹配零次或多次"><a href="#2-4：用星号匹配零次或多次" class="headerlink" title="2.4：用星号匹配零次或多次"></a>2.4：用星号匹配零次或多次</h3><p>#####（称为星号）意味着“匹配零次或多次”，即星号之前的分组或者<strong>一个元字符</strong>，可以在文本中出现任意次。它可以完全不存在，或一次又一次地重复。</p><pre><code>batrgex = re.compile(r&apos;bat(wo)*man&apos;)mo = batrgex.search(&apos; the adventures of batman&apos;)print(mo.group()) #batmanmo1 = batrgex.search(&apos; the adventures of batwoman&apos;)print(mo1.group()) #batwomanmo2 = batrgex.search(&apos; the adventures of batwowowoman&apos;)print(mo2.group()) #batwowowoman</code></pre><h3 id="2-5：用加号匹配一次或多次"><a href="#2-5：用加号匹配一次或多次" class="headerlink" title="2.5：用加号匹配一次或多次"></a>2.5：用加号匹配一次或多次</h3><p>#####正则表达式 bat(wo)+man 不会匹配字符串’the adventures of batman’，因为加号要求 wo 至少出现一次。如果需要匹配真正的加号字符， 在加号前面加上倒斜杠实现转义： +。</p><pre><code>#batregex = re.compile(&apos;bat(wo)+man&apos;)mo = batregex.search(&apos;the adventures of batwoman&apos;)print(mo.group()) #batwoman#******mo = batregex.search(&apos;the adventures of batman&apos;)#+ 号代表一次或者多次print(mo == none) #匹配队里里为空 等于none</code></pre><h3 id="2-5：用花括号匹配特定次数"><a href="#2-5：用花括号匹配特定次数" class="headerlink" title="2.5：用花括号匹配特定次数"></a>2.5：用花括号匹配特定次数</h3><p>#####如果想要一个分组重复特定次数，就在正则表达式中该分组的后面，跟上花括号包围的数字。例如，正则表达式(ha){3}将匹配字符串’hahaha’，但不会匹配’haha’，因为后者只重复了(ha)分组两次。除了一个数字，还可以指定一个范围，即在花括号中写下一个最小值、一个逗号和一个最大值。例如，正则表达式(ha){3,5}将匹配’hahaha’、 ‘hahahaha’和’hahahahaha’。</p><p>#####也可以不写花括号中的第一个或第二个数字， 不限定最小值或最大值。例如，(ha){3,}将匹配 3 次或更多次实例， (ha){,5}将匹配 0 到 5 次实例。花括号让正则表达式更简短。这两个正则表达式匹配同样的模式：<br>    hareget = re.compile(r’(ha){3}’)#匹配hahaha<br>    mo = hareget.search(‘hahaha’) #不会匹配haha<br>    print(mo.group())#hahaha</p><h3 id="2-6贪心和非贪心匹配"><a href="#2-6贪心和非贪心匹配" class="headerlink" title="2:6贪心和非贪心匹配"></a>2:6贪心和非贪心匹配</h3><pre><code>greedyharegex = re.compile(r&apos;(ha){3,5}&apos;)mo = greedyharegex.search(&apos;hahahaha&apos;)print(mo.group()) #hahahaha 他会匹配更长的值nongeedyharegex = re.compile(r&apos;(ha){3,5}?&apos;)mo2 = nongeedyharegex.search(&apos;hahahahaha&apos;)print(mo2.group())#hahaha 尽量取少的模式#贪婪匹配：正则会尽量多的帮我们匹配， 默认贪婪，回溯算法#非贪婪匹配：会尽量少的为我们匹配，    1：</code></pre><h2 id="三重要的方法"><a href="#三重要的方法" class="headerlink" title="三重要的方法"></a>三重要的方法</h2><h3 id="3-1-findall-方法"><a href="#3-1-findall-方法" class="headerlink" title="3.1    findall()方法"></a>3.1    findall()方法</h3><pre><code>phonenumregex = re.compile(r&apos;(\d{3})-(\d{3})-(\d{4})&apos;)mo = phonenumregex.findall(&apos;cell: 415-555-9999 work: 212-555-0000&apos;)print(mo) #[(&apos;415&apos;, &apos;555&apos;, &apos;9999&apos;), (&apos;212&apos;, &apos;555&apos;, &apos;0000&apos;)]#1:返回一个字符串列表，． 如果调用在一个有分组的正则表达式上，#2:方法 findall()将返回一个字符串的元组的列表（每个分组对应一个字符串），#3：会优先显示分组中的内容 ,(?:) 取消分组优先</code></pre><h3 id="3-2-split"><a href="#3-2-split" class="headerlink" title="3.2 split()"></a>3.2 split()</h3><pre><code>1.mo = re.split(&apos;(\w+)&apos;, &apos;my name is Dan, My sperk 1 langure&apos;)2.print(mo)#[&apos;my name is  leiwenxuan , the man years old &apos;, &apos;25&apos;, &apos;, It is sunny water&apos;]3.print(mo)#[&apos;my name is  leiwenxuan , the man years old &apos;, &apos;, It is sunny water&apos;]#() 和没有()的匹配的结果是不一样的#在匹配部分加上（）之后所切出的结果是不同的，#没有（）的没有保留所匹配的项，但是有（）的却能够保留了匹配的项，#这个在某些需要保留匹配部分的使用过程是非常重要的。</code></pre><h3 id="3-3-finditer（）"><a href="#3-3-finditer（）" class="headerlink" title="3.3 finditer（）"></a>3.3 finditer（）</h3><pre><code>fin = re.finditer(&apos;\d+&apos;, &apos;186lei 987has 123&apos;) #finditer返回一个存放匹配结果的迭代器for ret in fin:      print(ret) #&lt;_sre.SRE_Match object; span=(14, 17), match=&apos;123&apos;&gt;       print(ret.group())  #186</code></pre><h3 id="3-4match"><a href="#3-4match" class="headerlink" title="3.4match"></a>3.4match</h3><pre><code>mo = re.match(&apos;\d+&apos;, &apos;jkhjk892028617dsds&apos;)print(mo.group())# 报错AttributeErrormo = re.match(&apos;\d+&apos;, &apos;892028617rsds&apos;)print(mo.group()) #892028617*#注意事项： match 和search区别  match默认匹配加 ^ *</code></pre><h3 id="3-5sub-方法替换字符串"><a href="#3-5sub-方法替换字符串" class="headerlink" title="3.5sub()方法替换字符串"></a>3.5sub()方法替换字符串</h3><pre><code>1. sub_mo = re.compile(&apos;Agent \w+&apos;)2. mo = sub_mo.sub(&apos;leiwenxuan&apos;, &apos;Agent Alice gave the secret documents to Agent Bob.&apos;)3. print(mo) #leiwenxuan gave the secret documents to leiwenxuan.4. 对象的 sub()方法需要传入两个参数。第一个参数是一个字符串， 用于取代发现的匹配。第二个参数是一个字符串，即正则表达式。5. 在没有compile 绑定的情况下： 第一个参数是正则， 第二个是 替换的 ， 第三个是字符串， 还可以有第四个代表替换次数6. mo = re.sub(r&apos;name&apos;, &apos;姓名&apos;, &apos;name: Dan, name: lisa&apos;, 1)7. print(mo) # 姓名: Dan, name: lisa1. agentNameRggex = re.compile(r&apos;Agent (\w)\w*&apos;)2. mo = agentNameRggex.sub(r&apos;\1****&apos;, &apos;Agent Alice told Agent Carol that AgentEve knew Agent Bob was a double agent.&apos;)3. print(mo)</code></pre><h2 id="四字符分类"><a href="#四字符分类" class="headerlink" title="四字符分类"></a>四字符分类</h2><pre><code>4.1 元字符</code></pre><p>匹配内容</p><pre><code>.      匹配除换行符以外的任意字符\w     匹配字母或数字或下划线\s     匹配任意的空白符\d     匹配数字\n     匹配一个换行符\t     匹配一个制表符\b     匹配一个单词的结尾^     匹配字符串的开始$     匹配字符串的结尾\W     匹配非字母或数字或下划线\D     匹配非数字\S     匹配非空白符a|b     匹配字符a或字符b()     匹配括号内的表达式，也表示一个组[...]     匹配字符组中的字符[^...]     匹配除了字符组中字符的所有字符例如：字符分类[0-5]只匹配数字 0 到 5， 这比输入(0|1|2|3|4|5)要短很多。![字符分类](https://i.imgur.com/P2Udbd6.png)</code></pre><p>2018/9/10/周一 10:04:49 </p><h3 id="4-1插入字符和美元字符"><a href="#4-1插入字符和美元字符" class="headerlink" title="4.1插入字符和美元字符"></a>4.1插入字符和美元字符</h3><pre><code>1. 可以在正则表达式的开始处使用插入符号（^），表明匹配必须发生在被查找文本开始处2. 类似地，可以再正则表达式的末尾加上美元符号（$），表示该字符串必须以这个正则表达式的模式结束。可以同时使用^和$，表明整个字符串必须匹配该模式，也就是说，只匹配该字符串的某个子集是不够的。</code></pre><h3 id="4-2不区分大小写的匹配"><a href="#4-2不区分大小写的匹配" class="headerlink" title="4.2不区分大小写的匹配"></a>4.2不区分大小写的匹配</h3><pre><code>1. rebocp = re.compile(r&apos;leiWenXuan&apos;,re.I) 2. #忽略大小写  re.IGNORECASE 或者re.I3. mo = rebocp.search(&apos;Leiwenxuan livs in chain&apos;)4. print(mo.group())</code></pre><h3 id="管理复杂的正则表达式"><a href="#管理复杂的正则表达式" class="headerlink" title="管理复杂的正则表达式"></a>管理复杂的正则表达式</h3><pre><code>1. phoneRegex = re.compile(r&apos;&apos;&apos;       \w     #可以加注释&apos;&apos;&apos;, re.VERBOSE)2.mo = phoneRegex.findall(&apos;erhja&apos;)3.print(mo)flags有很多可选值：    re.I(IGNORECASE)忽略大小写，括号内是完整的写法    re.M(MULTILINE)多行模式，改变^和$的行为    re.S(DOTALL)点可以匹配任意字符，包括换行符    re.L(LOCALE)做本地化识别的匹配，表示特殊字符集 \w, \W, \b, \B, \s, \S 依赖于当前环境，不推荐使用    re.U(UNICODE) 使用\w \W \s \S \d \D使用取决于unicode定义的字符属性。在python3中默认使用该flag    re.X(VERBOSE)冗长模式，该模式下pattern字符串可以是多行的，忽略空白字符，并可以添加注释</code></pre><h3 id="分组命名、分组约束"><a href="#分组命名、分组约束" class="headerlink" title="分组命名、分组约束"></a>分组命名、分组约束</h3><h4 id="用途-前端"><a href="#用途-前端" class="headerlink" title="用途 前端"></a>用途 前端</h4><pre><code>1.pattern = &apos;&lt;(?P&lt;tag&gt;.*?)&gt;.*?&lt;/(?P=tag)&gt;&apos;2.ret = re.search(pattern, &apos;&lt;h2&gt; my name is who&lt;/h1&gt;&apos;)3.&apos;&apos;&apos;匹配&lt;&gt;里面一样才匹配&apos;&apos;&apos;4.if ret:5.     print(ret.group())6 pattern = r&apos;&lt;(.*?)&gt;.*?&lt;/\1&gt;&apos;7.ret = re.search(pattern, &apos;&lt;h1&gt; my name is who&lt;/h1&gt;&apos;)8.&apos;&apos;&apos;匹配前后格式一样的标签&apos;&apos;&apos;9.if ret:10.    print(ret.group())11.    #(?:正则表达式) 表示取消优先显示功能# (?P&lt;组名&gt;正则表达式) 表示给这个组起一个名字#(?P=组名) 表示引用之前组的名字，引用部分匹配到的内容必须和之前那个组中的内容一模一样    **</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###正则表达式的常见使用场景&lt;br&gt;    1：判断某一个字符串是否符合规则 #注册页-判断手机号-身份证&lt;br&gt;    2：将符合规则的内容从一个庞大的字符串体系中提取出来&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#爬虫日志分析
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;###什么是正则表
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2018/10/01/hello-world/"/>
    <id>http://yoursite.com/2018/10/01/hello-world/</id>
    <published>2018-10-01T04:42:47.891Z</published>
    <updated>2018-10-02T12:59:18.605Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>测试</title>
    <link href="http://yoursite.com/2017/12/02/test/"/>
    <id>http://yoursite.com/2017/12/02/test/</id>
    <published>2017-12-02T13:01:24.000Z</published>
    <updated>2018-10-03T10:28:24.174Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="云服务器" scheme="http://yoursite.com/categories/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="centOS" scheme="http://yoursite.com/tags/centOS/"/>
    
      <category term="tomcat" scheme="http://yoursite.com/tags/tomcat/"/>
    
  </entry>
  
</feed>
