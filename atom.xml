<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>雷文轩</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-10-19T15:01:47.497Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Leiwenxuan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>jQuery简单入门</title>
    <link href="http://yoursite.com/2018/10/17/JQuery%E5%88%9D%E8%AF%86/"/>
    <id>http://yoursite.com/2018/10/17/JQuery初识/</id>
    <published>2018-10-17T06:56:57.000Z</published>
    <updated>2018-10-19T15:01:47.497Z</updated>
    
    <content type="html"><![CDATA[<h1 id="jQuery版本"><a href="#jQuery版本" class="headerlink" title="jQuery版本"></a>jQuery版本</h1><p>1.x：兼容IE678,使用最为广泛的，官方只做BUG维护，功能不再新增。因此一般项目来说，使用1.x版本就可以了，最终版本：1.12.4 (2016年5月20日)</p><p>2.x：不兼容IE678，很少有人使用，官方只做BUG维护，功能不再新增。如果不考虑兼容低版本的浏览器可以使用2.x，最终版本：2.2.4 (2016年5月20日)</p><p>3.x：不兼容IE678，只支持最新的浏览器。需要注意的是很多老的jQuery插件不支持3.x版。目前该版本是官方主要更新维护的版本。<br>维护IE678是一件让人头疼的事情，一般我们都会额外加载一个CSS和JS单独处理。值得庆幸的是使用这些浏览器的人也逐步减少，PC端用户已经逐步被移动端用户所取代，如果没有特殊要求的话，一般都会选择放弃对678的支持。</p><h1 id="jQuery-对象"><a href="#jQuery-对象" class="headerlink" title="jQuery 对象"></a>jQuery 对象</h1><p>jQuery对象就是通过jQuery包装DOM对象后产生的对象。jQuery对象是 jQuery独有的。如果一个对象是 jQuery对象，那么它就可以使用jQuery里的方法：例如$(“#i1”).html()。</p><p>$(“#i1”).html()的意思是：获取id值为 i1的元素的html代码。其中 html()是jQuery里的方法。</p><p>相当于： <strong>document.getElementById(“i1”).innerHTML;</strong></p><p>虽然 jQuery对象是包装 DOM对象后产生的，但是 jQuery对象无法使用 DOM对象的任何方法，同理 DOM对象也没不能使用 jQuery里的方法。</p><p>一个约定，我们在声明一个jQuery对象变量的时候在变量名前面加上$：</p><h1 id="注意事项调用jQuery语法要调用-也就是jQuery-库"><a href="#注意事项调用jQuery语法要调用-也就是jQuery-库" class="headerlink" title="注意事项调用jQuery语法要调用 也就是jQuery 库"></a><strong>注意事项调用jQuery语法要调用 <script src="jquery.js"></script>也就是jQuery 库</strong></h1><h2 id="jQuery-基础语法"><a href="#jQuery-基础语法" class="headerlink" title="jQuery 基础语法"></a>jQuery 基础语法</h2><pre><code>$(selector).action()</code></pre><h1 id="查找标签"><a href="#查找标签" class="headerlink" title="查找标签"></a>查找标签</h1><h2 id="基本原则器"><a href="#基本原则器" class="headerlink" title="基本原则器"></a>基本原则器</h2><h3 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a>id选择器</h3><pre><code>$(&quot;#id&quot;)</code></pre><h3 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h3><pre><code>$(&quot;tagName&quot;)</code></pre><h3 id="class-选择器"><a href="#class-选择器" class="headerlink" title="class 选择器"></a>class 选择器</h3><pre><code>$(&quot;.className&quot;)</code></pre><h3 id="配合使用"><a href="#配合使用" class="headerlink" title="配合使用"></a>配合使用</h3><pre><code>$(&quot;div.c1&quot;) // 找到有c1 class的div 标签</code></pre><h3 id="所有的元素选择器"><a href="#所有的元素选择器" class="headerlink" title="所有的元素选择器"></a>所有的元素选择器</h3><pre><code>$(&quot;*&quot;)</code></pre><h3 id="组合选择器"><a href="#组合选择器" class="headerlink" title="组合选择器"></a>组合选择器</h3><pre><code>$(&quot;#id , .classname, tanName&quot;)</code></pre><h2 id="层级选择器"><a href="#层级选择器" class="headerlink" title="层级选择器"></a>层级选择器</h2><p>x 和 y 可以为任意选择器</p><p>$(“x y”) //x 的所有Y后代<br>$(“X&gt;y”)  //x的所有儿子y<br>$(“x+y”)   // 找到所有紧邻在X后面的Y<br>$(“x~y”)   //x之后所有的兄弟Y<br><img src="https://i.imgur.com/y8cENWG.png" alt=""></p><h2 id="基本选择器"><a href="#基本选择器" class="headerlink" title="基本选择器"></a>基本选择器</h2><pre><code>:first // 第一个:last // 最后一个:eq(index)// 索引等于index的那个元素:even // 匹配所有索引值为偶数的元素，从 0 开始计数:odd // 匹配所有索引值为奇数的元素，从 0 开始计数:gt(index)// 匹配所有大于给定索引值的元素:lt(index)// 匹配所有小于给定索引值的元素:not(元素选择器)// 移除所有满足not条件的标签:has(元素选择器)// 选取所有包含一个或多个标签在其内的标签(指的是从后代元素找)</code></pre><p><img src="https://i.imgur.com/JA1qlZC.png" alt=""></p><h3 id="具体事例"><a href="#具体事例" class="headerlink" title="具体事例"></a>具体事例</h3><pre><code>&lt;body&gt;&lt;div&gt;wo shi 1&lt;/div&gt;&lt;div class=&quot;c1&quot;&gt;wo shi c1&lt;/div&gt;&lt;ul id=&quot;u1&quot;&gt;    &lt;l1&gt;1&lt;/l1&gt;    &lt;l1&gt;2&lt;/l1&gt;    &lt;l1&gt;3&lt;/l1&gt;    &lt;l1&gt;4&lt;/l1&gt;    &lt;l1&gt;5&lt;/l1&gt;    &lt;l1&gt;6&lt;/l1&gt;    &lt;l1&gt;7&lt;/l1&gt;    &lt;l1&gt;8&lt;/l1&gt;    &lt;l1&gt;9&lt;/l1&gt;    &lt;l1&gt;10&lt;/l1&gt;&lt;/ul&gt;&lt;/body&gt;</code></pre><p><img src="https://i.imgur.com/UvnnvZ3.png" alt=""></p><h2 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h2><p>[attribute]<br>[attribute=value]// 属性等于<br>[attribute!=value]// 属性不等于</p><p><img src="https://i.imgur.com/UqKKpWM.png" alt=""><br><img src="https://i.imgur.com/6GfbJ2z.png" alt=""></p><h2 id="筛选器方法"><a href="#筛选器方法" class="headerlink" title="筛选器方法"></a>筛选器方法</h2><h3 id="下一个元素"><a href="#下一个元素" class="headerlink" title="下一个元素"></a>下一个元素</h3><pre><code>$(&quot;#id&quot;).next() //下一个$(&quot;#id&quot;).nextAll()  //$(&quot;#id&quot;).nextUntil(&quot;#i2&quot;)</code></pre><h3 id="上一个元素"><a href="#上一个元素" class="headerlink" title="上一个元素"></a>上一个元素</h3><pre><code>$(&quot;#id&quot;).prev()$(&quot;#id&quot;).prevAll()$(&quot;#id&quot;).prevUntil(&quot;#i2&quot;)</code></pre><h3 id="父亲元素"><a href="#父亲元素" class="headerlink" title="父亲元素"></a>父亲元素</h3><pre><code>$(&quot;#id&quot;).parent()$(&quot;#id&quot;).parents()  // 查找当前元素的所有的父辈元素$(&quot;#id&quot;).parentsUntil() // 查找当前元素的所有的父辈元素，直到遇到匹配的那个元素为止</code></pre><h3 id="儿子和兄弟元素"><a href="#儿子和兄弟元素" class="headerlink" title="儿子和兄弟元素"></a>儿子和兄弟元素</h3><pre><code>$(&quot;#id&quot;).children();// 儿子们$(&quot;#id&quot;).siblings();// 兄弟们</code></pre><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><pre><code>搜索所有与指定表达式匹配的元素。这个函数是找出正在处理的元素的后代元素的好方法。$(&quot;div&quot;).find(&quot;p&quot;)等价于$(&quot;div p&quot;)</code></pre><h3 id="筛选"><a href="#筛选" class="headerlink" title="筛选"></a>筛选</h3><pre><code>筛选出与指定表达式匹配的元素集合。这个方法用于缩小匹配的范围。用逗号分隔多个表达式。$(&quot;div&quot;).filter(&quot;.c1&quot;)  // 从结果集中过滤出有c1样式类的等价于 $(&quot;div.c1&quot;)补充：.first() // 获取匹配的第一个元素.last() // 获取匹配的最后一个元素.not() // 从匹配元素的集合中删除与指定表达式匹配的元素.has() // 保留包含特定后代的元素，去掉那些不含有指定后代的元素。.eq() // 索引值等于指定值的元素</code></pre><p>### </p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><pre><code>$(&quot;div:has(h1)&quot;)// 找到所有后代中有h1标签的div标签$(&quot;div:has(.c1)&quot;)// 找到所有后代中有c1样式类的div标签$(&quot;li:not(.c1)&quot;)// 找到所有不包含c1样式类的li标签$(&quot;li:not(:has(a))&quot;)// 找到所有后代中不含a标签的li标签</code></pre><h3 id="属性选择器-1"><a href="#属性选择器-1" class="headerlink" title="属性选择器"></a>属性选择器</h3><pre><code>[attribute][attribute=value]// 属性等于[attribute!=value]// 属性不等于用法    $(&quot;#create&quot;).click(function () {    console.log(alert(&quot;nihao&quot;));    flag = true      $(&apos;input[name=&quot;username&quot;]&apos;).val(&apos;&apos;);    $(&apos;input[name=&quot;password&quot;]&apos;).val(&apos;&apos;);    $(&quot;.hide&quot;).toggleClass(&quot;hide&quot;);})</code></pre><h3 id="表单筛选器"><a href="#表单筛选器" class="headerlink" title="表单筛选器"></a>表单筛选器</h3><p>根据表单的属性进行选择<br>    :text<br>    :password<br>    :file<br>    :radio<br>    :checkbox</p><pre><code>:submit:reset:button</code></pre><h4 id="表单对象属性"><a href="#表单对象属性" class="headerlink" title="表单对象属性"></a>表单对象属性</h4><pre><code>:enabled:disabled:checked:selected  //判断option是否被选中</code></pre><h3 id="筛选器方法-1"><a href="#筛选器方法-1" class="headerlink" title="筛选器方法"></a>筛选器方法</h3><h4 id="下一个元素-1"><a href="#下一个元素-1" class="headerlink" title="下一个元素"></a>下一个元素</h4><pre><code>$(&quot;#id&quot;).next()  //下一个$(&quot;#id&quot;).nextAll()  //同级下面全部$(&quot;#id&quot;).nextUntil(&quot;#i2&quot;) 全了“#i2”全部</code></pre><h3 id="上一个元素-1"><a href="#上一个元素-1" class="headerlink" title="上一个元素"></a>上一个元素</h3><pre><code>$(&quot;#id&quot;).prev()  #上一个$(&quot;#id&quot;).prevAll() # 上面所有$(&quot;#id&quot;).prevUntil(&quot;#i2&quot;) #除去“#i2”所有</code></pre><h3 id="父级元素"><a href="#父级元素" class="headerlink" title="父级元素"></a>父级元素</h3><pre><code>$(&quot;#id&quot;).parent()$(&quot;#id&quot;).parents()  // 查找当前元素的所有的父辈元素$(&quot;#id&quot;).parentsUntil(“匹配条件”) // 查找当前元素的所有的父辈元素，直到遇到匹配的那个元素为止。</code></pre><h3 id="儿子和兄弟元素-1"><a href="#儿子和兄弟元素-1" class="headerlink" title="儿子和兄弟元素"></a>儿子和兄弟元素</h3><pre><code>$(&quot;#id&quot;).children();// 儿子们$(&quot;#id&quot;).siblings();// 兄弟们</code></pre><h3 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h3><p>搜索所有与指定表达式匹配的元素。这个函数是找出正在处理的元素的后代元素的好方法。</p><pre><code>$(&quot;div&quot;).find(&quot;p&quot;)    等价于$(&quot;div p&quot;)</code></pre><h3 id="筛选-1"><a href="#筛选-1" class="headerlink" title="筛选"></a>筛选</h3><p>筛选出与指定表达式匹配的元素集合。这个方法用于缩小匹配的范围。用逗号分隔多个表达式。</p><pre><code>$(&quot;div&quot;).filter(&quot;.c1&quot;)  // 从结果集中过滤出有c1样式类的</code></pre><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><pre><code>.first() // 获取匹配的第一个元素.last() // 获取匹配的最后一个元素.not() // 从匹配元素的集合中删除与指定表达式匹配的元素.has() // 保留包含特定后代的元素，去掉那些不含有指定后代的元素。.eq() // 索引值等于指定值的元</code></pre><h3 id="样式操作"><a href="#样式操作" class="headerlink" title="样式操作"></a>样式操作</h3><pre><code>addClass();// 添加指定的CSS类名。removeClass();// 移除指定的CSS类名。hasClass();// 判断样式存不存在toggleClass();// 切换CSS类名，如果有就移除，如果没有就添加</code></pre><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><pre><code>css(&quot;color&quot;,&quot;red&quot;)//DOM操作：tag.style.color=&quot;red&quot;示例：$(&quot;p&quot;).css(&quot;color&quot;, &quot;red&quot;); //将所有p标签的字体设置为红色</code></pre><h3 id="位置操作"><a href="#位置操作" class="headerlink" title="位置操作"></a>位置操作</h3><pre><code>offset()// 获取匹配元素在当前窗口的相对偏移或设置元素位置position()// 获取匹配元素相对父元素的偏移scrollTop()// 获取匹配元素相对滚动条顶部的偏移scrollLeft()// 获取匹配元素相对滚动条左侧的偏移    </code></pre><p>.offset()方法允许我们检索一个元素相对于文档（document）的当前位置。</p><p>和 .position()的差别在于： .position()是相对于相对于父级元素的位移。</p><h3 id="尺寸"><a href="#尺寸" class="headerlink" title="尺寸"></a>尺寸</h3><pre><code>height()width()innerHeight()innerWidth()outerHeight()outerWidth()</code></pre><h3 id="文本操作"><a href="#文本操作" class="headerlink" title="文本操作"></a>文本操作</h3><h4 id="HTML代码："><a href="#HTML代码：" class="headerlink" title="HTML代码："></a>HTML代码：</h4><pre><code>html()// 取得第一个匹配元素的html内容html(val)// 设置所有匹配元素的html内容</code></pre><h4 id="文本值"><a href="#文本值" class="headerlink" title="文本值"></a>文本值</h4><pre><code>val()// 取得第一个匹配元素的当前值val(val)// 设置所有匹配元素的值val([val1, val2])// 设置多选的checkbox、多选select的值</code></pre><h3 id="属性操作"><a href="#属性操作" class="headerlink" title="属性操作"></a>属性操作</h3><h4 id="用于ID等或自定义属性"><a href="#用于ID等或自定义属性" class="headerlink" title="用于ID等或自定义属性"></a>用于ID等或自定义属性</h4><pre><code>attr(attrName)// 返回第一个匹配元素的属性值attr(attrName, attrValue)// 为所有匹配元素设置一个属性值attr({k1: v1, k2:v2})// 为所有匹配元素设置多个属性值removeAttr()// 从每一个匹配的元素中删除一个属性</code></pre><h4 id="用于checkbox和radio"><a href="#用于checkbox和radio" class="headerlink" title="用于checkbox和radio"></a>用于checkbox和radio</h4><pre><code>prop() // 获取属性removeProp() // 移除属性</code></pre><p>attr全称attribute(属性) </p><p>prop全称property(属性)</p><p>虽然都是属性，但他们所指的属性并不相同，attr所指的属性是HTML标签属性，而prop所指的是DOM对象属性，可以认为attr是显式的，而prop是隐式的。</p><p>prop不支持获取标签的自定义属性</p><h3 id="文档处理"><a href="#文档处理" class="headerlink" title="文档处理"></a>文档处理</h3><h4 id="添加到指定元素内部的后面"><a href="#添加到指定元素内部的后面" class="headerlink" title="添加到指定元素内部的后面"></a>添加到指定元素<strong>内部</strong>的后面</h4><pre><code>$(A).append(B)// 把B追加到A$(A).appendTo(B)// 把A追加到B</code></pre><h4 id="添加到指定元素-内部的前面"><a href="#添加到指定元素-内部的前面" class="headerlink" title="添加到指定元素 内部的前面"></a>添加到指定元素 <strong>内部</strong>的前面</h4><pre><code>$(A).prepend(B)// 把B前置到A$(A).prependTo(B)// 把A前置到B</code></pre><h4 id="添加到指定元素-外部-的后面"><a href="#添加到指定元素-外部-的后面" class="headerlink" title="添加到指定元素 外部 的后面"></a>添加到指定元素 <strong>外部</strong> 的后面</h4><pre><code>$(A).after(B)// 把B放到A的后面$(A).insertAfter(B)// 把A放到B的后面</code></pre><h4 id="添加到指定元素-外部-的前面"><a href="#添加到指定元素-外部-的前面" class="headerlink" title="添加到指定元素 外部 的前面"></a>添加到指定元素 <strong>外部</strong> 的前面</h4><pre><code>$(A).before(B)// 把B放到A的前面$(A).insertBefore(B)// 把A放到B的前面</code></pre><h4 id="移除和清空元素"><a href="#移除和清空元素" class="headerlink" title="移除和清空元素"></a>移除和清空元素</h4><pre><code>remove()// 从DOM中删除所有匹配的元素。empty()// 删除匹配的元素集合中所有的子节点。</code></pre><h4 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h4><pre><code>replaceWith()replaceAll()    </code></pre><h4 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h4><pre><code>clone()// 参数</code></pre><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>###常用事件</p><h4 id="click-function-…"><a href="#click-function-…" class="headerlink" title="click(function(){…})"></a>click(function(){…})</h4><p>鼠标点击事件</p><h4 id="hover-function-…"><a href="#hover-function-…" class="headerlink" title="hover(function(){…})"></a>hover(function(){…})</h4><p>鼠标放到上面， 和移除  两个函数必须有 </p><h4 id="blur-function-…"><a href="#blur-function-…" class="headerlink" title="blur(function(){…})"></a>blur(function(){…})</h4><h4 id="focus-function-…"><a href="#focus-function-…" class="headerlink" title="focus(function(){…})"></a>focus(function(){…})</h4><h4 id="change-function-…"><a href="#change-function-…" class="headerlink" title="change(function(){…})"></a>change(function(){…})</h4><p>选择改变事件</p><h4 id="keyup-function-…"><a href="#keyup-function-…" class="headerlink" title="keyup(function(){…})"></a>keyup(function(){…})</h4><p>和keydown 一个按下反应<br>一个抬起</p><h3 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h3><pre><code>1.on( events [, selector ],function(){})events： 事件selector: 选择器（可选的）function: 事件处理函数</code></pre><h3 id="事件移除"><a href="#事件移除" class="headerlink" title="事件移除"></a>事件移除</h3><pre><code>1.off( events [, selector ][,function(){}])off() 方法移除用 .on()绑定的事件处理程序。events： 事件selector: 选择器（可选的）function: 事件处理函数    </code></pre><h3 id="阻止后续事件执行"><a href="#阻止后续事件执行" class="headerlink" title="阻止后续事件执行"></a>阻止后续事件执行</h3><p>1.return false; // 常见阻止表单提交等<br>2.e.preventDefault();</p><h3 id="页面载入"><a href="#页面载入" class="headerlink" title="页面载入"></a>页面载入</h3><pre><code>$(document).ready(function(){// 在这里写你的JS代码...})</code></pre><p>window.onload()函数有覆盖现象，必须等待着图片资源加载完成之后才能调用<br>jQuery的这个入口函数没有函数覆盖现象，文档加载完成之后就可以调用（建议使用）</p><h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>事件委托是通过事件冒泡的原理，利用父标签去捕获子标签的事件。<br>    $(“table”).on(“click”, “.delete”, function () {<br>      // 删除按钮绑定的事件<br>    })</p><h3 id="动画效果"><a href="#动画效果" class="headerlink" title="动画效果"></a>动画效果</h3><p>了解即可</p><pre><code>// 基本show([s,[e],[fn]])hide([s,[e],[fn]])toggle([s],[e],[fn])// 滑动slideDown([s],[e],[fn])slideUp([s,[e],[fn]])slideToggle([s],[e],[fn])// 淡入淡出fadeIn([s],[e],[fn])fadeOut([s],[e],[fn])fadeTo([[s],o,[e],[fn]])fadeToggle([s,[e],[fn]])// 自定义（了解即可）animate(p,[s],[e],[fn])</code></pre><h3 id="each-遍历jQuery方法"><a href="#each-遍历jQuery方法" class="headerlink" title="each 遍历jQuery方法"></a>each 遍历jQuery方法</h3><pre><code>$(&quot;div&quot;).each(function (){console.log(this)})</code></pre><h3 id="data（）"><a href="#data（）" class="headerlink" title="data（）"></a>data（）</h3><p>在匹配的元素集合中的所有元素上存储任意相关数据或返回匹配的元素集合中的第一个元素的给定名称的数据存储的值。</p><h4 id="data-key-value"><a href="#data-key-value" class="headerlink" title=".data(key, value):"></a>.data(key, value):</h4><p>描述：在匹配的元素上存储任意相关数据。</p><pre><code>$(&quot;div&quot;).data(&quot;k&quot;,100);//给所有div标签都保存一个名为k，值为100</code></pre><h4 id="data-key"><a href="#data-key" class="headerlink" title=".data(key):"></a>.data(key):</h4><p>描述: 返回匹配的元素集合中的第一个元素的给定名称的数据存储的值—通过 .data(name, value)或 HTML5 data-*属性设置。</p><pre><code>$(&quot;div&quot;).data(&quot;k&quot;);//返回第一个div标签中保存的&quot;k&quot;的值</code></pre><p>####.removeData(key):</p><p>描述：移除存放在元素上的数据，不加key参数表示移除所有保存的数据。</p><pre><code>$(&quot;div&quot;).removeData(&quot;k&quot;);  //移除元素上存放k对应的数据</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;jQuery版本&quot;&gt;&lt;a href=&quot;#jQuery版本&quot; class=&quot;headerlink&quot; title=&quot;jQuery版本&quot;&gt;&lt;/a&gt;jQuery版本&lt;/h1&gt;&lt;p&gt;1.x：兼容IE678,使用最为广泛的，官方只做BUG维护，功能不再新增。因此一般项目来说，
      
    
    </summary>
    
      <category term="html" scheme="http://yoursite.com/categories/html/"/>
    
    
      <category term="jQuery" scheme="http://yoursite.com/tags/jQuery/"/>
    
  </entry>
  
  <entry>
    <title>cssPostion-定位</title>
    <link href="http://yoursite.com/2018/10/16/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8BBOM%E5%92%8CDOM/"/>
    <id>http://yoursite.com/2018/10/16/前端基础之BOM和DOM/</id>
    <published>2018-10-16T06:53:05.000Z</published>
    <updated>2018-10-16T15:23:14.995Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript分为-ECMAScript，DOM，BOM。"><a href="#JavaScript分为-ECMAScript，DOM，BOM。" class="headerlink" title="JavaScript分为 ECMAScript，DOM，BOM。"></a>JavaScript分为 ECMAScript，DOM，BOM。</h1><pre><code>BOM（Browser Object Model）是指浏览器对象模型，它使 JavaScript 有能力与浏览器进行“对话”。DOM （Document Object Model）是指文档对象模型，通过它，可以访问HTML文档的所有元素</code></pre><h1 id="window-对象"><a href="#window-对象" class="headerlink" title="window 对象"></a>window 对象</h1><p>所有的浏览器都支持window 对象， 它表示浏览器窗口。<br>如果文档包含框架（frame 或者iframe 标签），浏览器会为 HTML 文档创建一个 window 对象，并为每个框架创建一个额外的 window 对象。<br>*没有应用于 window 对象的公开标准，不过所有浏览器都支持该对象。<br>所有 JavaScript 全局对象、函数以及变量均自动成为 window 对象的成员。</p><p>全局变量是 window 对象的属性。全局函数是 window 对象的方法。</p><p><img src="https://i.imgur.com/QqF3Ubk.png" alt=""></p><h2 id="Window-的子标签"><a href="#Window-的子标签" class="headerlink" title="Window 的子标签"></a>Window 的子标签</h2><h3 id="navigator-对象"><a href="#navigator-对象" class="headerlink" title="navigator 对象"></a>navigator 对象</h3><p>浏览器对象， 通过这个对象可以判定用户所有使用的浏览器，包含浏览器的信息。</p><p><img src="https://i.imgur.com/4vXxs4H.png" alt=""></p><h3 id="screen-对象"><a href="#screen-对象" class="headerlink" title="screen 对象"></a>screen 对象</h3><p><img src="https://i.imgur.com/0WvbYcY.png" alt=""></p><h3 id="location-对象"><a href="#location-对象" class="headerlink" title="location 对象"></a>location 对象</h3><pre><code>location.href  获取URLlocation.href=&quot;URL&quot; // 跳转到指定页面location.reload() 重新加载页面</code></pre><h3 id="弹框"><a href="#弹框" class="headerlink" title="弹框"></a>弹框</h3><p>JavaScript 中创建三种：警告框， 确认框， 提示框</p><h4 id="警告框"><a href="#警告框" class="headerlink" title="警告框"></a>警告框</h4><pre><code>alert（&quot;字符串&quot;）</code></pre><h4 id="确认框"><a href="#确认框" class="headerlink" title="确认框"></a>确认框</h4><p><img src="https://i.imgur.com/JPC92Pw.png" alt=""></p><h4 id="提示框"><a href="#提示框" class="headerlink" title="提示框"></a>提示框</h4><p><img src="https://i.imgur.com/JhEdKuY.png" alt=""></p><h3 id="计时相关"><a href="#计时相关" class="headerlink" title="计时相关"></a>计时相关</h3><h4 id="setTimeout-和clearTimeout"><a href="#setTimeout-和clearTimeout" class="headerlink" title="setTimeout() 和clearTimeout()"></a>setTimeout() 和clearTimeout()</h4><p><strong>setTimeout: 返回进程id</strong><br><img src="https://i.imgur.com/3k1EqPN.png" alt=""></p><pre><code>clearTimeout() 清除setTimeout()设置</code></pre><h4 id="setInterval-和-clearInterval"><a href="#setInterval-和-clearInterval" class="headerlink" title="setInterval()  和 clearInterval()"></a>setInterval()  和 clearInterval()</h4><p><strong>setInterval ： 返回id</strong><br>    setInterval() 方法可按照指定的周期（以毫秒计）来调用函数或计算表达式。</p><pre><code>setInterval() 方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭。由 setInterval() 返回的 ID 值可用作 clearInterval() 方法的参数</code></pre><h1 id="Dom"><a href="#Dom" class="headerlink" title="Dom"></a>Dom</h1><p>html Dom 树</p><p><img src="https://i.imgur.com/AsjL0H7.png" alt=""></p><p><img src="https://i.imgur.com/VPMKhXP.png" alt=""></p><p><img src="https://i.imgur.com/RPFpbI3.png" alt=""></p><h2 id="查找标签"><a href="#查找标签" class="headerlink" title="查找标签"></a>查找标签</h2><h3 id="直接查找"><a href="#直接查找" class="headerlink" title="直接查找"></a>直接查找</h3><pre><code>document.getElementById           根据ID获取一个标签document.getElementsByClassName   根据class属性获取document.getElementsByTagName     根据标签名获取标签合集</code></pre><h3 id="间接查找"><a href="#间接查找" class="headerlink" title="间接查找"></a>间接查找</h3><p><img src="https://i.imgur.com/tpQ2aui.png" alt=""></p><h3 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h3><p>var divEle = document.createElement(“div”);</p><h3 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h3><pre><code>语法：追加一个子节点（作为最后的子节点）somenode.appendChild(newnode)；把增加的节点放到某个节点的前边。somenode.insertBefore(newnode,某个节点);</code></pre><p><img src="https://i.imgur.com/NL4XmZS.png" alt=""></p><h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><pre><code>语法：获得要删除的元素，通过父元素调用该方法删除。somenode.removeChild(要删除的节点)</code></pre><h3 id="替换节点"><a href="#替换节点" class="headerlink" title="替换节点"></a>替换节点</h3><pre><code>somenode.replaceChild(newnode, 某个节点);</code></pre><h3 id="属性节点"><a href="#属性节点" class="headerlink" title="属性节点"></a>属性节点</h3><p>获取文本节点的值</p><pre><code>var divEle = document.getElementById(&quot;d1&quot;)divEle.innerTextdivEle.innerHTML// 自带的属性还可以直接.属性名来获取和设置imgEle.srcimgEle.src=&quot;...&quot;</code></pre><p><img src="https://i.imgur.com/f5l5YW0.png" alt="">    </p><h3 id="获取值操作"><a href="#获取值操作" class="headerlink" title="获取值操作"></a>获取值操作</h3><p>语法：</p><p>elementNode.value</p><p>适用于以下标签：</p><p>.input<br>.select<br>.textarea</p><p><img src="https://i.imgur.com/w1ljWCZ.png" alt=""></p><h3 id="获取class的操作"><a href="#获取class的操作" class="headerlink" title="获取class的操作"></a>获取class的操作</h3><pre><code>className  获取所有样式类名(字符串)classList.remove(cls)  删除指定类classList.add(cls)  添加类classList.contains(cls)  存在返回true，否则返回falseclassList.toggle(cls)  存在就删除，否则添加</code></pre><h3 id="指定css操作"><a href="#指定css操作" class="headerlink" title="指定css操作"></a>指定css操作</h3><p>obj.style.backgroundColor=”red”<br>JS操作CSS属性的规律：<br><img src="https://i.imgur.com/KYf5J7Y.png" alt=""><br>1.对于没有中横线的CSS属性一般直接使用style.属性名即可。如：</p><pre><code>obj.style.marginobj.style.widthobj.style.leftobj.style.position</code></pre><p>2.对含有中横线的CSS属性，将中横线后面的第一个字母换成大写即可。如：</p><pre><code>obj.style.marginTopobj.style.borderLeftWidthobj.style.zIndexobj.style.fontFamily</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JavaScript分为-ECMAScript，DOM，BOM。&quot;&gt;&lt;a href=&quot;#JavaScript分为-ECMAScript，DOM，BOM。&quot; class=&quot;headerlink&quot; title=&quot;JavaScript分为 ECMAScript，DOM，
      
    
    </summary>
    
      <category term="html" scheme="http://yoursite.com/categories/html/"/>
    
    
      <category term="JavaScript-DOM，BOM。" scheme="http://yoursite.com/tags/JavaScript-DOM%EF%BC%8CBOM%E3%80%82/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript</title>
    <link href="http://yoursite.com/2018/10/15/JavaScript-%E5%88%9D%E8%AF%86/"/>
    <id>http://yoursite.com/2018/10/15/JavaScript-初识/</id>
    <published>2018-10-15T11:23:34.000Z</published>
    <updated>2018-10-15T13:30:18.919Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>一个完整的 JavaScript 实现是由以下 3 个不同部分组成的：</p><ol><li>核心（ECMAScript） </li><li>文档对象模型（DOM） Document object model (整合js，css，html)</li><li>浏览器对象模型（BOM） Broswer object model（整合js和浏览器）</li></ol><p>##JavaScript内容</p><pre><code>JavaScript 是脚本语言JavaScript 是一种轻量级的编程语言。JavaScript 是可插入 HTML 页面的编程代码。JavaScript 插入 HTML 页面后，可由所有的现代浏览器执行。JavaScript 很容易学习。</code></pre><h2 id="JavaScript引入方式"><a href="#JavaScript引入方式" class="headerlink" title="JavaScript引入方式"></a>JavaScript引入方式</h2><pre><code>&lt;script&gt;  // 在这里写你的JS代码&lt;/script&gt;----------&lt;script src=&quot;myscript.js&quot;&gt;&lt;/script&gt;</code></pre><h2 id="JavaScript注释-和C-语言的类似"><a href="#JavaScript注释-和C-语言的类似" class="headerlink" title="JavaScript注释 和C 语言的类似"></a>JavaScript注释 和C 语言的类似</h2><pre><code>// 单行/* */ 多行注释</code></pre><h1 id="JavaScript-语言基础"><a href="#JavaScript-语言基础" class="headerlink" title="JavaScript 语言基础"></a>JavaScript 语言基础</h1><h2 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h2><pre><code>JavaScript的变量名可以使用_，数字，字母，$组成，不能以数字开头。声明变量使用 var 变量名; 的格式来进行声明</code></pre><h2 id="JavaScript数据类型"><a href="#JavaScript数据类型" class="headerlink" title="JavaScript数据类型"></a>JavaScript数据类型</h2><p>JavaScript拥有动态的数据类型</p><h3 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h3><pre><code>var a = 12.34;var b = 20;var c = 123e5;  // 12300000var d = 123e-5;  // 0.00123常用方法parseInt(&quot;123&quot;)  // 返回123parseInt(&quot;ABC&quot;)  // 返回NaN,NaN属性是代表非数字值的特殊值。该属性用于指示某个值不是数字。parseFloat(&quot;123.456&quot;)  // 返回123.456</code></pre><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><pre><code>var a = &quot;Hello&quot;var b = &quot;world;var c = a + b; console.log(c);  // 得到Helloworld</code></pre><p><img src="https://i.imgur.com/5q1Z6AX.png" alt="字符串常用方法"></p><h4 id="slice-和-substring-区别"><a href="#slice-和-substring-区别" class="headerlink" title="slice 和 substring 区别"></a>slice 和 substring 区别</h4><pre><code>string.slice(start, stop)和string.substring(start, stop)：两者的相同点：如果start等于end，返回空字符串如果stop参数省略，则取到字符串末如果某个参数超过string的长度，这个参数会被替换为string的长度substirng()的特点：如果 start &gt; stop ，start和stop将被交换如果参数是负数或者不是数字，将会被0替换silce()的特点：如果 start &gt; stop 不会交换两者如果start小于0，则切割从字符串末尾往前数的第abs(start)个的字符开始(包括该位置的字符)如果stop小于0，则切割在从字符串末尾往前数的第abs(stop)个字符结束(不包含该位置字符    </code></pre><h3 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h3><pre><code>区别于Python，true和false都是小写。var a = true;var b = false;&quot;&quot;(空字符串)、0、null、undefined、NaN都是false。</code></pre><h3 id="null和undefined"><a href="#null和undefined" class="headerlink" title="null和undefined"></a>null和undefined</h3><pre><code>null表示值是空，一般在需要指定或清空一个变量时才会使用，如 name=null;undefined表示当声明一个变量但未初始化时，该变量的默认值是undefined。还有就是函数无明确的返回值时，返回的也是undefined。null表示变量的值是空，undefined则表示只声明了变量，但还没有赋值</code></pre><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><pre><code>和C语言类似</code></pre><p><img src="https://i.imgur.com/tZfv74M.png" alt=""></p><h5 id="关于sort-需要注意："><a href="#关于sort-需要注意：" class="headerlink" title="关于sort()需要注意："></a>关于sort()需要注意：</h5><pre><code>如果调用该方法时没有使用参数，将按字母顺序对数组中的元素进行排序，说得更精确点，是按照字符编码的顺序进行排序。要实现这一点，首先应把数组的元素都转换成字符串（如有必要），以便进行比较。如果想按照其他标准进行排序，就需要提供比较函数，该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。</code></pre><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><pre><code>和C语言类似算数运算符+ - * / % ++ --比较运算符&gt; &gt;= &lt; &lt;= != == === !==逻辑运算符|| &amp;&amp; ！赋值运算符= += -= *= /=</code></pre><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><pre><code>和C语言类似 基本语法 写法都类似</code></pre><h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h3><pre><code>a = x&gt;y ? x:y  如果x &gt; y a = x  否则 a= y</code></pre><h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><pre><code>和Python类似， 定义的方法不同function 函数名（） {    具体代码    }{} 扩起来的代表代码段</code></pre><h4 id="箭头函数-与Python匿名函数一致"><a href="#箭头函数-与Python匿名函数一致" class="headerlink" title="箭头函数 与Python匿名函数一致"></a>箭头函数 与Python匿名函数一致</h4><pre><code>var f = v =&gt; v;// 等同于var f = function(v){  return v;}var f = () =&gt; 5;// 等同于var f = function(){return 5};var sum = (num1, num2) =&gt; num1 + num2;// 等同于var sum = function(num1, num2){  return num1 + num2;}</code></pre><h3 id="函数中的arguments参数"><a href="#函数中的arguments参数" class="headerlink" title="函数中的arguments参数"></a>函数中的arguments参数</h3><pre><code>function add(a,b){  console.log(a+b);  console.log(arguments.length) # 计算传进的参数个数}add(1,2)</code></pre><h3 id="函数的全局变量和局部变量"><a href="#函数的全局变量和局部变量" class="headerlink" title="函数的全局变量和局部变量"></a>函数的全局变量和局部变量</h3><pre><code>局部变量：在JavaScript函数内部声明的变量（使用 var）是局部变量，所以只能在函数内部访问它（该变量的作用域是函数内部）。只要函数运行完毕，本地变量就会被删除。全局变量：在函数外声明的变量是全局变量，网页上的所有脚本和函数都能访问它。变量生存周期：JavaScript变量的生命期从它们被声明的时间开始。局部变量会在函数运行以后被删除。全局变量会在页面关闭后被删除。</code></pre><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>首先在函数内部查找变量，找不到则到外层函数查找，逐步找到最外层</p><h4 id="几个例子"><a href="#几个例子" class="headerlink" title="几个例子"></a>几个例子</h4><pre><code>#例子：1var city = &quot;BeiJing&quot;;function f() {  var city = &quot;ShangHai&quot;;  function inner(){    var city = &quot;ShenZhen&quot;;    console.log(city);  }  inner(); }f();  //输出结果是？shezhen# 例子：2var city = &quot;BeiJing&quot;;function Bar() {  console.log(city);}function f() {  var city = &quot;ShangHai&quot;;  return Bar;}var ret = f();ret();  // 打印结果是？# 例子： 3var city = &quot;BeiJing&quot;;function f(){    var city = &quot;ShangHai&quot;;    function inner(){        console.log(city);    }    return inner;}var ret = f();ret();此处形成闭包， 引用了外层函数的变量并且保存住</code></pre><h2 id="词云分析"><a href="#词云分析" class="headerlink" title="词云分析"></a>词云分析</h2><p>JavaScript中在调用函数的那一瞬间，会先进行词法分析。</p><p>词法分析的过程：</p><p>当函数调用的前一瞬间，会先形成一个激活对象：Avtive Object（AO），并会分析以下3个方面：</p><p>1:函数参数，如果有，则将此参数赋值给AO，且值为undefined。如果没有，则不做任何操作。<br>2:函数局部变量，如果AO上有同名的值，则不做任何操作。如果没有，则将此变量赋值给AO，并且值为undefined。<br>3:函数声明，如果AO上有，则会将AO上的对象覆盖。如果没有，则不做任何操作。</p><p>函数内部无论是使用参数还是使用局部变量都到AO上找。</p><h3 id="几个例子-1"><a href="#几个例子-1" class="headerlink" title="几个例子"></a>几个例子</h3><pre><code># 例子： 1var age = 18;function foo(){  console.log(age);  var age = 22;  console.log(age);}foo();  // 问：执行foo()之后的结果是？结果：     undefined    22# 例子： 2var age = 18;function foo(){  console.log(age);  var age = 22;  console.log(age);  function age(){    console.log(&quot;呵呵&quot;);  }  console.log(age);}foo();  // 执行后的结果是？    </code></pre><p><img src="https://i.imgur.com/ywS6EP9.png" alt=""></p><h1 id="内置方法和对象"><a href="#内置方法和对象" class="headerlink" title="内置方法和对象"></a>内置方法和对象</h1><h2 id="自定义对象"><a href="#自定义对象" class="headerlink" title="自定义对象"></a>自定义对象</h2><p><img src="https://i.imgur.com/pXtbpDx.png" alt=""></p><p><img src="https://i.imgur.com/v1cMQ3C.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;p&gt;一个完整的 JavaScript 实现是由以下 3 个不同部分组成的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;核心（ECMAScript） &lt;/li&gt;

      
    
    </summary>
    
      <category term="html" scheme="http://yoursite.com/categories/html/"/>
    
    
      <category term="-JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>面试真题：</title>
    <link href="http://yoursite.com/2018/10/15/%E9%9D%A2%E8%AF%95%E9%A2%98Python/"/>
    <id>http://yoursite.com/2018/10/15/面试题Python/</id>
    <published>2018-10-15T09:18:02.000Z</published>
    <updated>2018-10-15T11:13:27.739Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-编写函数-实现功能：将-1-2-3-4-5-6-7-转换成-1-2-3-4-5-6-7"><a href="#1-编写函数-实现功能：将-1-2-3-4-5-6-7-转换成-1-2-3-4-5-6-7" class="headerlink" title="1. 编写函数,实现功能：将[1,2,[3,[4,5]],6,[7,]] 转换成[1,2,3,4,5,6,7]"></a>1. 编写函数,实现功能：将[1,2,[3,[4,5]],6,[7,]] 转换成[1,2,3,4,5,6,7]</h1><p>li = [1, 2, [3, [4, 5, [1, 2, [1, 2]]]], 6, [7, ]]</p><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><pre><code>def func( li ):    # lis = []    if isinstance(li, list):        return [y for x in li for y in func(x)]    else:        return [li]</code></pre><p>print(func(li))</p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><pre><code>lis = []def func(li):    for i in li:        if isinstance(i,list):           func(i)        else:            lis.append(i)    return lis</code></pre><p>print(list(func(li)))</p><h2 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h2><pre><code>while lst:if isinstance(lst[0], list):    #这个for循环的作用是把是列表的元素，脱去最外层的列表，把里面的每个元素    #按照它们的索引来插入到原列表中，但最早的列表开头的元素会保留下来    #所以要把索引为index+1的元素删除掉。    for index, i in enumerate(lst[0]):        lst.insert(index, i)    #这句用来理解里面的变化，可以注释掉。    print(lst)    # del lst[index + 1] 也可以用pop或del    lst.pop(index + 1)else:    new_lst.append(lst[0])    lst.pop(0)</code></pre><h1 id="2-1-2-3-4-5-6-7-用生成器将其生成-1-2-3-4-5-6-7"><a href="#2-1-2-3-4-5-6-7-用生成器将其生成-1-2-3-4-5-6-7" class="headerlink" title="2. [1,2,[3,[4,5]],6,[7,]]  用生成器将其生成[1,2,3,4,5,6,7]"></a>2. [1,2,[3,[4,5]],6,[7,]]  用生成器将其生成[1,2,3,4,5,6,7]</h1><h2 id="生成器-一"><a href="#生成器-一" class="headerlink" title="生成器 一"></a>生成器 一</h2><pre><code>def func3(li):    for i in li:        if isinstance(i, list):            for j in func3(i):                yield j        else:            yield iprint(list(func3(li)))</code></pre><h2 id="生产器yield-from"><a href="#生产器yield-from" class="headerlink" title="生产器yield from"></a>生产器yield from</h2><pre><code>def func4(li):    for i in li:        if isinstance(i, list):            yield from func4(i)        else:            yield iprint(list(func4(li)))</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-编写函数-实现功能：将-1-2-3-4-5-6-7-转换成-1-2-3-4-5-6-7&quot;&gt;&lt;a href=&quot;#1-编写函数-实现功能：将-1-2-3-4-5-6-7-转换成-1-2-3-4-5-6-7&quot; class=&quot;headerlink&quot; title=&quot;1.
      
    
    </summary>
    
      <category term="面试题Python编程题" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98Python%E7%BC%96%E7%A8%8B%E9%A2%98/"/>
    
    
      <category term="Python编程题" scheme="http://yoursite.com/tags/Python%E7%BC%96%E7%A8%8B%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>cssPostion-定位</title>
    <link href="http://yoursite.com/2018/10/15/cssPostion-%E5%AE%9A%E4%BD%8D/"/>
    <id>http://yoursite.com/2018/10/15/cssPostion-定位/</id>
    <published>2018-10-15T09:18:02.000Z</published>
    <updated>2018-10-15T09:18:25.498Z</updated>
    
    <content type="html"><![CDATA[<h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><pre><code>static 默认值，无定位，不能当作绝对定位的参照物，并且设置标签对象的left、top等值是不起作用的的。</code></pre><h1 id="relative（相对定位）"><a href="#relative（相对定位）" class="headerlink" title="relative（相对定位）"></a>relative（相对定位）</h1><pre><code>相对定位是相对于该元素在文档流中的原始位置，即以自己原始位置为参照物。有趣的是，即使设定了元素的相对定位以及偏移值，元素还占有着原来的位置，即占据文档流空间。对象遵循正常文档流，但将依据top，right，bottom，left等属性在正常文档流中偏移位置。而其层叠通过z-index属性定义。注意：position：relative的一个主要用法：方便绝对定位元素找到参照物。</code></pre><h1 id="absolute（绝对定位）"><a href="#absolute（绝对定位）" class="headerlink" title="absolute（绝对定位）"></a>absolute（绝对定位）</h1><pre><code>定义：设置为绝对定位的元素框从文档流完全删除，并相对于最近的已定位祖先元素定位，如果元素没有已定位的祖先元素，那么它的位置相对于最初的包含块（即body元素）。元素原先在正常文档流中所占的空间会关闭，就好像该元素原来不存在一样。元素定位后生成一个块级框，而不论原来它在正常流中生成何种类型的框。重点：如果父级设置了position属性，例如position:relative;，那么子元素就会以父级的左上角为原始点进行定位。这样能很好的解决自适应网站的标签偏离问题，即父级为自适应的，那我子元素就设置position:absolute;父元素设置position:relative;，然后Top、Right、Bottom、Left用百分比宽度表示。另外，对象脱离正常文档流，使用top，right，bottom，left等属性进行绝对定位。而其层叠通过z-index属性定义。</code></pre><p>fixed（固定）</p><pre><code>fixed：对象脱离正常文档流，使用top，right，bottom，left等属性以窗口为参考点进行定位，当出现滚动条时，对象不会随着滚动。而其层叠通过z-index属性 定义。 注意点： 一个元素若设置了 position:absolute | fixed; 则该元素就不能设置float。这 是一个常识性的知识点，因为这是两个不同的流，一个是浮动流，另一个是“定位流”。但是 relative 却可以。因为它原本所占的空间仍然占据文档流。在理论上，被设置为fixed的元素会被定位于浏览器窗口的一个指定坐标，不论窗口是否滚动，它都会固定在这个位置。</code></pre><h2 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;  &lt;title&gt;返回顶部示例&lt;/title&gt;  &lt;style&gt;    * {      margin: 0;    }    .d1 {      height: 1000px;      background-color: #eeee;    }    .scrollTop {      background-color: darkgrey;      padding: 10px;      text-align: center;      position: fixed;      right: 10px;      bottom: 20px;    }  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;d1&quot;&gt;111&lt;/div&gt;&lt;div class=&quot;scrollTop&quot;&gt;返回顶部&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h1 id="z-index"><a href="#z-index" class="headerlink" title="z-index"></a>z-index</h1><pre><code>#i2 {  z-index: 999;}设置对象的层叠顺序，数值大的会覆盖在数值小的标签之上。z-index 仅能在定位元素上奏效。 自定义模态框示例</code></pre><h1 id="opacity"><a href="#opacity" class="headerlink" title="opacity"></a>opacity</h1><pre><code>用来定义透明效果。取值范围是0~1，0是完全透明，1是完全不透明</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;static&quot;&gt;&lt;a href=&quot;#static&quot; class=&quot;headerlink&quot; title=&quot;static&quot;&gt;&lt;/a&gt;static&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;static 默认值，无定位，不能当作绝对定位的参照物，并且设置标签对象的left、top等
      
    
    </summary>
    
      <category term="html" scheme="http://yoursite.com/categories/html/"/>
    
    
      <category term="css-Postion" scheme="http://yoursite.com/tags/css-Postion/"/>
    
  </entry>
  
  <entry>
    <title>Python面对对象</title>
    <link href="http://yoursite.com/2018/10/15/Python%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2018/10/15/Python面对对象/</id>
    <published>2018-10-15T08:17:07.413Z</published>
    <updated>2018-10-15T08:18:28.307Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python设计模式"><a href="#Python设计模式" class="headerlink" title="Python设计模式"></a>Python设计模式</h1><p>代码直戳: <a href="https://github.com/faif/python-patterns" target="_blank" rel="noopener">https://github.com/faif/python-patterns</a></p><h1 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h1><h2 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h2><p>实例 -&gt; 类 -&gt; 类工厂</p><h2 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h2><p>简单来说就是把一些具有相同方法的类再进行封装,抽象共同的方法以供调用.是工厂方法的进阶版本.</p><p>实例 -&gt; 类 -&gt; 类工厂 -&gt; 抽象工厂</p><h2 id="惰性初始化-Lazy-evaluation"><a href="#惰性初始化-Lazy-evaluation" class="headerlink" title="惰性初始化 Lazy evaluation"></a>惰性初始化 Lazy evaluation</h2><p>这个Python里可以使用@property实现,就是当调用的时候才生成.</p><h2 id="生成器-Builder"><a href="#生成器-Builder" class="headerlink" title="生成器 Builder"></a>生成器 Builder</h2><p><img src="img/builder.png" alt=""></p><p>Builder模式主要用于构建一个复杂的对象，但这个对象构建的算法是稳定的，对象中的各个部分经常变化。Builder模式主要在于应对复杂对象各个部分的频繁需求变动。但是难以应对算法的需求变动。这点一定要注意，如果用错了，会带来很多不必要的麻烦。</p><p>重点是将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。</p><p>简单的说：子对象变化较频繁，对算法相对稳定。</p><h2 id="单例模式-Singleton"><a href="#单例模式-Singleton" class="headerlink" title="单例模式 Singleton"></a>单例模式 Singleton</h2><p>一个类只有一个实例</p><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>特点是通过复制一个已经存在的实例来返回新的实例,而不是新建实例.</p><p>多用于创建复杂的或者耗时的实例,因为这种情况下,复制一个已经存在的实例使程序运行更高效;或者创建值相等,只是命名不一样的同类数据.</p><h2 id="对象池-Object-pool"><a href="#对象池-Object-pool" class="headerlink" title="对象池 Object pool"></a>对象池 Object pool</h2><p>一个对象池是一组已经初始化过且可以使用的对象，而可以不用在有需求时创建和销毁对象。池的用户可以从池子中取得对象，对其进行操作处理，并在不需要时归还给池子而非销毁 而不是销毁它. </p><p>在Python内部实现了对象池技术.例如像小整型这样的数据引用非常多,创建销毁都会消耗时间,所以保存在对象池里,减少开销.</p><h1 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h1><h2 id="修饰模型-Decorator"><a href="#修饰模型-Decorator" class="headerlink" title="修饰模型 Decorator"></a>修饰模型 Decorator</h2><p>Python里就是装饰器.</p><h2 id="代理模式-Proxy"><a href="#代理模式-Proxy" class="headerlink" title="代理模式 Proxy"></a>代理模式 Proxy</h2><p>例如Python里的引用计数.</p><h1 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h1><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>迭代容器里所有的元素.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Python设计模式&quot;&gt;&lt;a href=&quot;#Python设计模式&quot; class=&quot;headerlink&quot; title=&quot;Python设计模式&quot;&gt;&lt;/a&gt;Python设计模式&lt;/h1&gt;&lt;p&gt;代码直戳: &lt;a href=&quot;https://github.com/faif
      
    
    </summary>
    
      <category term="面试题Python编程题" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98Python%E7%BC%96%E7%A8%8B%E9%A2%98/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Python基础面试题</title>
    <link href="http://yoursite.com/2018/10/15/Python%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://yoursite.com/2018/10/15/Python基础面试题/</id>
    <published>2018-10-15T08:17:07.394Z</published>
    <updated>2018-10-15T08:17:55.663Z</updated>
    
    <content type="html"><![CDATA[<!-- markdown-toc start - Don't edit this section. Run M-x markdown-toc-generate-toc again --><p><strong>Table of Contents</strong></p><ul><li><a href="#python语言特性">Python语言特性</a><ul><li><a href="#1-python的函数参数传递">1 Python的函数参数传递</a></li><li><a href="#2-python中的元类metaclass">2 Python中的元类(metaclass)</a></li><li><a href="#3-staticmethod和classmethod">3 @staticmethod和@classmethod</a></li><li><a href="#4-类变量和实例变量">4 类变量和实例变量</a></li><li><a href="#5-python自省">5 Python自省</a></li><li><a href="#6-字典推导式">6 字典推导式</a></li><li><a href="#7-python中单下划线和双下划线">7 Python中单下划线和双下划线</a></li><li><a href="#8-字符串格式化和format">8 字符串格式化:\x和.format</a></li><li><a href="#9-迭代器和生成器">9 迭代器和生成器</a></li><li><a href="#10-args-and-kwargs">10 *args and <code>**kwargs</code></a></li><li><a href="#11-面向切面编程aop和装饰器">11 面向切面编程AOP和装饰器</a></li><li><a href="#12-鸭子类型">12 鸭子类型</a></li><li><a href="#13-python中重载">13 Python中重载</a></li><li><a href="#14-新式类和旧式类">14 新式类和旧式类</a></li><li><a href="#15-__new__和__init__的区别">15 <strong>new</strong>和<code><strong>init</strong></code>的区别</a></li><li><a href="#16-单例模式">16 单例模式</a><ul><li><a href="#1-使用__new__方法">1 使用<strong>new</strong>方法</a></li><li><a href="#2-共享属性">2 共享属性</a></li><li><a href="#3-装饰器版本">3 装饰器版本</a></li><li><a href="#4-import方法">4 import方法</a></li></ul></li><li><a href="#17-python中的作用域">17 Python中的作用域</a></li><li><a href="#18-gil线程全局锁">18 GIL线程全局锁</a></li><li><a href="#19-协程">19 协程</a></li><li><a href="#20-闭包">20 闭包</a></li><li><a href="#21-lambda函数">21 lambda函数</a></li><li><a href="#22-python函数式编程">22 Python函数式编程</a></li><li><a href="#23-python里的拷贝">23 Python里的拷贝</a></li><li><a href="#24-python垃圾回收机制">24 Python垃圾回收机制</a><ul><li><a href="#1-引用计数">1 引用计数</a></li><li><a href="#2-标记-清除机制">2 标记-清除机制</a></li><li><a href="#3-分代技术">3 分代技术</a></li></ul></li><li><a href="#25-python的list">25 Python的List</a></li><li><a href="#26-python的is">26 Python的is</a></li><li><a href="#27-readreadline和readlines">27 read,readline和readlines</a></li><li><a href="#28-python2和3的区别">28 Python2和3的区别</a></li><li><a href="#29-super-init">29 super init</a></li><li><a href="#30-range-and-xrange">30 range and xrange</a></li></ul></li><li><a href="#操作系统">操作系统</a><ul><li><a href="#1-selectpoll和epoll">1 select,poll和epoll</a></li><li><a href="#2-调度算法">2 调度算法</a></li><li><a href="#3-死锁">3 死锁</a></li><li><a href="#4-程序编译与链接">4 程序编译与链接</a><ul><li><a href="#1-预处理">1 预处理</a></li><li><a href="#2-编译">2 编译</a></li><li><a href="#3-汇编">3 汇编</a></li><li><a href="#4-链接">4 链接</a></li></ul></li><li><a href="#5-静态链接和动态链接">5 静态链接和动态链接</a></li><li><a href="#6-虚拟内存技术">6 虚拟内存技术</a></li><li><a href="#7-分页和分段">7 分页和分段</a><ul><li><a href="#分页与分段的主要区别">分页与分段的主要区别</a></li></ul></li><li><a href="#8-页面置换算法">8 页面置换算法</a></li><li><a href="#9-边沿触发和水平触发">9 边沿触发和水平触发</a></li></ul></li><li><a href="#数据库">数据库</a><ul><li><a href="#1-事务">1 事务</a></li><li><a href="#2-数据库索引">2 数据库索引</a></li><li><a href="#3-redis原理">3 Redis原理</a><ul><li><a href="#redis是什么">Redis是什么？</a></li><li><a href="#redis数据库">Redis数据库</a></li><li><a href="#redis缺点">Redis缺点</a></li></ul></li><li><a href="#4-乐观锁和悲观锁">4 乐观锁和悲观锁</a></li><li><a href="#5-mvcc">5 MVCC</a><ul><li><a href="#mysql的innodb引擎是如何实现mvcc的"><a href="http://lib.csdn.net/base/mysql" target="_blank" rel="noopener">MySQL</a>的innodb引擎是如何实现MVCC的</a></li></ul></li><li><a href="#6-myisam和innodb">6 MyISAM和InnoDB</a></li></ul></li><li><a href="#网络">网络</a><ul><li><a href="#1-三次握手">1 三次握手</a></li><li><a href="#2-四次挥手">2 四次挥手</a></li><li><a href="#3-arp协议">3 ARP协议</a></li><li><a href="#4-urllib和urllib2的区别">4 urllib和urllib2的区别</a></li><li><a href="#5-post和get">5 Post和Get</a></li><li><a href="#6-cookie和session">6 Cookie和Session</a></li><li><a href="#7-apache和nginx的区别">7 apache和nginx的区别</a></li><li><a href="#8-网站用户密码保存">8 网站用户密码保存</a></li><li><a href="#9-http和https">9 HTTP和HTTPS</a></li><li><a href="#10-xsrf和xss">10 XSRF和XSS</a></li><li><a href="#11-幂等-idempotence">11 幂等 Idempotence</a></li><li><a href="#12-restful架构soaprpc">12 RESTful架构(SOAP,RPC)</a></li><li><a href="#13-soap">13 SOAP</a></li><li><a href="#14-rpc">14 RPC</a></li><li><a href="#15-cgi和wsgi">15 CGI和WSGI</a></li><li><a href="#16-中间人攻击">16 中间人攻击</a></li><li><a href="#17-c10k问题">17 c10k问题</a></li><li><a href="#18-socket">18 socket</a></li><li><a href="#19-浏览器缓存">19 浏览器缓存</a></li><li><a href="#20-http10和http11">20 HTTP1.0和HTTP1.1</a></li><li><a href="#21-ajax">21 Ajax</a></li></ul></li><li><a href="#nix">*NIX</a><ul><li><a href="#unix进程间通信方式ipc">unix进程间通信方式(IPC)</a></li></ul></li><li><a href="#数据结构">数据结构</a><ul><li><a href="#1-红黑树">1 红黑树</a></li></ul></li><li><a href="#编程题">编程题</a><ul><li><a href="#1-台阶问题斐波那契">1 台阶问题/斐波那契</a></li><li><a href="#2-变态台阶问题">2 变态台阶问题</a></li><li><a href="#3-矩形覆盖">3 矩形覆盖</a></li><li><a href="#4-杨氏矩阵查找">4 杨氏矩阵查找</a></li><li><a href="#5-去除列表中的重复元素">5 去除列表中的重复元素</a></li><li><a href="#6-链表成对调换">6 链表成对调换</a></li><li><a href="#7-创建字典的方法">7 创建字典的方法</a><ul><li><a href="#1-直接创建">1 直接创建</a></li><li><a href="#2-工厂方法">2 工厂方法</a></li><li><a href="#3-fromkeys方法">3 fromkeys()方法</a></li></ul></li><li><a href="#8-合并两个有序列表">8 合并两个有序列表</a></li><li><a href="#9-交叉链表求交点">9 交叉链表求交点</a></li><li><a href="#10-二分查找">10 二分查找</a></li><li><a href="#11-快排">11 快排</a></li><li><a href="#12-找零问题">12 找零问题</a></li><li><a href="#13-广度遍历和深度遍历二叉树">13 广度遍历和深度遍历二叉树</a></li><li><a href="#17-前中后序遍历">17 前中后序遍历</a></li><li><a href="#18-求最大树深">18 求最大树深</a></li><li><a href="#19-求两棵树是否相同">19 求两棵树是否相同</a></li><li><a href="#20-前序中序求后序">20 前序中序求后序</a></li><li><a href="#21-单链表逆置">21 单链表逆置</a></li><li><a href="#22-两个字符串是否是变位词">22 两个字符串是否是变位词</a></li><li><a href="#23-动态规划问题">23 动态规划问题</a></li></ul></li></ul><!-- markdown-toc end --><h1 id="Python语言特性"><a href="#Python语言特性" class="headerlink" title="Python语言特性"></a>Python语言特性</h1><h2 id="1-Python的函数参数传递"><a href="#1-Python的函数参数传递" class="headerlink" title="1 Python的函数参数传递"></a>1 Python的函数参数传递</h2><p>看两个例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(a)</span>:</span></span><br><span class="line">    a = <span class="number">2</span></span><br><span class="line">fun(a)</span><br><span class="line"><span class="keyword">print</span> a  <span class="comment"># 1</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(a)</span>:</span></span><br><span class="line">    a.append(<span class="number">1</span>)</span><br><span class="line">fun(a)</span><br><span class="line"><span class="keyword">print</span> a  <span class="comment"># [1]</span></span><br></pre></td></tr></table></figure><p>所有的变量都可以理解是内存中一个对象的“引用”，或者，也可以看似c中void*的感觉。</p><p>通过<code>id</code>来看引用<code>a</code>的内存地址可以比较理解：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(a)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"func_in"</span>,id(a)   <span class="comment"># func_in 41322472</span></span><br><span class="line">    a = <span class="number">2</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"re-point"</span>,id(a), id(<span class="number">2</span>)   <span class="comment"># re-point 41322448 41322448</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"func_out"</span>,id(a), id(<span class="number">1</span>)  <span class="comment"># func_out 41322472 41322472</span></span><br><span class="line">fun(a)</span><br><span class="line"><span class="keyword">print</span> a  <span class="comment"># 1</span></span><br></pre></td></tr></table></figure><p>注：具体的值在不同电脑上运行时可能不同。</p><p>可以看到，在执行完<code>a = 2</code>之后，<code>a</code>引用中保存的值，即内存地址发生变化，由原来<code>1</code>对象的所在的地址变成了<code>2</code>这个实体对象的内存地址。</p><p>而第2个例子<code>a</code>引用保存的内存值就不会发生变化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(a)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"func_in"</span>,id(a)  <span class="comment"># func_in 53629256</span></span><br><span class="line">    a.append(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"func_out"</span>,id(a)     <span class="comment"># func_out 53629256</span></span><br><span class="line">fun(a)</span><br><span class="line"><span class="keyword">print</span> a  <span class="comment"># [1]</span></span><br></pre></td></tr></table></figure><p>这里记住的是类型是属于对象的，而不是变量。而对象有两种,“可更改”（mutable）与“不可更改”（immutable）对象。在python中，strings, tuples, 和numbers是不可更改的对象，而 list, dict, set 等则是可以修改的对象。(这就是这个问题的重点)</p><p>当一个引用传递给函数的时候,函数自动复制一份引用,这个函数里的引用和外边的引用没有半毛关系了.所以第一个例子里函数把引用指向了一个不可变对象,当函数返回的时候,外面的引用没半毛感觉.而第二个例子就不一样了,函数内的引用指向的是可变对象,对它的操作就和定位了指针地址一样,在内存里进行修改.</p><p>如果还不明白的话,这里有更好的解释: <a href="http://stackoverflow.com/questions/986006/how-do-i-pass-a-variable-by-reference" target="_blank" rel="noopener">http://stackoverflow.com/questions/986006/how-do-i-pass-a-variable-by-reference</a></p><h2 id="2-Python中的元类-metaclass"><a href="#2-Python中的元类-metaclass" class="headerlink" title="2 Python中的元类(metaclass)"></a>2 Python中的元类(metaclass)</h2><p>这个非常的不常用,但是像ORM这种复杂的结构还是会需要的,详情请看:<a href="http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python" target="_blank" rel="noopener">http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python</a></p><h2 id="3-staticmethod和-classmethod"><a href="#3-staticmethod和-classmethod" class="headerlink" title="3 @staticmethod和@classmethod"></a>3 @staticmethod和@classmethod</h2><p>Python其实有3个方法,即静态方法(staticmethod),类方法(classmethod)和实例方法,如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"executing foo(%s)"</span>%(x)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self,x)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"executing foo(%s,%s)"</span>%(self,x)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">class_foo</span><span class="params">(cls,x)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"executing class_foo(%s,%s)"</span>%(cls,x)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">static_foo</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"executing static_foo(%s)"</span>%x</span><br><span class="line"></span><br><span class="line">a=A()</span><br></pre></td></tr></table></figure><p>这里先理解下函数参数里面的self和cls.这个self和cls是对类或者实例的绑定,对于一般的函数来说我们可以这么调用<code>foo(x)</code>,这个函数就是最常用的,它的工作跟任何东西(类,实例)无关.对于实例方法,我们知道在类里每次定义方法的时候都需要绑定这个实例,就是<code>foo(self, x)</code>,为什么要这么做呢?因为实例方法的调用离不开实例,我们需要把实例自己传给函数,调用的时候是这样的<code>a.foo(x)</code>(其实是<code>foo(a, x)</code>).类方法一样,只不过它传递的是类而不是实例,<code>A.class_foo(x)</code>.注意这里的self和cls可以替换别的参数,但是python的约定是这俩,还是不要改的好.</p><p>对于静态方法其实和普通的方法一样,不需要对谁进行绑定,唯一的区别是调用的时候需要使用<code>a.static_foo(x)</code>或者<code>A.static_foo(x)</code>来调用.</p><table><thead><tr><th style="text-align:left">\</th><th style="text-align:left">实例方法</th><th style="text-align:left">类方法</th><th style="text-align:left">静态方法</th></tr></thead><tbody><tr><td style="text-align:left">a = A()</td><td style="text-align:left">a.foo(x)</td><td style="text-align:left">a.class_foo(x)</td><td style="text-align:left">a.static_foo(x)</td></tr><tr><td style="text-align:left">A</td><td style="text-align:left">不可用</td><td style="text-align:left">A.class_foo(x)</td><td style="text-align:left">A.static_foo(x)</td></tr></tbody></table><p>更多关于这个问题:</p><ol><li><a href="http://stackoverflow.com/questions/136097/what-is-the-difference-between-staticmethod-and-classmethod-in-python" target="_blank" rel="noopener">http://stackoverflow.com/questions/136097/what-is-the-difference-between-staticmethod-and-classmethod-in-python</a></li><li><a href="https://realpython.com/blog/python/instance-class-and-static-methods-demystified/" target="_blank" rel="noopener">https://realpython.com/blog/python/instance-class-and-static-methods-demystified/</a><h2 id="4-类变量和实例变量"><a href="#4-类变量和实例变量" class="headerlink" title="4 类变量和实例变量"></a>4 类变量和实例变量</h2></li></ol><p><strong>类变量：</strong></p><blockquote><p>​    是可在类的所有实例之间共享的值（也就是说，它们不是单独分配给每个实例的）。例如下例中，num_of_instance 就是类变量，用于跟踪存在着多少个Test 的实例。</p></blockquote><p><strong>实例变量：</strong></p><blockquote><p>实例化之后，每个实例单独拥有的变量。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span><span class="params">(object)</span>:</span>  </span><br><span class="line">    num_of_instance = <span class="number">0</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span>  </span><br><span class="line">        self.name = name  </span><br><span class="line">        Test.num_of_instance += <span class="number">1</span>  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:  </span><br><span class="line">    <span class="keyword">print</span> Test.num_of_instance   <span class="comment"># 0</span></span><br><span class="line">    t1 = Test(<span class="string">'jack'</span>)  </span><br><span class="line">    <span class="keyword">print</span> Test.num_of_instance   <span class="comment"># 1</span></span><br><span class="line">    t2 = Test(<span class="string">'lucy'</span>)  </span><br><span class="line">    <span class="keyword">print</span> t1.name , t1.num_of_instance  <span class="comment"># jack 2</span></span><br><span class="line">    <span class="keyword">print</span> t2.name , t2.num_of_instance  <span class="comment"># lucy 2</span></span><br></pre></td></tr></table></figure><blockquote><p>补充的例子</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    name=<span class="string">"aaa"</span></span><br><span class="line"></span><br><span class="line">p1=Person()</span><br><span class="line">p2=Person()</span><br><span class="line">p1.name=<span class="string">"bbb"</span></span><br><span class="line"><span class="keyword">print</span> p1.name  <span class="comment"># bbb</span></span><br><span class="line"><span class="keyword">print</span> p2.name  <span class="comment"># aaa</span></span><br><span class="line"><span class="keyword">print</span> Person.name  <span class="comment"># aaa</span></span><br></pre></td></tr></table></figure><p>这里<code>p1.name=&quot;bbb&quot;</code>是实例调用了类变量,这其实和上面第一个问题一样,就是函数传参的问题,<code>p1.name</code>一开始是指向的类变量<code>name=&quot;aaa&quot;</code>,但是在实例的作用域里把类变量的引用改变了,就变成了一个实例变量,self.name不再引用Person的类变量name了.</p><p>可以看看下面的例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    name=[]</span><br><span class="line"></span><br><span class="line">p1=Person()</span><br><span class="line">p2=Person()</span><br><span class="line">p1.name.append(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">print</span> p1.name  <span class="comment"># [1]</span></span><br><span class="line"><span class="keyword">print</span> p2.name  <span class="comment"># [1]</span></span><br><span class="line"><span class="keyword">print</span> Person.name  <span class="comment"># [1]</span></span><br></pre></td></tr></table></figure><p>参考:<a href="http://stackoverflow.com/questions/6470428/catch-multiple-exceptions-in-one-line-except-block" target="_blank" rel="noopener">http://stackoverflow.com/questions/6470428/catch-multiple-exceptions-in-one-line-except-block</a></p><h2 id="5-Python自省"><a href="#5-Python自省" class="headerlink" title="5 Python自省"></a>5 Python自省</h2><p>这个也是python彪悍的特性.</p><p>自省就是面向对象的语言所写的程序在运行时,所能知道对象的类型.简单一句就是运行时能够获得对象的类型.比如type(),dir(),getattr(),hasattr(),isinstance().</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b = &#123;<span class="string">'a'</span>:<span class="number">1</span>,<span class="string">'b'</span>:<span class="number">2</span>,<span class="string">'c'</span>:<span class="number">3</span>&#125;</span><br><span class="line">c = <span class="keyword">True</span></span><br><span class="line"><span class="keyword">print</span> type(a),type(b),type(c) <span class="comment"># &lt;type 'list'&gt; &lt;type 'dict'&gt; &lt;type 'bool'&gt;</span></span><br><span class="line"><span class="keyword">print</span> isinstance(a,list)  <span class="comment"># True</span></span><br></pre></td></tr></table></figure><h2 id="6-字典推导式"><a href="#6-字典推导式" class="headerlink" title="6 字典推导式"></a>6 字典推导式</h2><p>可能你见过列表推导时,却没有见过字典推导式,在2.7中才加入的:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;key: value <span class="keyword">for</span> (key, value) <span class="keyword">in</span> iterable&#125;</span><br></pre></td></tr></table></figure><h2 id="7-Python中单下划线和双下划线"><a href="#7-Python中单下划线和双下划线" class="headerlink" title="7 Python中单下划线和双下划线"></a>7 Python中单下划线和双下划线</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>            self.__superprivate = <span class="string">"Hello"</span></span><br><span class="line"><span class="meta">... </span>            self._semiprivate = <span class="string">", world!"</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mc = MyClass()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> mc.__superprivate</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: myClass instance has no attribute <span class="string">'__superprivate'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> mc._semiprivate</span><br><span class="line">, world!</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> mc.__dict__</span><br><span class="line">&#123;<span class="string">'_MyClass__superprivate'</span>: <span class="string">'Hello'</span>, <span class="string">'_semiprivate'</span>: <span class="string">', world!'</span>&#125;</span><br></pre></td></tr></table></figure><p><code>__foo__</code>:一种约定,Python内部的名字,用来区别其他用户自定义的命名,以防冲突，就是例如<code>__init__()</code>,<code>__del__()</code>,<code>__call__()</code>这些特殊方法</p><p><code>_foo</code>:一种约定,用来指定变量私有.程序员用来指定私有变量的一种方式.不能用from module import * 导入，其他方面和公有一样访问；</p><p><code>__foo</code>:这个有真正的意义:解析器用<code>_classname__foo</code>来代替这个名字,以区别和其他类相同的命名,它无法直接像公有成员一样随便访问,通过对象名._类名__xxx这样的方式可以访问.</p><p>详情见:<a href="http://stackoverflow.com/questions/1301346/the-meaning-of-a-single-and-a-double-underscore-before-an-object-name-in-python" target="_blank" rel="noopener">http://stackoverflow.com/questions/1301346/the-meaning-of-a-single-and-a-double-underscore-before-an-object-name-in-python</a></p><p>或者: <a href="http://www.zhihu.com/question/19754941" target="_blank" rel="noopener">http://www.zhihu.com/question/19754941</a></p><h2 id="8-字符串格式化-和-format"><a href="#8-字符串格式化-和-format" class="headerlink" title="8 字符串格式化:%和.format"></a>8 字符串格式化:%和.format</h2><p>.format在许多方面看起来更便利.对于<code>%</code>最烦人的是它无法同时传递一个变量和元组.你可能会想下面的代码不会有什么问题:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;hi there %s&quot; % name</span><br></pre></td></tr></table></figure><p>但是,如果name恰好是(1,2,3),它将会抛出一个TypeError异常.为了保证它总是正确的,你必须这样做:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;hi there %s&quot; % (name,)   # 提供一个单元素的数组而不是一个参数</span><br></pre></td></tr></table></figure><p>但是有点丑..format就没有这些问题.你给的第二个问题也是这样,.format好看多了.</p><p>你为什么不用它?</p><ul><li>不知道它(在读这个之前)</li><li>为了和Python2.5兼容(譬如logging库建议使用<code>%</code>(<a href="https://github.com/taizilongxu/interview_python/issues/4" target="_blank" rel="noopener">issue #4</a>))</li></ul><p><a href="http://stackoverflow.com/questions/5082452/python-string-formatting-vs-format" target="_blank" rel="noopener">http://stackoverflow.com/questions/5082452/python-string-formatting-vs-format</a></p><h2 id="9-迭代器和生成器"><a href="#9-迭代器和生成器" class="headerlink" title="9 迭代器和生成器"></a>9 迭代器和生成器</h2><p>这个是stackoverflow里python排名第一的问题,值得一看: <a href="http://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do-in-python" target="_blank" rel="noopener">http://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do-in-python</a></p><p>这是中文版: <a href="http://taizilongxu.gitbooks.io/stackoverflow-about-python/content/1/README.html" target="_blank" rel="noopener">http://taizilongxu.gitbooks.io/stackoverflow-about-python/content/1/README.html</a></p><p>这里有个关于生成器的创建问题面试官有考：<br>问：  将列表生成式中[]改成() 之后数据结构是否改变？<br>答案：是，从列表变为生成器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = [x*x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = (x*x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at <span class="number">0x0000028F8B774200</span>&gt;</span><br></pre></td></tr></table></figure><p>通过列表生成式，可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含百万元素的列表，不仅是占用很大的内存空间，如：我们只需要访问前面的几个元素，后面大部分元素所占的空间都是浪费的。因此，没有必要创建完整的列表（节省大量内存空间）。在Python中，我们可以采用生成器：边循环，边计算的机制—&gt;generator</p><h2 id="10-args-and-kwargs"><a href="#10-args-and-kwargs" class="headerlink" title="10 *args and **kwargs"></a>10 <code>*args</code> and <code>**kwargs</code></h2><p>用<code>*args</code>和<code>**kwargs</code>只是为了方便并没有强制使用它们.</p><p>当你不确定你的函数里将要传递多少参数时你可以用<code>*args</code>.例如,它可以传递任意数量的参数:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">print_everything</span><span class="params">(*args)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> count, thing <span class="keyword">in</span> enumerate(args):</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">print</span> <span class="string">'&#123;0&#125;. &#123;1&#125;'</span>.format(count, thing)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print_everything(<span class="string">'apple'</span>, <span class="string">'banana'</span>, <span class="string">'cabbage'</span>)</span><br><span class="line"><span class="number">0.</span> apple</span><br><span class="line"><span class="number">1.</span> banana</span><br><span class="line"><span class="number">2.</span> cabbage</span><br></pre></td></tr></table></figure><p>相似的,<code>**kwargs</code>允许你使用没有事先定义的参数名:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">table_things</span><span class="params">(**kwargs)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> name, value <span class="keyword">in</span> kwargs.items():</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">print</span> <span class="string">'&#123;0&#125; = &#123;1&#125;'</span>.format(name, value)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>table_things(apple = <span class="string">'fruit'</span>, cabbage = <span class="string">'vegetable'</span>)</span><br><span class="line">cabbage = vegetable</span><br><span class="line">apple = fruit</span><br></pre></td></tr></table></figure><p>你也可以混着用.命名参数首先获得参数值然后所有的其他参数都传递给<code>*args</code>和<code>**kwargs</code>.命名参数在列表的最前端.例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def table_things(titlestring, **kwargs)</span><br></pre></td></tr></table></figure><p><code>*args</code>和<code>**kwargs</code>可以同时在函数的定义中,但是<code>*args</code>必须在<code>**kwargs</code>前面.</p><p>当调用函数时你也可以用<code>*</code>和<code>**</code>语法.例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">print_three_things</span><span class="params">(a, b, c)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> <span class="string">'a = &#123;0&#125;, b = &#123;1&#125;, c = &#123;2&#125;'</span>.format(a,b,c)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mylist = [<span class="string">'aardvark'</span>, <span class="string">'baboon'</span>, <span class="string">'cat'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print_three_things(*mylist)</span><br><span class="line"></span><br><span class="line">a = aardvark, b = baboon, c = cat</span><br></pre></td></tr></table></figure><p>就像你看到的一样,它可以传递列表(或者元组)的每一项并把它们解包.注意必须与它们在函数里的参数相吻合.当然,你也可以在函数定义或者函数调用时用*.</p><p><a href="http://stackoverflow.com/questions/3394835/args-and-kwargs" target="_blank" rel="noopener">http://stackoverflow.com/questions/3394835/args-and-kwargs</a></p><h2 id="11-面向切面编程AOP和装饰器"><a href="#11-面向切面编程AOP和装饰器" class="headerlink" title="11 面向切面编程AOP和装饰器"></a>11 面向切面编程AOP和装饰器</h2><p>这个AOP一听起来有点懵,同学面阿里的时候就被问懵了…</p><p>装饰器是一个很著名的设计模式，经常被用于有切面需求的场景，较为经典的有插入日志、性能测试、事务处理等。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量函数中与函数功能本身无关的雷同代码并继续重用。概括的讲，<strong>装饰器的作用就是为已经存在的对象添加额外的功能。</strong></p><p>这个问题比较大,推荐: <a href="http://stackoverflow.com/questions/739654/how-can-i-make-a-chain-of-function-decorators-in-python" target="_blank" rel="noopener">http://stackoverflow.com/questions/739654/how-can-i-make-a-chain-of-function-decorators-in-python</a></p><p>中文: <a href="http://taizilongxu.gitbooks.io/stackoverflow-about-python/content/3/README.html" target="_blank" rel="noopener">http://taizilongxu.gitbooks.io/stackoverflow-about-python/content/3/README.html</a></p><h2 id="12-鸭子类型"><a href="#12-鸭子类型" class="headerlink" title="12 鸭子类型"></a>12 鸭子类型</h2><p>“当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。”</p><p>我们并不关心对象是什么类型，到底是不是鸭子，只关心行为。</p><p>比如在python中，有很多file-like的东西，比如StringIO,GzipFile,socket。它们有很多相同的方法，我们把它们当作文件使用。</p><p>又比如list.extend()方法中,我们并不关心它的参数是不是list,只要它是可迭代的,所以它的参数可以是list/tuple/dict/字符串/生成器等.</p><p>鸭子类型在动态语言中经常使用，非常灵活，使得python不想java那样专门去弄一大堆的设计模式。</p><h2 id="13-Python中重载"><a href="#13-Python中重载" class="headerlink" title="13 Python中重载"></a>13 Python中重载</h2><p>引自知乎:<a href="http://www.zhihu.com/question/20053359" target="_blank" rel="noopener">http://www.zhihu.com/question/20053359</a></p><p>函数重载主要是为了解决两个问题。</p><ol><li>可变参数类型。</li><li>可变参数个数。</li></ol><p>另外，一个基本的设计原则是，仅仅当两个函数除了参数类型和参数个数不同以外，其功能是完全相同的，此时才使用函数重载，如果两个函数的功能其实不同，那么不应当使用重载，而应当使用一个名字不同的函数。</p><p>好吧，那么对于情况 1 ，函数功能相同，但是参数类型不同，python 如何处理？答案是根本不需要处理，因为 python 可以接受任何类型的参数，如果函数的功能相同，那么不同的参数类型在 python 中很可能是相同的代码，没有必要做成两个不同函数。</p><p>那么对于情况 2 ，函数功能相同，但参数个数不同，python 如何处理？大家知道，答案就是缺省参数。对那些缺少的参数设定为缺省参数即可解决问题。因为你假设函数功能相同，那么那些缺少的参数终归是需要用的。</p><p>好了，鉴于情况 1 跟 情况 2 都有了解决方案，python 自然就不需要函数重载了。</p><h2 id="14-新式类和旧式类"><a href="#14-新式类和旧式类" class="headerlink" title="14 新式类和旧式类"></a>14 新式类和旧式类</h2><p>这个面试官问了,我说了老半天,不知道他问的真正意图是什么.</p><p><a href="http://stackoverflow.com/questions/54867/what-is-the-difference-between-old-style-and-new-style-classes-in-python" target="_blank" rel="noopener">stackoverflow</a></p><p>这篇文章很好的介绍了新式类的特性: <a href="http://www.cnblogs.com/btchenguang/archive/2012/09/17/2689146.html" target="_blank" rel="noopener">http://www.cnblogs.com/btchenguang/archive/2012/09/17/2689146.html</a></p><p>新式类很早在2.2就出现了,所以旧式类完全是兼容的问题,Python3里的类全部都是新式类.这里有一个MRO问题可以了解下(新式类是广度优先,旧式类是深度优先),&lt;Python核心编程&gt;里讲的也很多.</p><blockquote><p>一个旧式类的深度优先的例子</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo1</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"A"</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo2</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo1</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"C"</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span><span class="params">(B, C)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">d = D()</span><br><span class="line">d.foo1()</span><br><span class="line"></span><br><span class="line"><span class="comment"># A</span></span><br></pre></td></tr></table></figure><p><strong>按照经典类的查找顺序<code>从左到右深度优先</code>的规则，在访问<code>d.foo1()</code>的时候,D这个类是没有的..那么往上查找,先找到B,里面没有,深度优先,访问A,找到了foo1(),所以这时候调用的是A的foo1()，从而导致C重写的foo1()被绕过</strong></p><h2 id="15-new-和-init-的区别"><a href="#15-new-和-init-的区别" class="headerlink" title="15 __new__和__init__的区别"></a>15 <code>__new__</code>和<code>__init__</code>的区别</h2><p>这个<code>__new__</code>确实很少见到,先做了解吧.</p><ol><li><code>__new__</code>是一个静态方法,而<code>__init__</code>是一个实例方法.</li><li><code>__new__</code>方法会返回一个创建的实例,而<code>__init__</code>什么都不返回.</li><li>只有在<code>__new__</code>返回一个cls的实例时后面的<code>__init__</code>才能被调用.</li><li>当创建一个新实例时调用<code>__new__</code>,初始化一个实例时用<code>__init__</code>.</li></ol><p><a href="http://stackoverflow.com/questions/674304/pythons-use-of-new-and-init" target="_blank" rel="noopener">stackoverflow</a></p><p>ps: <code>__metaclass__</code>是创建类时起作用.所以我们可以分别使用<code>__metaclass__</code>,<code>__new__</code>和<code>__init__</code>来分别在类创建,实例创建和实例初始化的时候做一些小手脚.</p><h2 id="16-单例模式"><a href="#16-单例模式" class="headerlink" title="16 单例模式"></a>16 单例模式</h2><blockquote><p>​    单例模式是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例类的特殊类。通过单例模式可以保证系统中一个类只有一个实例而且该实例易于外界访问，从而方便对实例个数的控制并节约系统资源。如果希望在系统中某个类的对象只能存在一个，单例模式是最好的解决方案。</p><p><code>__new__()</code>在<code>__init__()</code>之前被调用，用于生成实例对象。利用这个方法和类的属性的特点可以实现设计模式的单例模式。单例模式是指创建唯一对象，单例模式设计的类只能实例<br><strong>这个绝对常考啊.绝对要记住1~2个方法,当时面试官是让手写的.</strong></p></blockquote><h3 id="1-使用-new-方法"><a href="#1-使用-new-方法" class="headerlink" title="1 使用__new__方法"></a>1 使用<code>__new__</code>方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kw)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(cls, <span class="string">'_instance'</span>):</span><br><span class="line">            orig = super(Singleton, cls)</span><br><span class="line">            cls._instance = orig.__new__(cls, *args, **kw)</span><br><span class="line">        <span class="keyword">return</span> cls._instance</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(Singleton)</span>:</span></span><br><span class="line">    a = <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="2-共享属性"><a href="#2-共享属性" class="headerlink" title="2 共享属性"></a>2 共享属性</h3><p>创建实例时把所有实例的<code>__dict__</code>指向同一个字典,这样它们具有相同的属性和方法.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Borg</span><span class="params">(object)</span>:</span></span><br><span class="line">    _state = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kw)</span>:</span></span><br><span class="line">        ob = super(Borg, cls).__new__(cls, *args, **kw)</span><br><span class="line">        ob.__dict__ = cls._state</span><br><span class="line">        <span class="keyword">return</span> ob</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass2</span><span class="params">(Borg)</span>:</span></span><br><span class="line">    a = <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="3-装饰器版本"><a href="#3-装饰器版本" class="headerlink" title="3 装饰器版本"></a>3 装饰器版本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleton</span><span class="params">(cls)</span>:</span></span><br><span class="line">    instances = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getinstance</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> instances:</span><br><span class="line">            instances[cls] = cls(*args, **kw)</span><br><span class="line">        <span class="keyword">return</span> instances[cls]</span><br><span class="line">    <span class="keyword">return</span> getinstance</span><br><span class="line"></span><br><span class="line"><span class="meta">@singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><h3 id="4-import方法"><a href="#4-import方法" class="headerlink" title="4 import方法"></a>4 import方法</h3><p>作为python的模块是天然的单例模式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mysingleton.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">My_Singleton</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">my_singleton = My_Singleton()</span><br><span class="line"></span><br><span class="line"><span class="comment"># to use</span></span><br><span class="line"><span class="keyword">from</span> mysingleton <span class="keyword">import</span> my_singleton</span><br><span class="line"></span><br><span class="line">my_singleton.foo()</span><br></pre></td></tr></table></figure><p><strong><a href="http://python.jobbole.com/87294/" target="_blank" rel="noopener">单例模式伯乐在线详细解释</a></strong></p><h2 id="17-Python中的作用域"><a href="#17-Python中的作用域" class="headerlink" title="17 Python中的作用域"></a>17 Python中的作用域</h2><p>Python 中，一个变量的作用域总是由在代码中被赋值的地方所决定的。</p><p>当 Python 遇到一个变量的话他会按照这样的顺序进行搜索：</p><p>本地作用域（Local）→当前作用域被嵌入的本地作用域（Enclosing locals）→全局/模块作用域（Global）→内置作用域（Built-in）</p><h2 id="18-GIL线程全局锁"><a href="#18-GIL线程全局锁" class="headerlink" title="18 GIL线程全局锁"></a>18 GIL线程全局锁</h2><p>线程全局锁(Global Interpreter Lock),即Python为了保证线程安全而采取的独立线程运行的限制,说白了就是一个核只能在同一时间运行一个线程.<strong>对于io密集型任务，python的多线程起到作用，但对于cpu密集型任务，python的多线程几乎占不到任何优势，还有可能因为争夺资源而变慢。</strong></p><p>见<a href="http://www.oschina.net/translate/pythons-hardest-problem" target="_blank" rel="noopener">Python 最难的问题</a></p><p>解决办法就是多进程和下面的协程(协程也只是单CPU,但是能减小切换代价提升性能).</p><h2 id="19-协程"><a href="#19-协程" class="headerlink" title="19 协程"></a>19 协程</h2><p>知乎被问到了,呵呵哒,跪了</p><p>简单点说协程是进程和线程的升级版,进程和线程都面临着内核态和用户态的切换问题而耗费许多切换时间,而协程就是用户自己控制切换的时机,不再需要陷入系统的内核态.</p><p>Python里最常见的yield就是协程的思想!可以查看第九个问题.</p><h2 id="20-闭包"><a href="#20-闭包" class="headerlink" title="20 闭包"></a>20 闭包</h2><p>闭包(closure)是函数式编程的重要的语法结构。闭包也是一种组织代码的结构，它同样提高了代码的可重复使用性。</p><p>当一个内嵌函数引用其外部作作用域的变量,我们就会得到一个闭包. 总结一下,创建一个闭包必须满足以下几点:</p><ol><li>必须有一个内嵌函数</li><li>内嵌函数必须引用外部函数中的变量</li><li>外部函数的返回值必须是内嵌函数</li></ol><p>感觉闭包还是有难度的,几句话是说不明白的,还是查查相关资料.</p><p>重点是函数运行后并不会被撤销,就像16题的instance字典一样,当函数运行完后,instance并不被销毁,而是继续留在内存空间里.这个功能类似类里的类变量,只不过迁移到了函数上.</p><p>闭包就像个空心球一样,你知道外面和里面,但你不知道中间是什么样.</p><h2 id="21-lambda函数"><a href="#21-lambda函数" class="headerlink" title="21 lambda函数"></a>21 lambda函数</h2><p>其实就是一个匿名函数,为什么叫lambda?因为和后面的函数式编程有关.</p><p>推荐: <a href="http://www.zhihu.com/question/20125256" target="_blank" rel="noopener">知乎</a></p><h2 id="22-Python函数式编程"><a href="#22-Python函数式编程" class="headerlink" title="22 Python函数式编程"></a>22 Python函数式编程</h2><p>这个需要适当的了解一下吧,毕竟函数式编程在Python中也做了引用.</p><p>推荐: <a href="http://coolshell.cn/articles/10822.html" target="_blank" rel="noopener">酷壳</a></p><p>python中函数式编程支持:</p><p>filter 函数的功能相当于过滤器。调用一个布尔函数<code>bool_func</code>来迭代遍历每个seq中的元素；返回一个使<code>bool_seq</code>返回值为true的元素的序列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">&gt;&gt;&gt;b = filter(<span class="keyword">lambda</span> x: x &gt; <span class="number">5</span>, a)</span><br><span class="line">&gt;&gt;&gt;<span class="keyword">print</span> b</span><br><span class="line">&gt;&gt;&gt;[<span class="number">6</span>,<span class="number">7</span>]</span><br></pre></td></tr></table></figure><p>map函数是对一个序列的每个项依次执行函数，下面是对一个序列每个项都乘以2：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = map(<span class="keyword">lambda</span> x:x*<span class="number">2</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(a)</span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure><p>reduce函数是对一个序列的每个项迭代调用函数，下面是求3的阶乘：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(<span class="keyword">lambda</span> x,y:x*y,range(<span class="number">1</span>,<span class="number">4</span>))</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><h2 id="23-Python里的拷贝"><a href="#23-Python里的拷贝" class="headerlink" title="23 Python里的拷贝"></a>23 Python里的拷贝</h2><p>引用和copy(),deepcopy()的区别</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>]]  <span class="comment">#原始对象</span></span><br><span class="line"></span><br><span class="line">b = a  <span class="comment">#赋值，传对象的引用</span></span><br><span class="line">c = copy.copy(a)  <span class="comment">#对象拷贝，浅拷贝</span></span><br><span class="line">d = copy.deepcopy(a)  <span class="comment">#对象拷贝，深拷贝</span></span><br><span class="line"></span><br><span class="line">a.append(<span class="number">5</span>)  <span class="comment">#修改对象a</span></span><br><span class="line">a[<span class="number">4</span>].append(<span class="string">'c'</span>)  <span class="comment">#修改对象a中的['a', 'b']数组对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">'a = '</span>, a</span><br><span class="line"><span class="keyword">print</span> <span class="string">'b = '</span>, b</span><br><span class="line"><span class="keyword">print</span> <span class="string">'c = '</span>, c</span><br><span class="line"><span class="keyword">print</span> <span class="string">'d = '</span>, d</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">a =  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>], <span class="number">5</span>]</span><br><span class="line">b =  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>], <span class="number">5</span>]</span><br><span class="line">c =  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]]</span><br><span class="line">d =  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>]]</span><br></pre></td></tr></table></figure><h2 id="24-Python垃圾回收机制"><a href="#24-Python垃圾回收机制" class="headerlink" title="24 Python垃圾回收机制"></a>24 Python垃圾回收机制</h2><p>Python GC主要使用引用计数（reference counting）来跟踪和回收垃圾。在引用计数的基础上，通过“标记-清除”（mark and sweep）解决容器对象可能产生的循环引用问题，通过“分代回收”（generation collection）以空间换时间的方法提高垃圾回收效率。</p><h3 id="1-引用计数"><a href="#1-引用计数" class="headerlink" title="1 引用计数"></a>1 引用计数</h3><p>PyObject是每个对象必有的内容，其中<code>ob_refcnt</code>就是做为引用计数。当一个对象有新的引用时，它的<code>ob_refcnt</code>就会增加，当引用它的对象被删除，它的<code>ob_refcnt</code>就会减少.引用计数为0时，该对象生命就结束了。</p><p>优点:</p><ol><li>简单</li><li>实时性</li></ol><p>缺点:</p><ol><li>维护引用计数消耗资源</li><li>循环引用</li></ol><h3 id="2-标记-清除机制"><a href="#2-标记-清除机制" class="headerlink" title="2 标记-清除机制"></a>2 标记-清除机制</h3><p>基本思路是先按需分配，等到没有空闲内存的时候从寄存器和程序栈上的引用出发，遍历以对象为节点、以引用为边构成的图，把所有可以访问到的对象打上标记，然后清扫一遍内存空间，把所有没标记的对象释放。</p><h3 id="3-分代技术"><a href="#3-分代技术" class="headerlink" title="3 分代技术"></a>3 分代技术</h3><p>分代回收的整体思想是：将系统中的所有内存块根据其存活时间划分为不同的集合，每个集合就成为一个“代”，垃圾收集频率随着“代”的存活时间的增大而减小，存活时间通常利用经过几次垃圾回收来度量。</p><p>Python默认定义了三代对象集合，索引数越大，对象存活时间越长。</p><p>举例：<br>当某些内存块M经过了3次垃圾收集的清洗之后还存活时，我们就将内存块M划到一个集合A中去，而新分配的内存都划分到集合B中去。当垃圾收集开始工作时，大多数情况都只对集合B进行垃圾回收，而对集合A进行垃圾回收要隔相当长一段时间后才进行，这就使得垃圾收集机制需要处理的内存少了，效率自然就提高了。在这个过程中，集合B中的某些内存块由于存活时间长而会被转移到集合A中，当然，集合A中实际上也存在一些垃圾，这些垃圾的回收会因为这种分代的机制而被延迟。</p><h2 id="25-Python的List"><a href="#25-Python的List" class="headerlink" title="25 Python的List"></a>25 Python的List</h2><p>推荐: <a href="http://www.jianshu.com/p/J4U6rR" target="_blank" rel="noopener">http://www.jianshu.com/p/J4U6rR</a></p><h2 id="26-Python的is"><a href="#26-Python的is" class="headerlink" title="26 Python的is"></a>26 Python的is</h2><p>is是对比地址,==是对比值</p><h2 id="27-read-readline和readlines"><a href="#27-read-readline和readlines" class="headerlink" title="27 read,readline和readlines"></a>27 read,readline和readlines</h2><ul><li>read        读取整个文件</li><li>readline    读取下一行,使用生成器方法</li><li>readlines   读取整个文件到一个迭代器以供我们遍历</li></ul><h2 id="28-Python2和3的区别"><a href="#28-Python2和3的区别" class="headerlink" title="28 Python2和3的区别"></a>28 Python2和3的区别</h2><p>推荐：<a href="http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/" target="_blank" rel="noopener">Python 2.7.x 与 Python 3.x 的主要差异</a></p><h2 id="29-super-init"><a href="#29-super-init" class="headerlink" title="29 super init"></a>29 super init</h2><p>super() lets you avoid referring to the base class explicitly, which can be nice. But the main advantage comes with multiple inheritance, where all sorts of fun stuff can happen. See the standard docs on super if you haven’t already.</p><p>Note that the syntax changed in Python 3.0: you can just say super().<code>__init__</code>() instead of super(ChildB, self).<code>__init__</code>() which IMO is quite a bit nicer.</p><p><a href="http://stackoverflow.com/questions/576169/understanding-python-super-with-init-methods" target="_blank" rel="noopener">http://stackoverflow.com/questions/576169/understanding-python-super-with-init-methods</a></p><p><a href="http://blog.csdn.net/mrlevo520/article/details/51712440" target="_blank" rel="noopener">Python2.7中的super方法浅见</a></p><h2 id="30-range-and-xrange"><a href="#30-range-and-xrange" class="headerlink" title="30 range and xrange"></a>30 range and xrange</h2><p>都在循环时使用，xrange内存性能更好。<br>for i in range(0, 20):<br>for i in xrange(0, 20):<br>What is the difference between range and xrange functions in Python 2.X?<br> range creates a list, so if you do range(1, 10000000) it creates a list in memory with 9999999 elements.<br> xrange is a sequence object that evaluates lazily.</p><p><a href="http://stackoverflow.com/questions/94935/what-is-the-difference-between-range-and-xrange-functions-in-python-2-x" target="_blank" rel="noopener">http://stackoverflow.com/questions/94935/what-is-the-difference-between-range-and-xrange-functions-in-python-2-x</a></p><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="1-select-poll和epoll"><a href="#1-select-poll和epoll" class="headerlink" title="1 select,poll和epoll"></a>1 select,poll和epoll</h2><p>其实所有的I/O都是轮询的方法,只不过实现的层面不同罢了.</p><p>这个问题可能有点深入了,但相信能回答出这个问题是对I/O多路复用有很好的了解了.其中tornado使用的就是epoll的.</p><p><a href="http://www.cnblogs.com/Anker/p/3265058.html" target="_blank" rel="noopener">selec,poll和epoll区别总结</a></p><p>基本上select有3个缺点:</p><ol><li>连接数受限</li><li>查找配对速度慢</li><li>数据由内核拷贝到用户态</li></ol><p>poll改善了第一个缺点</p><p>epoll改了三个缺点.</p><p>关于epoll的: <a href="http://www.cnblogs.com/my_life/articles/3968782.html" target="_blank" rel="noopener">http://www.cnblogs.com/my_life/articles/3968782.html</a></p><h2 id="2-调度算法"><a href="#2-调度算法" class="headerlink" title="2 调度算法"></a>2 调度算法</h2><ol><li>先来先服务(FCFS, First Come First Serve)</li><li>短作业优先(SJF, Shortest Job First)</li><li>最高优先权调度(Priority Scheduling)</li><li>时间片轮转(RR, Round Robin)</li><li>多级反馈队列调度(multilevel feedback queue scheduling)</li></ol><p>常见的调度算法总结:<a href="http://www.jianshu.com/p/6edf8174c1eb" target="_blank" rel="noopener">http://www.jianshu.com/p/6edf8174c1eb</a></p><p>实时调度算法:</p><ol><li>最早截至时间优先 EDF</li><li>最低松弛度优先 LLF</li></ol><h2 id="3-死锁"><a href="#3-死锁" class="headerlink" title="3 死锁"></a>3 死锁</h2><p>原因:</p><ol><li>竞争资源</li><li>程序推进顺序不当</li></ol><p>必要条件:</p><ol><li>互斥条件</li><li>请求和保持条件</li><li>不剥夺条件</li><li>环路等待条件</li></ol><p>处理死锁基本方法:</p><ol><li>预防死锁(摒弃除1以外的条件)</li><li>避免死锁(银行家算法)</li><li>检测死锁(资源分配图)</li><li>解除死锁<ol><li>剥夺资源</li><li>撤销进程</li></ol></li></ol><p>死锁概念处理策略详细介绍:<a href="https://wizardforcel.gitbooks.io/wangdaokaoyan-os/content/10.html" target="_blank" rel="noopener">https://wizardforcel.gitbooks.io/wangdaokaoyan-os/content/10.html</a></p><h2 id="4-程序编译与链接"><a href="#4-程序编译与链接" class="headerlink" title="4 程序编译与链接"></a>4 程序编译与链接</h2><p>推荐: <a href="http://www.ruanyifeng.com/blog/2014/11/compiler.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/11/compiler.html</a></p><p>Bulid过程可以分解为4个步骤:预处理(Prepressing), 编译(Compilation)、汇编(Assembly)、链接(Linking)</p><p>以c语言为例:</p><h3 id="1-预处理"><a href="#1-预处理" class="headerlink" title="1 预处理"></a>1 预处理</h3><p>预编译过程主要处理那些源文件中的以“#”开始的预编译指令，主要处理规则有：</p><ol><li>将所有的“#define”删除，并展开所用的宏定义</li><li>处理所有条件预编译指令，比如“#if”、“#ifdef”、 “#elif”、“#endif”</li><li>处理“#include”预编译指令，将被包含的文件插入到该编译指令的位置，注：此过程是递归进行的</li><li>删除所有注释</li><li>添加行号和文件名标识，以便于编译时编译器产生调试用的行号信息以及用于编译时产生编译错误或警告时可显示行号</li><li>保留所有的#pragma编译器指令。</li></ol><h3 id="2-编译"><a href="#2-编译" class="headerlink" title="2 编译"></a>2 编译</h3><p>编译过程就是把预处理完的文件进行一系列的词法分析、语法分析、语义分析及优化后生成相应的汇编代码文件。这个过程是整个程序构建的核心部分。</p><h3 id="3-汇编"><a href="#3-汇编" class="headerlink" title="3 汇编"></a>3 汇编</h3><p>汇编器是将汇编代码转化成机器可以执行的指令，每一条汇编语句几乎都是一条机器指令。经过编译、链接、汇编输出的文件成为目标文件(Object File)</p><h3 id="4-链接"><a href="#4-链接" class="headerlink" title="4 链接"></a>4 链接</h3><p>链接的主要内容就是把各个模块之间相互引用的部分处理好，使各个模块可以正确的拼接。<br>链接的主要过程包块 地址和空间的分配（Address and Storage Allocation）、符号决议(Symbol Resolution)和重定位(Relocation)等步骤。</p><h2 id="5-静态链接和动态链接"><a href="#5-静态链接和动态链接" class="headerlink" title="5 静态链接和动态链接"></a>5 静态链接和动态链接</h2><p>静态链接方法：静态链接的时候，载入代码就会把程序会用到的动态代码或动态代码的地址确定下来<br>静态库的链接可以使用静态链接，动态链接库也可以使用这种方法链接导入库</p><p>动态链接方法：使用这种方式的程序并不在一开始就完成动态链接，而是直到真正调用动态库代码时，载入程序才计算(被调用的那部分)动态代码的逻辑地址，然后等到某个时候，程序又需要调用另外某块动态代码时，载入程序又去计算这部分代码的逻辑地址，所以，这种方式使程序初始化时间较短，但运行期间的性能比不上静态链接的程序</p><h2 id="6-虚拟内存技术"><a href="#6-虚拟内存技术" class="headerlink" title="6 虚拟内存技术"></a>6 虚拟内存技术</h2><p>虚拟存储器是指具有请求调入功能和置换功能,能从逻辑上对内存容量加以扩充的一种存储系统.</p><h2 id="7-分页和分段"><a href="#7-分页和分段" class="headerlink" title="7 分页和分段"></a>7 分页和分段</h2><p>分页: 用户程序的地址空间被划分成若干固定大小的区域，称为“页”，相应地，内存空间分成若干个物理块，页和块的大小相等。可将用户程序的任一页放在内存的任一块中，实现了离散分配。</p><p>分段: 将用户程序地址空间分成若干个大小不等的段，每段可以定义一组相对完整的逻辑信息。存储分配时，以段为单位，段与段在内存中可以不相邻接，也实现了离散分配。</p><h3 id="分页与分段的主要区别"><a href="#分页与分段的主要区别" class="headerlink" title="分页与分段的主要区别"></a>分页与分段的主要区别</h3><ol><li>页是信息的物理单位,分页是为了实现非连续分配,以便解决内存碎片问题,或者说分页是由于系统管理的需要.段是信息的逻辑单位,它含有一组意义相对完整的信息,分段的目的是为了更好地实现共享,满足用户的需要.</li><li>页的大小固定,由系统确定,将逻辑地址划分为页号和页内地址是由机器硬件实现的.而段的长度却不固定,决定于用户所编写的程序,通常由编译程序在对源程序进行编译时根据信息的性质来划分.</li><li>分页的作业地址空间是一维的.分段的地址空间是二维的.</li></ol><h2 id="8-页面置换算法"><a href="#8-页面置换算法" class="headerlink" title="8 页面置换算法"></a>8 页面置换算法</h2><ol><li>最佳置换算法OPT:不可能实现</li><li>先进先出FIFO</li><li>最近最久未使用算法LRU:最近一段时间里最久没有使用过的页面予以置换.</li><li>clock算法</li></ol><h2 id="9-边沿触发和水平触发"><a href="#9-边沿触发和水平触发" class="headerlink" title="9 边沿触发和水平触发"></a>9 边沿触发和水平触发</h2><p>边缘触发是指每当状态变化时发生一个 io 事件，条件触发是只要满足条件就发生一个 io 事件</p><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="1-事务"><a href="#1-事务" class="headerlink" title="1 事务"></a>1 事务</h2><p>数据库事务(Database Transaction) ，是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。<br>彻底理解数据库事务: <a href="http://www.hollischuang.com/archives/898" target="_blank" rel="noopener">http://www.hollischuang.com/archives/898</a></p><h2 id="2-数据库索引"><a href="#2-数据库索引" class="headerlink" title="2 数据库索引"></a>2 数据库索引</h2><p>推荐: <a href="http://tech.meituan.com/mysql-index.html" target="_blank" rel="noopener">http://tech.meituan.com/mysql-index.html</a></p><p><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">MySQL索引背后的数据结构及算法原理</a></p><p>聚集索引,非聚集索引,B-Tree,B+Tree,最左前缀原理</p><h2 id="3-Redis原理"><a href="#3-Redis原理" class="headerlink" title="3 Redis原理"></a>3 Redis原理</h2><h3 id="Redis是什么？"><a href="#Redis是什么？" class="headerlink" title="Redis是什么？"></a>Redis是什么？</h3><ol><li>是一个完全开源免费的key-value内存数据库 </li><li>通常被认为是一个数据结构服务器，主要是因为其有着丰富的数据结构 strings、map、 list、sets、 sorted sets</li></ol><h3 id="Redis数据库"><a href="#Redis数据库" class="headerlink" title="Redis数据库"></a>Redis数据库</h3><blockquote><p>​    通常局限点来说，Redis也以消息队列的形式存在，作为内嵌的List存在，满足实时的高并发需求。在使用缓存的时候，redis比memcached具有更多的优势，并且支持更多的数据类型，把redis当作一个中间存储系统，用来处理高并发的数据库操作</p></blockquote><ul><li>速度快：使用标准C写，所有数据都在内存中完成，读写速度分别达到10万/20万 </li><li>持久化：对数据的更新采用Copy-on-write技术，可以异步地保存到磁盘上，主要有两种策略，一是根据时间，更新次数的快照（save 300 10 ）二是基于语句追加方式(Append-only file，aof) </li><li>自动操作：对不同数据类型的操作都是自动的，很安全 </li><li>快速的主–从复制，官方提供了一个数据，Slave在21秒即完成了对Amazon网站10G key set的复制。 </li><li>Sharding技术： 很容易将数据分布到多个Redis实例中，数据库的扩展是个永恒的话题，在关系型数据库中，主要是以添加硬件、以分区为主要技术形式的纵向扩展解决了很多的应用场景，但随着web2.0、移动互联网、云计算等应用的兴起，这种扩展模式已经不太适合了，所以近年来，像采用主从配置、数据库复制形式的，Sharding这种技术把负载分布到多个特理节点上去的横向扩展方式用处越来越多。</li></ul><h3 id="Redis缺点"><a href="#Redis缺点" class="headerlink" title="Redis缺点"></a>Redis缺点</h3><ul><li>是数据库容量受到物理内存的限制,不能用作海量数据的高性能读写,因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。</li><li>Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。</li></ul><h2 id="4-乐观锁和悲观锁"><a href="#4-乐观锁和悲观锁" class="headerlink" title="4 乐观锁和悲观锁"></a>4 乐观锁和悲观锁</h2><p>悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作</p><p>乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。</p><p>乐观锁与悲观锁的具体区别: <a href="http://www.cnblogs.com/Bob-FD/p/3352216.html" target="_blank" rel="noopener">http://www.cnblogs.com/Bob-FD/p/3352216.html</a></p><h2 id="5-MVCC"><a href="#5-MVCC" class="headerlink" title="5 MVCC"></a>5 MVCC</h2><blockquote><p>​    全称是Multi-Version Concurrent Control，即多版本并发控制，在MVCC协议下，每个读操作会看到一个一致性的snapshot，并且可以实现非阻塞的读。MVCC允许数据具有多个版本，这个版本可以是时间戳或者是全局递增的事务ID，在同一个时间点，不同的事务看到的数据是不同的。</p></blockquote><h3 id="MySQL的innodb引擎是如何实现MVCC的"><a href="#MySQL的innodb引擎是如何实现MVCC的" class="headerlink" title="MySQL的innodb引擎是如何实现MVCC的"></a><a href="http://lib.csdn.net/base/mysql" target="_blank" rel="noopener">MySQL</a>的innodb引擎是如何实现MVCC的</h3><p>innodb会为每一行添加两个字段，分别表示该行<strong>创建的版本</strong>和<strong>删除的版本</strong>，填入的是事务的版本号，这个版本号随着事务的创建不断递增。在repeated read的隔离级别（<a href="http://blog.csdn.net/chosen0ne/article/details/10036775" target="_blank" rel="noopener">事务的隔离级别请看这篇文章</a>）下，具体各种数据库操作的实现：</p><ul><li>select：满足以下两个条件innodb会返回该行数据：<ul><li>该行的创建版本号小于等于当前版本号，用于保证在select操作之前所有的操作已经执行落地。</li><li>该行的删除版本号大于当前版本或者为空。删除版本号大于当前版本意味着有一个并发事务将该行删除了。</li></ul></li><li>insert：将新插入的行的创建版本号设置为当前系统的版本号。</li><li>delete：将要删除的行的删除版本号设置为当前系统的版本号。</li><li>update：不执行原地update，而是转换成insert + delete。将旧行的删除版本号设置为当前版本号，并将新行insert同时设置创建版本号为当前版本号。</li></ul><p>其中，写操作（insert、delete和update）执行时，需要将系统版本号递增。</p><p>​    由于旧数据并不真正的删除，所以必须对这些数据进行清理，innodb会开启一个后台线程执行清理工作，具体的规则是将删除版本号小于当前系统版本的行删除，这个过程叫做purge。</p><p>通过MVCC很好的实现了事务的隔离性，可以达到repeated read级别，要实现serializable还必须加锁。</p><blockquote><p> 参考：<a href="http://blog.csdn.net/chosen0ne/article/details/18093187" target="_blank" rel="noopener">MVCC浅析</a></p></blockquote><h2 id="6-MyISAM和InnoDB"><a href="#6-MyISAM和InnoDB" class="headerlink" title="6 MyISAM和InnoDB"></a>6 MyISAM和InnoDB</h2><p>MyISAM 适合于一些需要大量查询的应用，但其对于有大量写操作并不是很好。甚至你只是需要update一个字段，整个表都会被锁起来，而别的进程，就算是读进程都无法操作直到读操作完成。另外，MyISAM 对于 SELECT COUNT(*) 这类的计算是超快无比的。</p><p>InnoDB 的趋势会是一个非常复杂的存储引擎，对于一些小的应用，它会比 MyISAM 还慢。他是它支持“行锁” ，于是在写操作比较多的时候，会更优秀。并且，他还支持更多的高级应用，比如：事务。</p><p>mysql 数据库引擎: <a href="http://www.cnblogs.com/0201zcr/p/5296843.html" target="_blank" rel="noopener">http://www.cnblogs.com/0201zcr/p/5296843.html</a><br>MySQL存储引擎－－MyISAM与InnoDB区别: <a href="https://segmentfault.com/a/1190000008227211" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008227211</a></p><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="1-三次握手"><a href="#1-三次握手" class="headerlink" title="1 三次握手"></a>1 三次握手</h2><ol><li>客户端通过向服务器端发送一个SYN来创建一个主动打开，作为三次握手的一部分。客户端把这段连接的序号设定为随机数 A。</li><li>服务器端应当为一个合法的SYN回送一个SYN/ACK。ACK 的确认码应为 A+1，SYN/ACK 包本身又有一个随机序号 B。</li><li>最后，客户端再发送一个ACK。当服务端受到这个ACK的时候，就完成了三路握手，并进入了连接创建状态。此时包序号被设定为收到的确认号 A+1，而响应则为 B+1。</li></ol><h2 id="2-四次挥手"><a href="#2-四次挥手" class="headerlink" title="2 四次挥手"></a>2 四次挥手</h2><p><em>注意: 中断连接端可以是客户端，也可以是服务器端. 下面仅以客户端断开连接举例, 反之亦然.</em></p><ol><li>客户端发送一个数据分段, 其中的 FIN 标记设置为1. 客户端进入 FIN-WAIT 状态. 该状态下客户端只接收数据, 不再发送数据.</li><li>服务器接收到带有 FIN = 1 的数据分段, 发送带有 ACK = 1 的剩余数据分段, 确认收到客户端发来的 FIN 信息.</li><li>服务器等到所有数据传输结束, 向客户端发送一个带有 FIN = 1 的数据分段, 并进入 CLOSE-WAIT 状态, 等待客户端发来带有 ACK = 1 的确认报文.</li><li>客户端收到服务器发来带有 FIN = 1 的报文, 返回 ACK = 1 的报文确认, 为了防止服务器端未收到需要重发, 进入 TIME-WAIT 状态. 服务器接收到报文后关闭连接. 客户端等待 2MSL 后未收到回复, 则认为服务器成功关闭, 客户端关闭连接.</li></ol><p>图解: <a href="http://blog.csdn.net/whuslei/article/details/6667471" target="_blank" rel="noopener">http://blog.csdn.net/whuslei/article/details/6667471</a></p><h2 id="3-ARP协议"><a href="#3-ARP协议" class="headerlink" title="3 ARP协议"></a>3 ARP协议</h2><p>地址解析协议(Address Resolution Protocol)，其基本功能为透过目标设备的IP地址，查询目标的MAC地址，以保证通信的顺利进行。它是IPv4网络层必不可少的协议，不过在IPv6中已不再适用，并被邻居发现协议（NDP）所替代。</p><h2 id="4-urllib和urllib2的区别"><a href="#4-urllib和urllib2的区别" class="headerlink" title="4 urllib和urllib2的区别"></a>4 urllib和urllib2的区别</h2><p>这个面试官确实问过,当时答的urllib2可以Post而urllib不可以.</p><ol><li>urllib提供urlencode方法用来GET查询字符串的产生，而urllib2没有。这是为何urllib常和urllib2一起使用的原因。</li><li>urllib2可以接受一个Request类的实例来设置URL请求的headers，urllib仅可以接受URL。这意味着，你不可以伪装你的User Agent字符串等。</li></ol><h2 id="5-Post和Get"><a href="#5-Post和Get" class="headerlink" title="5 Post和Get"></a>5 Post和Get</h2><p><a href="http://www.cnblogs.com/nankezhishi/archive/2012/06/09/getandpost.html" target="_blank" rel="noopener">GET和POST有什么区别？及为什么网上的多数答案都是错的</a><br><a href="https://www.zhihu.com/question/31640769?rf=37401322" target="_blank" rel="noopener">知乎回答</a></p><p>get: <a href="http://tools.ietf.org/html/rfc2616#section-9.3" target="_blank" rel="noopener">RFC 2616 - Hypertext Transfer Protocol – HTTP/1.1</a><br>post: <a href="http://tools.ietf.org/html/rfc2616#section-9.5" target="_blank" rel="noopener">RFC 2616 - Hypertext Transfer Protocol – HTTP/1.1</a></p><h2 id="6-Cookie和Session"><a href="#6-Cookie和Session" class="headerlink" title="6 Cookie和Session"></a>6 Cookie和Session</h2><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">Cookie</th><th style="text-align:left">Session</th></tr></thead><tbody><tr><td style="text-align:left">储存位置</td><td style="text-align:left">客户端</td><td style="text-align:left">服务器端</td></tr><tr><td style="text-align:left">目的</td><td style="text-align:left">跟踪会话，也可以保存用户偏好设置或者保存用户名密码等</td><td style="text-align:left">跟踪会话</td></tr><tr><td style="text-align:left">安全性</td><td style="text-align:left">不安全</td><td style="text-align:left">安全</td></tr></tbody></table><p>session技术是要使用到cookie的，之所以出现session技术，主要是为了安全。</p><h2 id="7-apache和nginx的区别"><a href="#7-apache和nginx的区别" class="headerlink" title="7 apache和nginx的区别"></a>7 apache和nginx的区别</h2><p>nginx 相对 apache 的优点：</p><ul><li>轻量级，同样起web 服务，比apache 占用更少的内存及资源</li><li>抗并发，nginx 处理请求是异步非阻塞的，支持更多的并发连接，而apache 则是阻塞型的，在高并发下nginx 能保持低资源低消耗高性能</li><li>配置简洁</li><li>高度模块化的设计，编写模块相对简单</li><li>社区活跃</li></ul><p>apache 相对nginx 的优点：</p><ul><li>rewrite ，比nginx 的rewrite 强大</li><li>模块超多，基本想到的都可以找到</li><li>少bug ，nginx 的bug 相对较多</li><li>超稳定</li></ul><h2 id="8-网站用户密码保存"><a href="#8-网站用户密码保存" class="headerlink" title="8 网站用户密码保存"></a>8 网站用户密码保存</h2><ol><li>明文保存</li><li>明文hash后保存,如md5</li><li>MD5+Salt方式,这个salt可以随机</li><li>知乎使用了Bcrypy(好像)加密</li></ol><h2 id="9-HTTP和HTTPS"><a href="#9-HTTP和HTTPS" class="headerlink" title="9 HTTP和HTTPS"></a>9 HTTP和HTTPS</h2><table><thead><tr><th style="text-align:left">状态码</th><th style="text-align:left">定义</th></tr></thead><tbody><tr><td style="text-align:left">1xx 报告</td><td style="text-align:left">接收到请求，继续进程</td></tr><tr><td style="text-align:left">2xx 成功</td><td style="text-align:left">步骤成功接收，被理解，并被接受</td></tr><tr><td style="text-align:left">3xx 重定向</td><td style="text-align:left">为了完成请求,必须采取进一步措施</td></tr><tr><td style="text-align:left">4xx 客户端出错</td><td style="text-align:left">请求包括错的顺序或不能完成</td></tr><tr><td style="text-align:left">5xx 服务器出错</td><td style="text-align:left">服务器无法完成显然有效的请求</td></tr></tbody></table><p>403: Forbidden<br>404: Not Found</p><p>HTTPS握手,对称加密,非对称加密,TLS/SSL,RSA</p><h2 id="10-XSRF和XSS"><a href="#10-XSRF和XSS" class="headerlink" title="10 XSRF和XSS"></a>10 XSRF和XSS</h2><ul><li>CSRF(Cross-site request forgery)跨站请求伪造</li><li>XSS(Cross Site Scripting)跨站脚本攻击</li></ul><p>CSRF重点在请求,XSS重点在脚本</p><h2 id="11-幂等-Idempotence"><a href="#11-幂等-Idempotence" class="headerlink" title="11 幂等 Idempotence"></a>11 幂等 Idempotence</h2><p>HTTP方法的幂等性是指一次和多次请求某一个资源应该具有同样的<strong>副作用</strong>。(注意是副作用)</p><p><code>GET http://www.bank.com/account/123456</code>，不会改变资源的状态，不论调用一次还是N次都没有副作用。请注意，这里强调的是一次和N次具有相同的副作用，而不是每次GET的结果相同。<code>GET http://www.news.com/latest-news</code>这个HTTP请求可能会每次得到不同的结果，但它本身并没有产生任何副作用，因而是满足幂等性的。</p><p>DELETE方法用于删除资源，有副作用，但它应该满足幂等性。比如：<code>DELETE http://www.forum.com/article/4231</code>，调用一次和N次对系统产生的副作用是相同的，即删掉id为4231的帖子；因此，调用者可以多次调用或刷新页面而不必担心引起错误。</p><p>POST所对应的URI并非创建的资源本身，而是资源的接收者。比如：<code>POST http://www.forum.com/articles</code>的语义是在<code>http://www.forum.com/articles</code>下创建一篇帖子，HTTP响应中应包含帖子的创建状态以及帖子的URI。两次相同的POST请求会在服务器端创建两份资源，它们具有不同的URI；所以，POST方法不具备幂等性。</p><p>PUT所对应的URI是要创建或更新的资源本身。比如：<code>PUT http://www.forum/articles/4231</code>的语义是创建或更新ID为4231的帖子。对同一URI进行多次PUT的副作用和一次PUT是相同的；因此，PUT方法具有幂等性。</p><h2 id="12-RESTful架构-SOAP-RPC"><a href="#12-RESTful架构-SOAP-RPC" class="headerlink" title="12 RESTful架构(SOAP,RPC)"></a>12 RESTful架构(SOAP,RPC)</h2><p>推荐: <a href="http://www.ruanyifeng.com/blog/2011/09/restful.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2011/09/restful.html</a></p><h2 id="13-SOAP"><a href="#13-SOAP" class="headerlink" title="13 SOAP"></a>13 SOAP</h2><p>SOAP（原为Simple Object Access Protocol的首字母缩写，即简单对象访问协议）是交换数据的一种协议规范，使用在计算机网络Web服务（web service）中，交换带结构信息。SOAP为了简化网页服务器（Web Server）从XML数据库中提取数据时，节省去格式化页面时间，以及不同应用程序之间按照HTTP通信协议，遵从XML格式执行资料互换，使其抽象于语言实现、平台和硬件。</p><h2 id="14-RPC"><a href="#14-RPC" class="headerlink" title="14 RPC"></a>14 RPC</h2><p>RPC（Remote Procedure Call Protocol）——远程过程调用协议，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发包括网络分布式多程序在内的应用程序更加容易。</p><p>总结:服务提供的两大流派.传统意义以方法调用为导向通称RPC。为了企业SOA,若干厂商联合推出webservice,制定了wsdl接口定义,传输soap.当互联网时代,臃肿SOA被简化为http+xml/json.但是简化出现各种混乱。以资源为导向,任何操作无非是对资源的增删改查，于是统一的REST出现了.</p><p>进化的顺序: RPC -&gt; SOAP -&gt; RESTful</p><h2 id="15-CGI和WSGI"><a href="#15-CGI和WSGI" class="headerlink" title="15 CGI和WSGI"></a>15 CGI和WSGI</h2><p>CGI是通用网关接口，是连接web服务器和应用程序的接口，用户通过CGI来获取动态数据或文件等。<br>CGI程序是一个独立的程序，它可以用几乎所有语言来写，包括perl，c，lua，python等等。</p><p>WSGI, Web Server Gateway Interface，是Python应用程序或框架和Web服务器之间的一种接口，WSGI的其中一个目的就是让用户可以用统一的语言(Python)编写前后端。</p><p>官方说明：<a href="https://www.python.org/dev/peps/pep-3333/" target="_blank" rel="noopener">PEP-3333</a></p><h2 id="16-中间人攻击"><a href="#16-中间人攻击" class="headerlink" title="16 中间人攻击"></a>16 中间人攻击</h2><p>在GFW里屡见不鲜的,呵呵.</p><p>中间人攻击（Man-in-the-middle attack，通常缩写为MITM）是指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。</p><h2 id="17-c10k问题"><a href="#17-c10k问题" class="headerlink" title="17 c10k问题"></a>17 c10k问题</h2><p>所谓c10k问题，指的是服务器同时支持成千上万个客户端的问题，也就是concurrent 10 000 connection（这也是c10k这个名字的由来）。<br>推荐: <a href="https://my.oschina.net/xianggao/blog/664275" target="_blank" rel="noopener">https://my.oschina.net/xianggao/blog/664275</a></p><h2 id="18-socket"><a href="#18-socket" class="headerlink" title="18 socket"></a>18 socket</h2><p>推荐: <a href="http://www.360doc.com/content/11/0609/15/5482098_122692444.shtml" target="_blank" rel="noopener">http://www.360doc.com/content/11/0609/15/5482098_122692444.shtml</a></p><p>Socket=Ip address+ TCP/UDP + port</p><h2 id="19-浏览器缓存"><a href="#19-浏览器缓存" class="headerlink" title="19 浏览器缓存"></a>19 浏览器缓存</h2><p>推荐: <a href="http://www.cnblogs.com/skynet/archive/2012/11/28/2792503.html" target="_blank" rel="noopener">http://www.cnblogs.com/skynet/archive/2012/11/28/2792503.html</a></p><p>304 Not Modified</p><h2 id="20-HTTP1-0和HTTP1-1"><a href="#20-HTTP1-0和HTTP1-1" class="headerlink" title="20 HTTP1.0和HTTP1.1"></a>20 HTTP1.0和HTTP1.1</h2><p>推荐: <a href="http://blog.csdn.net/elifefly/article/details/3964766" target="_blank" rel="noopener">http://blog.csdn.net/elifefly/article/details/3964766</a></p><ol><li>请求头Host字段,一个服务器多个网站</li><li>长链接</li><li>文件断点续传</li><li>身份认证,状态管理,Cache缓存</li></ol><p>HTTP请求8种方法介绍<br>HTTP/1.1协议中共定义了8种HTTP请求方法，HTTP请求方法也被叫做“请求动作”，不同的方法规定了不同的操作指定的资源方式。服务端也会根据不同的请求方法做不同的响应。</p><p>GET</p><p>GET请求会显示请求指定的资源。一般来说GET方法应该只用于数据的读取，而不应当用于会产生副作用的非幂等的操作中。</p><p>GET会方法请求指定的页面信息，并返回响应主体，GET被认为是不安全的方法，因为GET方法会被网络蜘蛛等任意的访问。</p><p>HEAD</p><p>HEAD方法与GET方法一样，都是向服务器发出指定资源的请求。但是，服务器在响应HEAD请求时不会回传资源的内容部分，即：响应主体。这样，我们可以不传输全部内容的情况下，就可以获取服务器的响应头信息。HEAD方法常被用于客户端查看服务器的性能。</p><p>POST</p><p>POST请求会 向指定资源提交数据，请求服务器进行处理，如：表单数据提交、文件上传等，请求数据会被包含在请求体中。POST方法是非幂等的方法，因为这个请求可能会创建新的资源或/和修改现有资源。</p><p>PUT</p><p>PUT请求会身向指定资源位置上传其最新内容，PUT方法是幂等的方法。通过该方法客户端可以将指定资源的最新数据传送给服务器取代指定的资源的内容。</p><p>DELETE</p><p>DELETE请求用于请求服务器删除所请求URI（统一资源标识符，Uniform Resource Identifier）所标识的资源。DELETE请求后指定资源会被删除，DELETE方法也是幂等的。</p><p>CONNECT</p><p>CONNECT方法是HTTP/1.1协议预留的，能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接与非加密的HTTP代理服务器的通信。</p><p>OPTIONS</p><p>OPTIONS请求与HEAD类似，一般也是用于客户端查看服务器的性能。 这个方法会请求服务器返回该资源所支持的所有HTTP请求方法，该方法会用’*’来代替资源名称，向服务器发送OPTIONS请求，可以测试服务器功能是否正常。JavaScript的XMLHttpRequest对象进行CORS跨域资源共享时，就是使用OPTIONS方法发送嗅探请求，以判断是否有对指定资源的访问权限。 允许</p><p>TRACE</p><p>TRACE请求服务器回显其收到的请求信息，该方法主要用于HTTP请求的测试或诊断。</p><p>HTTP/1.1之后增加的方法</p><p>在HTTP/1.1标准制定之后，又陆续扩展了一些方法。其中使用中较多的是 PATCH 方法：</p><p>PATCH</p><p>PATCH方法出现的较晚，它在2010年的RFC 5789标准中被定义。PATCH请求与PUT请求类似，同样用于资源的更新。二者有以下两点不同：</p><p>但PATCH一般用于资源的部分更新，而PUT一般用于资源的整体更新。<br>当资源不存在时，PATCH会创建一个新的资源，而PUT只会对已在资源进行更新。</p><h2 id="21-Ajax"><a href="#21-Ajax" class="headerlink" title="21 Ajax"></a>21 Ajax</h2><p>AJAX,Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）, 是与在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页的技术。</p><h1 id="NIX"><a href="#NIX" class="headerlink" title="*NIX"></a>*NIX</h1><h2 id="unix进程间通信方式-IPC"><a href="#unix进程间通信方式-IPC" class="headerlink" title="unix进程间通信方式(IPC)"></a>unix进程间通信方式(IPC)</h2><ol><li>管道（Pipe）：管道可用于具有亲缘关系进程间的通信，允许一个进程和另一个与它有共同祖先的进程之间进行通信。</li><li>命名管道（named pipe）：命名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。命名管道在文件系统中有对应的文件名。命名管道通过命令mkfifo或系统调用mkfifo来创建。</li><li>信号（Signal）：信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身；linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上，该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数）。</li><li>消息（Message）队列：消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺</li><li>共享内存：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。</li><li>内存映射（mapped memory）：内存映射允许任何多个进程间通信，每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现它。</li><li>信号量（semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段。</li><li>套接口（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System V的变种都支持套接字。</li></ol><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="1-红黑树"><a href="#1-红黑树" class="headerlink" title="1 红黑树"></a>1 红黑树</h2><p>红黑树与AVL的比较：</p><p>AVL是严格平衡树，因此在增加或者删除节点的时候，根据不同情况，旋转的次数比红黑树要多；</p><p>红黑是用非严格的平衡来换取增删节点时候旋转次数的降低；</p><p>所以简单说，如果你的应用中，搜索的次数远远大于插入和删除，那么选择AVL，如果搜索，插入删除次数几乎差不多，应该选择RB。</p><p>红黑树详解: <a href="https://xieguanglei.github.io/blog/post/red-black-tree.html" target="_blank" rel="noopener">https://xieguanglei.github.io/blog/post/red-black-tree.html</a></p><p>教你透彻了解红黑树: <a href="https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/03.01.md" target="_blank" rel="noopener">https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/03.01.md</a></p><h1 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h1><h2 id="1-台阶问题-斐波那契"><a href="#1-台阶问题-斐波那契" class="headerlink" title="1 台阶问题/斐波那契"></a>1 台阶问题/斐波那契</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fib = <span class="keyword">lambda</span> n: n <span class="keyword">if</span> n &lt;= <span class="number">2</span> <span class="keyword">else</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>第二种记忆方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">memo</span><span class="params">(func)</span>:</span></span><br><span class="line">    cache = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrap</span><span class="params">(*args)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> args <span class="keyword">not</span> <span class="keyword">in</span> cache:</span><br><span class="line">            cache[args] = func(*args)</span><br><span class="line">        <span class="keyword">return</span> cache[args]</span><br><span class="line">    <span class="keyword">return</span> wrap</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@memo</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(i)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> i &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> fib(i<span class="number">-1</span>) + fib(i<span class="number">-2</span>)</span><br></pre></td></tr></table></figure><p>第三种方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span></span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(n):</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">    <span class="keyword">return</span> b</span><br></pre></td></tr></table></figure><h2 id="2-变态台阶问题"><a href="#2-变态台阶问题" class="headerlink" title="2 变态台阶问题"></a>2 变态台阶问题</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fib = <span class="keyword">lambda</span> n: n <span class="keyword">if</span> n &lt; <span class="number">2</span> <span class="keyword">else</span> <span class="number">2</span> * fib(n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="3-矩形覆盖"><a href="#3-矩形覆盖" class="headerlink" title="3 矩形覆盖"></a>3 矩形覆盖</h2><p>我们可以用<code>2*1</code>的小矩形横着或者竖着去覆盖更大的矩形。请问用n个<code>2*1</code>的小矩形无重叠地覆盖一个<code>2*n</code>的大矩形，总共有多少种方法？</p><blockquote><p>第<code>2*n</code>个矩形的覆盖方法等于第<code>2*(n-1)</code>加上第<code>2*(n-2)</code>的方法。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="keyword">lambda</span> n: <span class="number">1</span> <span class="keyword">if</span> n &lt; <span class="number">2</span> <span class="keyword">else</span> f(n - <span class="number">1</span>) + f(n - <span class="number">2</span>)</span><br></pre></td></tr></table></figure><h2 id="4-杨氏矩阵查找"><a href="#4-杨氏矩阵查找" class="headerlink" title="4 杨氏矩阵查找"></a>4 杨氏矩阵查找</h2><p>在一个m行n列二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p>使用Step-wise线性搜索。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_value</span><span class="params">(l, r, c)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> l[r][c]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(l, x)</span>:</span></span><br><span class="line">    m = len(l) - <span class="number">1</span></span><br><span class="line">    n = len(l[<span class="number">0</span>]) - <span class="number">1</span></span><br><span class="line">    r = <span class="number">0</span></span><br><span class="line">    c = n</span><br><span class="line">    <span class="keyword">while</span> c &gt;= <span class="number">0</span> <span class="keyword">and</span> r &lt;= m:</span><br><span class="line">        value = get_value(l, r, c)</span><br><span class="line">        <span class="keyword">if</span> value == x:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">elif</span> value &gt; x:</span><br><span class="line">            c = c - <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> value &lt; x:</span><br><span class="line">            r = r + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h2 id="5-去除列表中的重复元素"><a href="#5-去除列表中的重复元素" class="headerlink" title="5 去除列表中的重复元素"></a>5 去除列表中的重复元素</h2><p>用集合</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list(set(l))</span><br></pre></td></tr></table></figure><p>用字典</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l1 = [<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'a'</span>,<span class="string">'a'</span>]</span><br><span class="line">l2 = &#123;&#125;.fromkeys(l1).keys()</span><br><span class="line"><span class="keyword">print</span> l2</span><br></pre></td></tr></table></figure><p>用字典并保持顺序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">l1 = [<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'a'</span>,<span class="string">'a'</span>]</span><br><span class="line">l2 = list(set(l1))</span><br><span class="line">l2.sort(key=l1.index)</span><br><span class="line"><span class="keyword">print</span> l2</span><br></pre></td></tr></table></figure><p>列表推导式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l1 = [<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'a'</span>,<span class="string">'a'</span>]</span><br><span class="line">l2 = []</span><br><span class="line">[l2.append(i) <span class="keyword">for</span> i <span class="keyword">in</span> l1 <span class="keyword">if</span> <span class="keyword">not</span> i <span class="keyword">in</span> l2]</span><br></pre></td></tr></table></figure><p>sorted排序并且用列表推导式.</p><p>l = [‘b’,’c’,’d’,’b’,’c’,’a’,’a’]<br>[single.append(i) for i in sorted(l) if i not in single]<br>print single</p><h2 id="6-链表成对调换"><a href="#6-链表成对调换" class="headerlink" title="6 链表成对调换"></a>6 链表成对调换</h2><p><code>1-&gt;2-&gt;3-&gt;4</code>转换成<code>2-&gt;1-&gt;4-&gt;3</code>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param a ListNode</span></span><br><span class="line">    <span class="comment"># @return a ListNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> head != <span class="keyword">None</span> <span class="keyword">and</span> head.next != <span class="keyword">None</span>:</span><br><span class="line">            next = head.next</span><br><span class="line">            head.next = self.swapPairs(next.next)</span><br><span class="line">            next.next = head</span><br><span class="line">            <span class="keyword">return</span> next</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><h2 id="7-创建字典的方法"><a href="#7-创建字典的方法" class="headerlink" title="7 创建字典的方法"></a>7 创建字典的方法</h2><h3 id="1-直接创建"><a href="#1-直接创建" class="headerlink" title="1 直接创建"></a>1 直接创建</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dict = &#123;<span class="string">'name'</span>:<span class="string">'earth'</span>, <span class="string">'port'</span>:<span class="string">'80'</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="2-工厂方法"><a href="#2-工厂方法" class="headerlink" title="2 工厂方法"></a>2 工厂方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">items=[(<span class="string">'name'</span>,<span class="string">'earth'</span>),(<span class="string">'port'</span>,<span class="string">'80'</span>)]</span><br><span class="line">dict2=dict(items)</span><br><span class="line">dict1=dict(([<span class="string">'name'</span>,<span class="string">'earth'</span>],[<span class="string">'port'</span>,<span class="string">'80'</span>]))</span><br></pre></td></tr></table></figure><h3 id="3-fromkeys-方法"><a href="#3-fromkeys-方法" class="headerlink" title="3 fromkeys()方法"></a>3 fromkeys()方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dict1=&#123;&#125;.fromkeys((<span class="string">'x'</span>,<span class="string">'y'</span>),<span class="number">-1</span>)</span><br><span class="line">dict=&#123;<span class="string">'x'</span>:<span class="number">-1</span>,<span class="string">'y'</span>:<span class="number">-1</span>&#125;</span><br><span class="line">dict2=&#123;&#125;.fromkeys((<span class="string">'x'</span>,<span class="string">'y'</span>))</span><br><span class="line">dict2=&#123;<span class="string">'x'</span>:<span class="keyword">None</span>, <span class="string">'y'</span>:<span class="keyword">None</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="8-合并两个有序列表"><a href="#8-合并两个有序列表" class="headerlink" title="8 合并两个有序列表"></a>8 合并两个有序列表</h2><p>知乎远程面试要求编程</p><blockquote><p> 尾递归</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_recursion_merge_sort2</span><span class="params">(l1, l2, tmp)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(l1) == <span class="number">0</span> <span class="keyword">or</span> len(l2) == <span class="number">0</span>:</span><br><span class="line">        tmp.extend(l1)</span><br><span class="line">        tmp.extend(l2)</span><br><span class="line">        <span class="keyword">return</span> tmp</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> l1[<span class="number">0</span>] &lt; l2[<span class="number">0</span>]:</span><br><span class="line">            tmp.append(l1[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">del</span> l1[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            tmp.append(l2[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">del</span> l2[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> _recursion_merge_sort2(l1, l2, tmp)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recursion_merge_sort2</span><span class="params">(l1, l2)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> _recursion_merge_sort2(l1, l2, [])</span><br></pre></td></tr></table></figure><blockquote><p> 循环算法</p></blockquote><p>思路：</p><p>定义一个新的空列表</p><p>比较两个列表的首个元素</p><p>小的就插入到新列表里</p><p>把已经插入新列表的元素从旧列表删除</p><p>直到两个旧列表有一个为空</p><p>再把旧列表加到新列表后面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def loop_merge_sort(l1, l2):</span><br><span class="line">    tmp = []</span><br><span class="line">    while len(l1) &gt; 0 and len(l2) &gt; 0:</span><br><span class="line">        if l1[0] &lt; l2[0]:</span><br><span class="line">            tmp.append(l1[0])</span><br><span class="line">            del l1[0]</span><br><span class="line">        else:</span><br><span class="line">            tmp.append(l2[0])</span><br><span class="line">            del l2[0]</span><br><span class="line">    tmp.extend(l1)</span><br><span class="line">    tmp.extend(l2)</span><br><span class="line">    return tmp</span><br></pre></td></tr></table></figure><blockquote><p>pop弹出</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>]</span><br><span class="line">b = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sortedlist</span><span class="params">(a,b)</span>:</span></span><br><span class="line">    c = []</span><br><span class="line">    <span class="keyword">while</span> a <span class="keyword">and</span> b:</span><br><span class="line">        <span class="keyword">if</span> a[<span class="number">0</span>] &gt;= b[<span class="number">0</span>]:</span><br><span class="line">            c.append(b.pop(<span class="number">0</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            c.append(a.pop(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">while</span> a:</span><br><span class="line">        c.append(a.pop(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">while</span> b:</span><br><span class="line">        c.append(b.pop(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"><span class="keyword">print</span> merge_sortedlist(a,b)</span><br></pre></td></tr></table></figure><h2 id="9-交叉链表求交点"><a href="#9-交叉链表求交点" class="headerlink" title="9 交叉链表求交点"></a>9 交叉链表求交点</h2><blockquote><p>其实思想可以按照从尾开始比较两个链表，如果相交，则从尾开始必然一致，只要从尾开始比较，直至不一致的地方即为交叉点，如图所示</p></blockquote><p><img src="http://hi.csdn.net/attachment/201106/28/0_1309244136MWLP.gif" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用a,b两个list来模拟链表，可以看出交叉点是 7这个节点</span></span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">5</span>]</span><br><span class="line">b = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,min(len(a),len(b))):</span><br><span class="line">    <span class="keyword">if</span> i==<span class="number">1</span> <span class="keyword">and</span> (a[<span class="number">-1</span>] != b[<span class="number">-1</span>]):</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"No"</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> a[-i] != b[-i]:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"交叉节点："</span>,a[-i+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><blockquote><p>另外一种比较正规的方法，构造链表类</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">node</span><span class="params">(l1, l2)</span>:</span></span><br><span class="line">    length1, lenth2 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="comment"># 求两个链表长度</span></span><br><span class="line">    <span class="keyword">while</span> l1.next:</span><br><span class="line">        l1 = l1.next</span><br><span class="line">        length1 += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> l2.next:</span><br><span class="line">        l2 = l2.next</span><br><span class="line">        length2 += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 长的链表先走</span></span><br><span class="line">    <span class="keyword">if</span> length1 &gt; lenth2:</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(length1 - length2):</span><br><span class="line">            l1 = l1.next</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(length2 - length1):</span><br><span class="line">            l2 = l2.next</span><br><span class="line">    <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">        <span class="keyword">if</span> l1.next == l2.next:</span><br><span class="line">            <span class="keyword">return</span> l1.next</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l1 = l1.next</span><br><span class="line">            l2 = l2.next</span><br></pre></td></tr></table></figure><p>修改了一下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">node</span><span class="params">(l1, l2)</span>:</span></span><br><span class="line">    length1, length2 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="comment"># 求两个链表长度</span></span><br><span class="line">    <span class="keyword">while</span> l1.next:</span><br><span class="line">        l1 = l1.next<span class="comment">#尾节点</span></span><br><span class="line">        length1 += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> l2.next:</span><br><span class="line">        l2 = l2.next<span class="comment">#尾节点</span></span><br><span class="line">        length2 += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#如果相交</span></span><br><span class="line">    <span class="keyword">if</span> l1.next == l2.next:</span><br><span class="line">        <span class="comment"># 长的链表先走</span></span><br><span class="line">        <span class="keyword">if</span> length1 &gt; length2:</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(length1 - length2):</span><br><span class="line">                l1 = l1.next</span><br><span class="line">            <span class="keyword">return</span> l1<span class="comment">#返回交点</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(length2 - length1):</span><br><span class="line">                l2 = l2.next</span><br><span class="line">            <span class="keyword">return</span> l2<span class="comment">#返回交点</span></span><br><span class="line">    <span class="comment"># 如果不相交</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>思路: <a href="http://humaoli.blog.163.com/blog/static/13346651820141125102125995/" target="_blank" rel="noopener">http://humaoli.blog.163.com/blog/static/13346651820141125102125995/</a></p><h2 id="10-二分查找"><a href="#10-二分查找" class="headerlink" title="10 二分查找"></a>10 二分查找</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span><span class="params">(list,item)</span>:</span></span><br><span class="line">    low = <span class="number">0</span></span><br><span class="line">    high = len(list)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> low&lt;=high:</span><br><span class="line">        mid = (low+high)/<span class="number">2</span></span><br><span class="line">        guess = list[mid]</span><br><span class="line">        <span class="keyword">if</span> guess&gt;item:</span><br><span class="line">            high = mid<span class="number">-1</span></span><br><span class="line">        <span class="keyword">elif</span> guess&lt;item:</span><br><span class="line">            low = mid+<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">mylist = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>]</span><br><span class="line"><span class="keyword">print</span> binary_search(mylist,<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>参考: <a href="http://blog.csdn.net/u013205877/article/details/76411718" target="_blank" rel="noopener">http://blog.csdn.net/u013205877/article/details/76411718</a></p><h2 id="11-快排"><a href="#11-快排" class="headerlink" title="11 快排"></a>11 快排</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quicksort</span><span class="params">(list)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(list)&lt;<span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> list</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        midpivot = list[<span class="number">0</span>]</span><br><span class="line">        lessbeforemidpivot = [i <span class="keyword">for</span> i <span class="keyword">in</span> list[<span class="number">1</span>:] <span class="keyword">if</span> i&lt;=midpivot]</span><br><span class="line">        biggerafterpivot = [i <span class="keyword">for</span> i <span class="keyword">in</span> list[<span class="number">1</span>:] <span class="keyword">if</span> i &gt; midpivot]</span><br><span class="line">        finallylist = quicksort(lessbeforemidpivot)+[midpivot]+quicksort(biggerafterpivot)</span><br><span class="line">        <span class="keyword">return</span> finallylist</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> quicksort([<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>])</span><br></pre></td></tr></table></figure><blockquote><p> 更多排序问题可见：<a href="http://blog.csdn.net/mrlevo520/article/details/77829204" target="_blank" rel="noopener">数据结构与算法-排序篇-Python描述</a></p></blockquote><h2 id="12-找零问题"><a href="#12-找零问题" class="headerlink" title="12 找零问题"></a>12 找零问题</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="comment">#values是硬币的面值values = [ 25, 21, 10, 5, 1]</span></span><br><span class="line"><span class="comment">#valuesCounts   钱币对应的种类数</span></span><br><span class="line"><span class="comment">#money  找出来的总钱数</span></span><br><span class="line"><span class="comment">#coinsUsed   对应于目前钱币总数i所使用的硬币数目</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coinChange</span><span class="params">(values,valuesCounts,money,coinsUsed)</span>:</span></span><br><span class="line">    <span class="comment">#遍历出从1到money所有的钱数可能</span></span><br><span class="line">    <span class="keyword">for</span> cents <span class="keyword">in</span> range(<span class="number">1</span>,money+<span class="number">1</span>):</span><br><span class="line">        minCoins = cents</span><br><span class="line">        <span class="comment">#把所有的硬币面值遍历出来和钱数做对比</span></span><br><span class="line">        <span class="keyword">for</span> kind <span class="keyword">in</span> range(<span class="number">0</span>,valuesCounts):</span><br><span class="line">            <span class="keyword">if</span> (values[kind] &lt;= cents):</span><br><span class="line">                temp = coinsUsed[cents - values[kind]] +<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> (temp &lt; minCoins):</span><br><span class="line">                    minCoins = temp</span><br><span class="line">        coinsUsed[cents] = minCoins</span><br><span class="line">        <span class="keyword">print</span> (<span class="string">'面值:&#123;0&#125;的最少硬币使用数为:&#123;1&#125;'</span>.format(cents, coinsUsed[cents]))</span><br></pre></td></tr></table></figure><p>思路: <a href="http://blog.csdn.net/wdxin1322/article/details/9501163" target="_blank" rel="noopener">http://blog.csdn.net/wdxin1322/article/details/9501163</a></p><p>方法: <a href="http://www.cnblogs.com/ChenxofHit/archive/2011/03/18/1988431.html" target="_blank" rel="noopener">http://www.cnblogs.com/ChenxofHit/archive/2011/03/18/1988431.html</a></p><h2 id="13-广度遍历和深度遍历二叉树"><a href="#13-广度遍历和深度遍历二叉树" class="headerlink" title="13 广度遍历和深度遍历二叉树"></a>13 广度遍历和深度遍历二叉树</h2><p>给定一个数组，构建二叉树，并且按层次打印这个二叉树</p><h2 id="14-二叉树节点"><a href="#14-二叉树节点" class="headerlink" title="14 二叉树节点"></a>14 二叉树节点</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data, left=None, right=None)</span>:</span></span><br><span class="line">        self.data = data</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"></span><br><span class="line">tree = Node(<span class="number">1</span>, Node(<span class="number">3</span>, Node(<span class="number">7</span>, Node(<span class="number">0</span>)), Node(<span class="number">6</span>)), Node(<span class="number">2</span>, Node(<span class="number">5</span>), Node(<span class="number">4</span>)))</span><br></pre></td></tr></table></figure><h2 id="15-层次遍历"><a href="#15-层次遍历" class="headerlink" title="15 层次遍历"></a>15 层次遍历</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lookup</span><span class="params">(root)</span>:</span></span><br><span class="line">    row = [root]</span><br><span class="line">    <span class="keyword">while</span> row:</span><br><span class="line">        print(row)</span><br><span class="line">        row = [kid <span class="keyword">for</span> item <span class="keyword">in</span> row <span class="keyword">for</span> kid <span class="keyword">in</span> (item.left, item.right) <span class="keyword">if</span> kid]</span><br></pre></td></tr></table></figure><h2 id="16-深度遍历"><a href="#16-深度遍历" class="headerlink" title="16 深度遍历"></a>16 深度遍历</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deep</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">print</span> root.data</span><br><span class="line">    deep(root.left)</span><br><span class="line">    deep(root.right)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    lookup(tree)</span><br><span class="line">    deep(tree)</span><br></pre></td></tr></table></figure><h2 id="17-前中后序遍历"><a href="#17-前中后序遍历" class="headerlink" title="17 前中后序遍历"></a>17 前中后序遍历</h2><p>深度遍历改变顺序就OK了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="comment">#二叉树的遍历</span></span><br><span class="line"><span class="comment">#简单的二叉树节点类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,value,left,right)</span>:</span></span><br><span class="line">        self.value = value</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"></span><br><span class="line"><span class="comment">#中序遍历:遍历左子树,访问当前节点,遍历右子树</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mid_travelsal</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> root.left <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        mid_travelsal(root.left)</span><br><span class="line">    <span class="comment">#访问当前节点</span></span><br><span class="line">    print(root.value)</span><br><span class="line">    <span class="keyword">if</span> root.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        mid_travelsal(root.right)</span><br><span class="line"></span><br><span class="line"><span class="comment">#前序遍历:访问当前节点,遍历左子树,遍历右子树</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pre_travelsal</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> (root.value)</span><br><span class="line">    <span class="keyword">if</span> root.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        pre_travelsal(root.left)</span><br><span class="line">    <span class="keyword">if</span> root.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        pre_travelsal(root.right)</span><br><span class="line"></span><br><span class="line"><span class="comment">#后续遍历:遍历左子树,遍历右子树,访问当前节点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">post_trvelsal</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> root.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        post_trvelsal(root.left)</span><br><span class="line">    <span class="keyword">if</span> root.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        post_trvelsal(root.right)</span><br><span class="line">    <span class="keyword">print</span> (root.value)</span><br></pre></td></tr></table></figure><h2 id="18-求最大树深"><a href="#18-求最大树深" class="headerlink" title="18 求最大树深"></a>18 求最大树深</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> max(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="19-求两棵树是否相同"><a href="#19-求两棵树是否相同" class="headerlink" title="19 求两棵树是否相同"></a>19 求两棵树是否相同</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isSameTree</span><span class="params">(p, q)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> p == <span class="keyword">None</span> <span class="keyword">and</span> q == <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">    <span class="keyword">elif</span> p <span class="keyword">and</span> q :</span><br><span class="line">        <span class="keyword">return</span> p.val == q.val <span class="keyword">and</span> isSameTree(p.left,q.left) <span class="keyword">and</span> isSameTree(p.right,q.right)</span><br><span class="line">    <span class="keyword">else</span> :</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h2 id="20-前序中序求后序"><a href="#20-前序中序求后序" class="headerlink" title="20 前序中序求后序"></a>20 前序中序求后序</h2><p>推荐: <a href="http://blog.csdn.net/hinyunsin/article/details/6315502" target="_blank" rel="noopener">http://blog.csdn.net/hinyunsin/article/details/6315502</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rebuild</span><span class="params">(pre, center)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> pre:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    cur = Node(pre[<span class="number">0</span>])</span><br><span class="line">    index = center.index(pre[<span class="number">0</span>])</span><br><span class="line">    cur.left = rebuild(pre[<span class="number">1</span>:index + <span class="number">1</span>], center[:index])</span><br><span class="line">    cur.right = rebuild(pre[index + <span class="number">1</span>:], center[index + <span class="number">1</span>:])</span><br><span class="line">    <span class="keyword">return</span> cur</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deep</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    deep(root.left)</span><br><span class="line">    deep(root.right)</span><br><span class="line">    <span class="keyword">print</span> root.data</span><br></pre></td></tr></table></figure><h2 id="21-单链表逆置"><a href="#21-单链表逆置" class="headerlink" title="21 单链表逆置"></a>21 单链表逆置</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data=None, next=None)</span>:</span></span><br><span class="line">        self.data = data</span><br><span class="line">        self.next = next</span><br><span class="line"></span><br><span class="line">link = Node(<span class="number">1</span>, Node(<span class="number">2</span>, Node(<span class="number">3</span>, Node(<span class="number">4</span>, Node(<span class="number">5</span>, Node(<span class="number">6</span>, Node(<span class="number">7</span>, Node(<span class="number">8</span>, Node(<span class="number">9</span>)))))))))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rev</span><span class="params">(link)</span>:</span></span><br><span class="line">    pre = link</span><br><span class="line">    cur = link.next</span><br><span class="line">    pre.next = <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">while</span> cur:</span><br><span class="line">        tmp = cur.next</span><br><span class="line">        cur.next = pre</span><br><span class="line">        pre = cur</span><br><span class="line">        cur = tmp</span><br><span class="line">    <span class="keyword">return</span> pre</span><br><span class="line"></span><br><span class="line">root = rev(link)</span><br><span class="line"><span class="keyword">while</span> root:</span><br><span class="line">    <span class="keyword">print</span> root.data</span><br><span class="line">    root = root.next</span><br></pre></td></tr></table></figure><p>思路: <a href="http://blog.csdn.net/feliciafay/article/details/6841115" target="_blank" rel="noopener">http://blog.csdn.net/feliciafay/article/details/6841115</a></p><p>方法: <a href="http://www.xuebuyuan.com/2066385.html?mobile=1" target="_blank" rel="noopener">http://www.xuebuyuan.com/2066385.html?mobile=1</a></p><h2 id="22-两个字符串是否是变位词"><a href="#22-两个字符串是否是变位词" class="headerlink" title="22 两个字符串是否是变位词"></a>22 两个字符串是否是变位词</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Anagram</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @:param s1: The first string</span></span><br><span class="line"><span class="string">    @:param s2: The second string</span></span><br><span class="line"><span class="string">    @:return true or false</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Solution1</span><span class="params">(s1,s2)</span>:</span></span><br><span class="line">        alist = list(s2)</span><br><span class="line"></span><br><span class="line">        pos1 = <span class="number">0</span></span><br><span class="line">        stillOK = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> pos1 &lt; len(s1) <span class="keyword">and</span> stillOK:</span><br><span class="line">            pos2 = <span class="number">0</span></span><br><span class="line">            found = <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">while</span> pos2 &lt; len(alist) <span class="keyword">and</span> <span class="keyword">not</span> found:</span><br><span class="line">                <span class="keyword">if</span> s1[pos1] == alist[pos2]:</span><br><span class="line">                    found = <span class="keyword">True</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    pos2 = pos2 + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> found:</span><br><span class="line">                alist[pos2] = <span class="keyword">None</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stillOK = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">            pos1 = pos1 + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stillOK</span><br><span class="line"></span><br><span class="line">    print(Solution1(<span class="string">'abcd'</span>,<span class="string">'dcba'</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Solution2</span><span class="params">(s1,s2)</span>:</span></span><br><span class="line">        alist1 = list(s1)</span><br><span class="line">        alist2 = list(s2)</span><br><span class="line"></span><br><span class="line">        alist1.sort()</span><br><span class="line">        alist2.sort()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        pos = <span class="number">0</span></span><br><span class="line">        matches = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> pos &lt; len(s1) <span class="keyword">and</span> matches:</span><br><span class="line">            <span class="keyword">if</span> alist1[pos] == alist2[pos]:</span><br><span class="line">                pos = pos + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                matches = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> matches</span><br><span class="line"></span><br><span class="line">    print(Solution2(<span class="string">'abcde'</span>,<span class="string">'edcbg'</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Solution3</span><span class="params">(s1,s2)</span>:</span></span><br><span class="line">        c1 = [<span class="number">0</span>]*<span class="number">26</span></span><br><span class="line">        c2 = [<span class="number">0</span>]*<span class="number">26</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s1)):</span><br><span class="line">            pos = ord(s1[i])-ord(<span class="string">'a'</span>)</span><br><span class="line">            c1[pos] = c1[pos] + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s2)):</span><br><span class="line">            pos = ord(s2[i])-ord(<span class="string">'a'</span>)</span><br><span class="line">            c2[pos] = c2[pos] + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        stillOK = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">while</span> j&lt;<span class="number">26</span> <span class="keyword">and</span> stillOK:</span><br><span class="line">            <span class="keyword">if</span> c1[j] == c2[j]:</span><br><span class="line">                j = j + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stillOK = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stillOK</span><br><span class="line"></span><br><span class="line">    print(Solution3(<span class="string">'apple'</span>,<span class="string">'pleap'</span>))</span><br></pre></td></tr></table></figure><h2 id="23-动态规划问题"><a href="#23-动态规划问题" class="headerlink" title="23 动态规划问题"></a>23 动态规划问题</h2><blockquote><p> 可参考：<a href="http://blog.csdn.net/mrlevo520/article/details/75676160" target="_blank" rel="noopener">动态规划(DP)的整理-Python描述</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- markdown-toc start - Don&#39;t edit this section. Run M-x markdown-toc-generate-toc again --&gt;
&lt;p&gt;&lt;strong&gt;Table of Contents&lt;/strong&gt;&lt;/p&gt;
&lt;ul
      
    
    </summary>
    
      <category term="面试题Python编程题" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98Python%E7%BC%96%E7%A8%8B%E9%A2%98/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>CSS 进阶</title>
    <link href="http://yoursite.com/2018/10/11/CSS%E8%BF%9B%E9%98%B6/"/>
    <id>http://yoursite.com/2018/10/11/CSS进阶/</id>
    <published>2018-10-11T07:57:57.000Z</published>
    <updated>2018-10-11T12:01:14.131Z</updated>
    
    <content type="html"><![CDATA[<ol><li>CSS属性：<a href="https://www.cnblogs.com/liwenzhou/p/7999532.html" target="_blank" rel="noopener">https://www.cnblogs.com/liwenzhou/p/7999532.html</a></li></ol><h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h1><p>width属性可以为元素设置宽度。<br>height属性可以为元素设置高度。<br>块级标签才能设置宽度，内联标签的宽度由内容来决定。<br>     <style><br>        p {color: red} #优先显示<br>        body {color: #0000cc}<br>    </style></p><pre><code> &lt;style&gt;        /*显示背景的*/    .c1 {        height: 100px;          width: 100px;        color: red;        background-color: darkorange; #背景设置    }    .c2 {        height: 600px;        width: 600px;        /*设置背景图片出现的次数 位置*/        background: url(&quot;01.jpg&quot; ) no-repeat center bottom;    }雪碧图：为了减少网页请求图片的次数，将很多小图片放在一个大图片中，通过background-postion来指定background: url(&apos;xx.png&apos; no-repeat center center)</code></pre><h2 id="背景图片的设置"><a href="#背景图片的设置" class="headerlink" title="背景图片的设置"></a>背景图片的设置</h2><pre><code>repeat(默认):背景图片平铺排满整个网页repeat-x：背景图片只在水平方向上平铺repeat-y：背景图片只在垂直方向上平铺no-repeat：背景图片不平铺</code></pre><h1 id="2-边框"><a href="#2-边框" class="headerlink" title="2. 边框"></a>2. 边框</h1><pre><code>border: 1px solid red</code></pre><h2 id="边框设置属性"><a href="#边框设置属性" class="headerlink" title="边框设置属性"></a>边框设置属性</h2><pre><code>border-widthborder-styleborder-color    值    描述none    无边框。dotted    点状虚线边框。dashed    矩形虚线边框。solid    实线边框。</code></pre><h2 id="画圆和-圆角矩形"><a href="#画圆和-圆角矩形" class="headerlink" title="画圆和 圆角矩形"></a>画圆和 圆角矩形</h2><pre><code> &lt;style&gt;    .c1 {        height: 100px;        width: 100px;        background-color: red;        border-radius:            50%;    }&lt;style&gt;</code></pre><h1 id="3-display"><a href="#3-display" class="headerlink" title="3. display"></a>3. display</h1><pre><code>1. none2. inline3. block4. inline-blockdisplay: none和visibility: hidden的区别？    都是隐藏页面上的标签    display: none隐藏标签并且不占位置    visibility: hidden 隐藏标签的同时会占住位置</code></pre><p><img src="https://i.imgur.com/zp0CS2F.png" alt=""></p><h1 id="4-盒子模型"><a href="#4-盒子模型" class="headerlink" title="4. 盒子模型"></a>4. 盒子模型</h1><h3 id="margin-用于控制元素与元素之间的距离；margin的最基本用途就是控制元素周围空间的间隔，从视觉角度上达到相互隔开的目的。"><a href="#margin-用于控制元素与元素之间的距离；margin的最基本用途就是控制元素周围空间的间隔，从视觉角度上达到相互隔开的目的。" class="headerlink" title="margin:用于控制元素与元素之间的距离；margin的最基本用途就是控制元素周围空间的间隔，从视觉角度上达到相互隔开的目的。"></a>margin:用于控制元素与元素之间的距离；margin的最基本用途就是控制元素周围空间的间隔，从视觉角度上达到相互隔开的目的。</h3><h3 id="padding-用于控制内容与边框之间的距离；"><a href="#padding-用于控制内容与边框之间的距离；" class="headerlink" title="padding:   用于控制内容与边框之间的距离；"></a>padding:   用于控制内容与边框之间的距离；</h3><h3 id="Border-边框-围绕在内边距和内容外的边框。"><a href="#Border-边框-围绕在内边距和内容外的边框。" class="headerlink" title="Border(边框):     围绕在内边距和内容外的边框。"></a>Border(边框):     围绕在内边距和内容外的边框。</h3><h3 id="Content-内容-盒子的内容，显示文本和图像。"><a href="#Content-内容-盒子的内容，显示文本和图像。" class="headerlink" title="Content(内容):   盒子的内容，显示文本和图像。"></a>Content(内容):   盒子的内容，显示文本和图像。</h3><pre><code>内容&gt;内填充(padding)&gt;边框(border)&gt;外边距(margin)</code></pre><p><img src="https://i.imgur.com/KUvfWZ7.png" alt=""></p><h1 id="5-浮动"><a href="#5-浮动" class="headerlink" title="5. 浮动"></a>5. 浮动</h1><pre><code>1. 浮动多用于页面大范围布局2. 浮动    - left   往左浮动    - right  往右浮动3. 清除浮动的副作用    1. clear        - left    左边不能有浮动元素        - right   右边不能有浮动元素        - both    两边都不能有浮动元素    2. 常用class        .clearfix:after {            content: &apos;&apos;;            display: block;            clear:both        }</code></pre><h1 id="6-溢出"><a href="#6-溢出" class="headerlink" title="6. 溢出"></a>6. 溢出</h1><pre><code>overflow    - hidden    - scroll    - auto圆形头像的例子</code></pre><h1 id="7-定位"><a href="#7-定位" class="headerlink" title="7. 定位"></a>7. 定位</h1><pre><code>1. 相对定位：相对 标签原来的位置 做的定位    position: relative    left:    top:    bottom:    right:2. 绝对定位：相对 已经定位过的祖先标签 做的定位    多用于页面局部的布局，注意要和定位过的祖先标签配合使用    绝对定位和浮动一样，标签都会脱离文档，别的标签可以占用它的位置3. 固定定位    固定定位相对于 屏幕 固定显示在某个位置    固定定位的元素也是脱离文档的    返回顶部按钮</code></pre><h1 id="2-Blog页面"><a href="#2-Blog页面" class="headerlink" title="2. Blog页面"></a>2. Blog页面</h1><pre><code>1. 先写HTML(HTML是骨架)2. 再写CSS(CSS控制HTML的显示效果)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;CSS属性：&lt;a href=&quot;https://www.cnblogs.com/liwenzhou/p/7999532.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/liwenzhou/p
      
    
    </summary>
    
      <category term="html" scheme="http://yoursite.com/categories/html/"/>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>CSS-给HTML设置样式</title>
    <link href="http://yoursite.com/2018/10/10/CSS-%E7%BB%99HTML%E8%AE%BE%E7%BD%AE%E6%A0%B7%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/10/10/CSS-给HTML设置样式/</id>
    <published>2018-10-10T12:15:54.367Z</published>
    <updated>2018-10-10T12:15:54.378Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-CSS（给HTML标签设置样式的）"><a href="#1-CSS（给HTML标签设置样式的）" class="headerlink" title="1. CSS（给HTML标签设置样式的）"></a>1. CSS（给HTML标签设置样式的）</h1><h2 id="1-1-CSS定义："><a href="#1-1-CSS定义：" class="headerlink" title="1.1 CSS定义："></a>1.1 CSS定义：</h2><p>层叠样式表</p><h2 id="1-2-CSS语法："><a href="#1-2-CSS语法：" class="headerlink" title="1.2 CSS语法："></a>1.2 CSS语法：</h2><p>选择器 {k1: v1; k2:v2…}</p><h2 id="1-3-CSS代码存在的位置"><a href="#1-3-CSS代码存在的位置" class="headerlink" title="1.3 CSS代码存在的位置"></a>1.3 CSS代码存在的位置</h2><pre><code>1. 直接写在标签中的style属性2. 写在head标签中的style标签内3. 写在单独的CSS文件中，通过link标签引用4. CSS选择器（定义如何在HTML中找标签）</code></pre><h1 id="2-CSS样式分类"><a href="#2-CSS样式分类" class="headerlink" title="2.CSS样式分类"></a>2.CSS样式分类</h1><h2 id="2-1-基本选择器"><a href="#2-1-基本选择器" class="headerlink" title="2.1 基本选择器"></a>2.1 基本选择器</h2><pre><code>1. ID选择器      --&gt; #p12. 标签选择器    --&gt; div3. 类选择器      --&gt; .c14. 通用选择器    --&gt; *  #没有设置样式的将匹配</code></pre><h3 id="2-1-1-具体实例"><a href="#2-1-1-具体实例" class="headerlink" title="2.1.1 具体实例"></a>2.1.1 具体实例</h3><pre><code>&lt;style&gt;    /*id是p1的标签*/    #p1 {color: red}    /*id是p2的标签*/    #p2 {        color: green    }    /*所有的div标签*/    div {color: blue}    /*有c1这个class的标签*/    .c1 {color: deeppink}    /*有c2这个class的标签*/    .c2 {color: purple}    /*有c1这个class的i标签*/    i.c1 {color: yellow}    /* 通用 */    * {color: black}&lt;/style&gt;</code></pre><h3 id="id-和-class的区别"><a href="#id-和-class的区别" class="headerlink" title="id 和 class的区别"></a>id 和 class的区别</h3><pre><code>1.class是设置标签的类， 用于指定元素属于何种样式的类2.ID是设置标签的标识。用于定义一个元素的独特的样式。3.class和ID的用法一样4.概念上说是不一样的    1.一个class是用来根据用户定义的样式对一个或者多个元素进行定义    2.ID通常用于定义页面上一个仅出现一次         </code></pre><h2 id="2-2组合选择器"><a href="#2-2组合选择器" class="headerlink" title="2.2组合选择器"></a>2.2组合选择器</h2><pre><code>1. 子子孙孙选择器（后代选择器）     --&gt; div p2. 儿子选择器                       --&gt; div&gt;p3. 毗邻选择器(紧挨着下面的标签)     --&gt; div+p4. 弟弟选择器(同级下面所有的标签)   --&gt; div~p</code></pre><h3 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h3><pre><code>&lt;style&gt;    /*找儿子标签：li的儿子a标签*/    li&gt;a {color: red}    /*子子孙孙中找标签*/    #d1 p {color: green}    /*毗邻选择器：找下面紧挨着的*/    div+p {color: blue}    /*弟弟选择器：同级往下面找 */    #d2~a {color: deeppink}&lt;/style&gt;</code></pre><h2 id="2-3-属性选择器"><a href="#2-3-属性选择器" class="headerlink" title="2.3 属性选择器"></a>2.3 属性选择器</h2><pre><code>1. 有某个属性的标签                 --&gt; div[title]2. 有属性并且属性值等于我给定的值   --&gt; div[title=&apos;hello&apos;]</code></pre><h3 id="代码实例-1"><a href="#代码实例-1" class="headerlink" title="代码实例"></a>代码实例</h3><pre><code>&lt;style&gt;    /* 找到所有有qs这个属性的标签 */    div[qs] {color: green}    /* 找到qs属性值是nb2的标签 */    div[qs=&apos;nb2&apos;] {color: yellow}    /*判断字符串是否包含给定的值*/    div[title*=&apos;hello&apos;] {color: blue}    /* 判断属性值按照空格分割得到的列表中是否包含指定的值 */    div[title~=&apos;hello&apos;] {color: deeppink}&lt;/style&gt;</code></pre><h2 id="2-4-分组和嵌套"><a href="#2-4-分组和嵌套" class="headerlink" title="2.4 分组和嵌套"></a>2.4 分组和嵌套</h2><pre><code>1. 分组应用于多个选择器找到的标签应用相同的样式时，为了避免重复写到一起    div, p {color: red}    &lt;style&gt;    /*#d1 {color: red}*/    /*.c1 {color: red}*/    #d1, .c1 {color: red}&lt;/style&gt;2. 基本选择器之间可以任意嵌套组合使用    .c1&gt;p </code></pre><h2 id="2-5-伪类选择器"><a href="#2-5-伪类选择器" class="headerlink" title="2.5 伪类选择器"></a>2.5 伪类选择器</h2><pre><code>&lt;style&gt;    a:link {        color: red;    }    /* 已访问的链接 */    a:visited {      color: green;    }    /*a标签被点击的那一刻*/    a:active {color: yellow}    /*鼠标移上去之后*/    span:hover {color: deeppink}    /*input输入框获取焦点时样式*/    input:focus {      background-color: red;    }&lt;/style&gt;</code></pre><h2 id="2-6-伪元素选择器-－１"><a href="#2-6-伪元素选择器-－１" class="headerlink" title="2.6 伪元素选择器　－１"></a>2.6 伪元素选择器　－１</h2><pre><code>&lt;style&gt;    /*没有访问*/   a:link {       color: red;   }    /*已访问的连接*/    a:visited {        color: green;    }    /*ａ标签被点击的那一刻*/    a:active {        color: yellow;    }    /*鼠标移动到便签时*/    a:hover {        color: #2b99ff;    }    /*input 点击输入框的时候的背景*/    input:focus {        background-color: red;    }&lt;/style&gt;</code></pre><h2 id="2-6-伪元素选择器-－2"><a href="#2-6-伪元素选择器-－2" class="headerlink" title="2.6 伪元素选择器　－2"></a>2.6 伪元素选择器　－2</h2><pre><code>&lt;style&gt;    /*首元素按照定义的格式*/    div.c1:first-letter {        color: red;font-size: 48px;    }    /*p标签首元素＋“×”*/    p:before {        content: &quot;lei&quot;;        color: blue;    }    /*p标签末尾加入*/    p:after {        content: &quot;[?]&quot;;        color: red;    }&lt;/style&gt;</code></pre><h2 id="元素选择器"><a href="#元素选择器" class="headerlink" title="元素选择器"></a>元素选择器</h2><pre><code>&lt;style&gt;    p {color: red}    div {color: #0000cc}&lt;/style&gt;</code></pre><h1 id="3-选择器的优先级"><a href="#3-选择器的优先级" class="headerlink" title="3. 选择器的优先级"></a>3. 选择器的优先级</h1><h2 id="3-1-当选择器相同的时候"><a href="#3-1-当选择器相同的时候" class="headerlink" title="3.1.当选择器相同的时候"></a>3.1.当选择器相同的时候</h2><pre><code>谁最后加载听谁的！</code></pre><p>##　3.2 选择器不同的时候</p><pre><code>1. 内联样式(1000) &gt; ID选择器(100) &gt; class选择器(10) &gt; 元素选择器(1)2. 不讲道理的!import</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-CSS（给HTML标签设置样式的）&quot;&gt;&lt;a href=&quot;#1-CSS（给HTML标签设置样式的）&quot; class=&quot;headerlink&quot; title=&quot;1. CSS（给HTML标签设置样式的）&quot;&gt;&lt;/a&gt;1. CSS（给HTML标签设置样式的）&lt;/h1&gt;&lt;h2
      
    
    </summary>
    
      <category term="html" scheme="http://yoursite.com/categories/html/"/>
    
    
      <category term="MySQL练习" scheme="http://yoursite.com/tags/MySQL%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>HTML初识</title>
    <link href="http://yoursite.com/2018/10/09/HTML%E5%88%9D%E8%AF%86/"/>
    <id>http://yoursite.com/2018/10/09/HTML初识/</id>
    <published>2018-10-09T13:25:52.811Z</published>
    <updated>2018-10-09T13:23:25.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="html初识"><a href="#html初识" class="headerlink" title="html初识"></a>html初识</h1><h2 id="1-CS-–-gt-BS架构"><a href="#1-CS-–-gt-BS架构" class="headerlink" title="1. CS   –&gt;  BS架构"></a>1. CS   –&gt;  BS架构</h2><h2 id="2-Web的原理"><a href="#2-Web的原理" class="headerlink" title="2. Web的原理"></a>2. Web的原理</h2><pre><code>浏览器地址栏输入URL--&gt; 浏览器往服务端发消息 --&gt; 服务端接收消息--&gt; 服务端回消息（从文件中读取数据）--&gt; 浏览器收到消息(按照一个约定好的规则展示出来)</code></pre><h2 id="3-HTML初识"><a href="#3-HTML初识" class="headerlink" title="3. HTML初识"></a>3. HTML初识</h2><pre><code>1. 就是一些特殊符号，不同的符号有不同的显示效果2. 学前端就是学怎么写HTML文件,学后端框架就是学怎么样返回写好的HTML文件</code></pre><h2 id="4-HTML规则：https-www-cnblogs-com-liwenzhou-p-7988087-html"><a href="#4-HTML规则：https-www-cnblogs-com-liwenzhou-p-7988087-html" class="headerlink" title="4. HTML规则：https://www.cnblogs.com/liwenzhou/p/7988087.html"></a>4. HTML规则：<a href="https://www.cnblogs.com/liwenzhou/p/7988087.html" target="_blank" rel="noopener">https://www.cnblogs.com/liwenzhou/p/7988087.html</a></h2><h3 id="4-1-HTML中把连续的空格和换行都解析成一个空格，不存在缩进的问题"><a href="#4-1-HTML中把连续的空格和换行都解析成一个空格，不存在缩进的问题" class="headerlink" title="4.1. HTML中把连续的空格和换行都解析成一个空格，不存在缩进的问题"></a>4.1. HTML中把连续的空格和换行都解析成一个空格，不存在缩进的问题</h3><h3 id="4-2-基本标签"><a href="#4-2-基本标签" class="headerlink" title="4.2. 基本标签"></a>4.2. 基本标签</h3><h3 id="4-3-块级标签和行内标签"><a href="#4-3-块级标签和行内标签" class="headerlink" title="4.3. 块级标签和行内标签"></a>4.3. 块级标签和行内标签</h3><pre><code>div和span标签的特点：    没有自带的样式，方便后续使用CSS调整样式！块级标签：    自己独占一行！    p    h1~h6    hr    div行内标签（内联标签）：    默认都在一行显示！    b、i、u、s    span</code></pre><h3 id="4-4-标签支持嵌套"><a href="#4-4-标签支持嵌套" class="headerlink" title="4.4. 标签支持嵌套"></a>4.4. 标签支持嵌套</h3><pre><code>1. 块级标签可以包含内联标签2. p标签不能包含p标签和div标签</code></pre><h3 id="4-5-标签分类"><a href="#4-5-标签分类" class="headerlink" title="4.5. 标签分类"></a>4.5. 标签分类</h3><pre><code>1. 展示给用户看的标签2. 获取用户输入的标签    form标签（表单标签）</code></pre><h2 id="表格-lt-DOCTYPE-html-gt"><a href="#表格-lt-DOCTYPE-html-gt" class="headerlink" title="表格&lt;!DOCTYPE html&gt;"></a>表格&lt;!DOCTYPE html&gt;</h2><pre><code>&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;!--&lt;table border=&quot;1&quot; cellpadding=&quot;10&quot; cellspacing=&quot;5&quot;&gt;--&gt;    &lt;table border=&quot;1&quot; &gt;        &lt;thead&gt;            &lt;tr&gt;                &lt;th&gt;id&lt;/th&gt;                &lt;th&gt;name&lt;/th&gt;                &lt;th&gt;pwd&lt;/th&gt;            &lt;/tr&gt;        &lt;/thead&gt;        &lt;tbody&gt;            &lt;tr&gt;                &lt;td&gt;1&lt;/td&gt;                &lt;td&gt;qwer&lt;/td&gt;                &lt;td&gt;1234&lt;/td&gt;            &lt;/tr&gt;            &lt;tr&gt;                &lt;td&gt;2&lt;/td&gt;                &lt;td&gt;qaz&lt;/td&gt;                &lt;td&gt;1234&lt;/td&gt;            &lt;/tr&gt;            &lt;tr&gt;                &lt;td&gt;3&lt;/td&gt;                &lt;td&gt;wen&lt;/td&gt;                &lt;td&gt;1234&lt;/td&gt;            &lt;/tr&gt;        &lt;/tbody&gt;    &lt;/table&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="获取用户输入的标签"><a href="#获取用户输入的标签" class="headerlink" title="获取用户输入的标签"></a>获取用户输入的标签</h2><h2 id="1-input"><a href="#1-input" class="headerlink" title="1. input"></a>1. input</h2><h3 id="1-根据type类型划分"><a href="#1-根据type类型划分" class="headerlink" title="1. 根据type类型划分"></a>1. 根据type类型划分</h3><pre><code>1. text2. password4. email5. date6. radio      --&gt; 单选7. checkbox   --&gt; 多选7. button     --&gt; 普通按钮，多用于使用JS代码绑定事件8. submit     --&gt; 提交9. reset      --&gt; 重置    10. file      --&gt; 上传文件</code></pre><h2 id="2-select"><a href="#2-select" class="headerlink" title="2. select"></a>2. select</h2><pre><code>1. select标签内部包含的是option，需要配置value属性    默认选中：selected=&quot;selected&quot;2. 多选    multiple3. textare</code></pre><h3 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h3><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;http://127.0.0.1:8081&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;    &lt;p&gt;        &lt;label for=&quot;i1&quot;&gt;用户名：&lt;/label&gt;      &lt;input id=&quot;i1&quot; type=&quot;text&quot; name=&quot;username&quot;&gt;    &lt;/p&gt;    &lt;p&gt;        &lt;label&gt;密码：            &lt;input type=&quot;password&quot; name=&quot;pwd&quot;&gt;        &lt;/label&gt;    &lt;/p&gt;    &lt;p&gt;        邮箱：        &lt;input disabled type=&quot;email&quot; name=&quot;email&quot;&gt;    &lt;/p&gt;    &lt;p&gt;出生日期：        &lt;input type=&quot;date&quot; name=&quot;birthday&quot;&gt;    &lt;/p&gt;    &lt;p&gt;        头像：        &lt;input type=&quot;file&quot; name=&quot;avatar&quot;&gt;    &lt;/p&gt;    &lt;p&gt;        隐藏的输入框：        &lt;input type=&quot;hidden&quot;&gt;    &lt;/p&gt;    &lt;p&gt;性别：        &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;male&quot; checked&gt;男        &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;female&quot;&gt;女    &lt;/p&gt;    &lt;p&gt;        爱好：        &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;basketball&quot;&gt;篮球        &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;football&quot;&gt;足球        &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;doublecolorball&quot;&gt;双色球    &lt;/p&gt;    &lt;label for=&quot;s1&quot;&gt;城市&lt;/label&gt;    &lt;select id=&quot;s1&quot; name=&quot;city1&quot;&gt;        &lt;option value=&quot;010&quot;&gt;北京&lt;/option&gt;        &lt;option value=&quot;021&quot;&gt;上海&lt;/option&gt;        &lt;option value=&quot;020&quot;&gt;广州&lt;/option&gt;        &lt;option value=&quot;0755&quot; selected=&quot;selected&quot;&gt;深圳&lt;/option&gt;    &lt;/select&gt;     &lt;select name=&quot;city2&quot; multiple=&quot;multiple&quot;&gt;            &lt;option value=&quot;010&quot;&gt;北京&lt;/option&gt;        &lt;option value=&quot;021&quot;&gt;上海&lt;/option&gt;        &lt;option value=&quot;020&quot;&gt;广州&lt;/option&gt;        &lt;option value=&quot;0755&quot; selected=&quot;selected&quot;&gt;深圳&lt;/option&gt;    &lt;/select&gt;    &lt;p&gt;        个人简介：        &lt;textarea name=&quot;info&quot;  cols=&quot;60&quot; rows=&quot;40&quot;&gt;        &lt;/textarea&gt;    &lt;/p&gt;    &lt;input type=&quot;button&quot; value=&quot;按钮&quot;&gt;    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;    &lt;input type=&quot;reset&quot; value=&quot;重置&quot;&gt;&lt;/form&gt;{&quot;name属性的值&quot;: 用户填写的内容}&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h2><pre><code>1. 所有放在form标签中获取用户输入的标签，必须要有name属性2. form标签有action属性和method属性    1. action：控制往哪里提交数据    2. method：控制用什么方式提交    3. 上传文件需要额外配置enctype=&quot;multipart/form-data&quot;3. form要提交数据必须要有submit按钮        </code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;html初识&quot;&gt;&lt;a href=&quot;#html初识&quot; class=&quot;headerlink&quot; title=&quot;html初识&quot;&gt;&lt;/a&gt;html初识&lt;/h1&gt;&lt;h2 id=&quot;1-CS-–-gt-BS架构&quot;&gt;&lt;a href=&quot;#1-CS-–-gt-BS架构&quot; class=&quot;
      
    
    </summary>
    
      <category term="html" scheme="http://yoursite.com/categories/html/"/>
    
    
      <category term="MySQL练习" scheme="http://yoursite.com/tags/MySQL%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Mysql 小练习</title>
    <link href="http://yoursite.com/2018/10/08/mysql%E7%BB%83%E4%B9%A0%20copy/"/>
    <id>http://yoursite.com/2018/10/08/mysql练习 copy/</id>
    <published>2018-10-08T12:32:11.783Z</published>
    <updated>2018-10-08T12:32:11.784Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、查询男生、女生的人数；"><a href="#1、查询男生、女生的人数；" class="headerlink" title="1、查询男生、女生的人数；"></a>1、查询男生、女生的人数；</h2><pre><code>select gender, count(gender) from student group by gender;</code></pre><p>  +——–+—————+<br>    | gender | count(gender) |<br>    +——–+—————+<br>    | 女     |             6 |<br>    | 男     |            10 |<br>    +——–+—————+</p><h2 id="2、查询姓“张”的学生名单；"><a href="#2、查询姓“张”的学生名单；" class="headerlink" title="2、查询姓“张”的学生名单；"></a>2、查询姓“张”的学生名单；</h2><pre><code>select * from student where sname like &apos;张%&apos;;</code></pre><p>  +—–+——–+———-+——–+<br>    | sid | gender | class_id | sname  |<br>    +—–+——–+———-+——–+<br>    |   3 | 男     |        1 | 张三   |<br>    |   4 | 男     |        1 | 张一   |<br>    |   5 | 女     |        1 | 张二   |<br>    |   6 | 男     |        1 | 张四   |<br>    +—–+——–+———-+——–+</p><h2 id="3、课程平均分从高到低显示"><a href="#3、课程平均分从高到低显示" class="headerlink" title="3、课程平均分从高到低显示"></a>3、课程平均分从高到低显示</h2><pre><code>select * ,avg(num) from score group by course_id order by  avg(num) asc;</code></pre><p>  +—–+————+———–+—–+———-+<br>    | sid | student_id | course_id | num | avg(num) |<br>    +—–+————+———–+—–+———-+<br>    |   1 |          1 |         1 |  10 |  53.4167 |<br>    |   8 |          2 |         3 |  68 |  64.4167 |<br>    |   2 |          1 |         2 |   9 |  65.0909 |<br>    |   5 |          1 |         4 |  66 |  85.2500 |<br>    +—–+————+———–+—–+———-+</p><h2 id="4、查询有课程成绩小于60分的同学的学号、姓名；"><a href="#4、查询有课程成绩小于60分的同学的学号、姓名；" class="headerlink" title="4、查询有课程成绩小于60分的同学的学号、姓名；"></a>4、查询有课程成绩小于60分的同学的学号、姓名；</h2><pre><code> select sname, student_id from score, student where student.sid = score.student_id and score.num &lt; 60;+--------+------------+| sname  | student_id |+--------+------------+| 理解   |          1 || 理解   |          1 || 钢蛋   |          2 || 张一   |          4 || 张二   |          5 || 张四   |          6 || 铁锤   |          7 || 李三   |          8 || 李一   |          9 || 李二   |         10 || 李四   |         11 || 如花   |         12 |+--------+------------+</code></pre><h2 id="5、查询至少有一门课与学号为1的同学所学课程相同的同学的学号和姓名；"><a href="#5、查询至少有一门课与学号为1的同学所学课程相同的同学的学号和姓名；" class="headerlink" title="5、查询至少有一门课与学号为1的同学所学课程相同的同学的学号和姓名；"></a>5、查询至少有一门课与学号为1的同学所学课程相同的同学的学号和姓名；</h2><pre><code>  select sname, sid from student where sid in (     select student_id from score where course_id in    (select course_id from score where student_id = 1)        group by student_id having student_id != 1);+--------+-----+| sname  | sid |+--------+-----+| 钢蛋   |   2 || 张三   |   3 || 张一   |   4 || 张二   |   5 || 张四   |   6 || 铁锤   |   7 || 李三   |   8 || 李一   |   9 || 李二   |  10 || 李四   |  11 || 如花   |  12 |+--------+-----+</code></pre><h2 id="6、查询出只选修了一门课程的全部学生的学号和姓名；"><a href="#6、查询出只选修了一门课程的全部学生的学号和姓名；" class="headerlink" title="6、查询出只选修了一门课程的全部学生的学号和姓名；"></a>6、查询出只选修了一门课程的全部学生的学号和姓名；</h2><pre><code>select sid, sname from student where sid in (select student_id from score group by     student_id having count(student_id) =1 );+-----+--------+| sid | sname  |+-----+--------+|  13 | 刘三   |+-----+--------+</code></pre><h2 id="7、查询各科成绩最高和最低的分：以如下形式显示：课程ID，最高分，最低分；"><a href="#7、查询各科成绩最高和最低的分：以如下形式显示：课程ID，最高分，最低分；" class="headerlink" title="7、查询各科成绩最高和最低的分：以如下形式显示：课程ID，最高分，最低分；"></a>7、查询各科成绩最高和最低的分：以如下形式显示：课程ID，最高分，最低分；</h2><pre><code>select course_id, max(num) as &apos;最高分&apos;, min(num) as &apos;最低分&apos; from score group by course_id; +-----------+-----------+-----------+| course_id | 最高分    | 最低分    |+-----------+-----------+-----------+|         1 |        91 |         8 ||         2 |       100 |         9 ||         3 |        87 |        43 ||         4 |       100 |        22 |+-----------+-----------+-----------+</code></pre><h2 id="8、查询课程编号“2”的成绩比课程编号“1”课程低的所有同学的学号、姓名；"><a href="#8、查询课程编号“2”的成绩比课程编号“1”课程低的所有同学的学号、姓名；" class="headerlink" title="8、查询课程编号“2”的成绩比课程编号“1”课程低的所有同学的学号、姓名；"></a>8、查询课程编号“2”的成绩比课程编号“1”课程低的所有同学的学号、姓名；</h2><pre><code>方法1：select sid, sname from student where (select num from score where course_id =1 and student.sid =student_id) &gt; (select num from score where course_id =2 and student.sid =student_id); 方法2：  select s1.student_id, s1.num as slnum, s2.num as s2num from score as s1, score as s2 where s1.student_id = s2.student_id and s1.course_id = 1 and s2.course_id =2 and s1.num &gt; s2.num;+------------+-------+-------+| student_id | slnum | s2num |+------------+-------+-------+|          1 |    10 |     9 ||          3 |    77 |    66 ||          4 |    79 |    11 ||          5 |    79 |    11 ||          9 |    91 |    88 ||         10 |    90 |    77 ||         11 |    90 |    77 ||         12 |    90 |    77 |+------------+-------+-------+</code></pre><h2 id="9、查询“生物”课程比“物理”课程成绩高的所有学生的学号；"><a href="#9、查询“生物”课程比“物理”课程成绩高的所有学生的学号；" class="headerlink" title="9、查询“生物”课程比“物理”课程成绩高的所有学生的学号；"></a>9、查询“生物”课程比“物理”课程成绩高的所有学生的学号；</h2><pre><code>方法 1： 分开查询select student.sid, student.sname from student where  (select num from score, course  where course_id = course.cid and course.cname = &apos;生物&apos; and student_id=student.sid) &gt;   (select num from score, course  where course_id = course.cid and course.cname = &apos;物理&apos; and student_id= student.sid);方法2：select s1.student_id from score as s1, score as s2 where-&gt; s1.student_id = s2.student_id and s1.course_id =(select cid from course where cname = &apos;生物&apos;) and s2.course_id =(select cid from course where cname =&apos;物理&apos;) and s1.num &gt; s2.num;+------------+| student_id |+------------+|          1 ||          3 ||          4 ||          5 ||          9 ||         10 ||         11 ||         12 |+------------+</code></pre><h2 id="10、查询平均成绩大于60分的同学的学号和平均成绩"><a href="#10、查询平均成绩大于60分的同学的学号和平均成绩" class="headerlink" title="10、查询平均成绩大于60分的同学的学号和平均成绩;"></a>10、查询平均成绩大于60分的同学的学号和平均成绩;</h2><pre><code>select sid, avg(num) from score group by student_id having avg(num) &gt; 60;</code></pre><h2 id="11、查询所有同学的学号、姓名、选课数、总成绩；"><a href="#11、查询所有同学的学号、姓名、选课数、总成绩；" class="headerlink" title="11、查询所有同学的学号、姓名、选课数、总成绩；"></a>11、查询所有同学的学号、姓名、选课数、总成绩；</h2><pre><code>select student.sname as 姓名, score.student_id as 学号, count(score.course_id) as 选课数,  sum(score.num) as 总成绩 from student ,score where student.sid = score.student_id group by score.student_id;+--------+--------+-----------+-----------+| 姓名   | 学号   | 选课数    | 总成绩    |+--------+--------+-----------+-----------+| 理解   |      1 |         3 |        85 || 钢蛋   |      2 |         3 |       175 || 张三   |      3 |         4 |       329 || 张一   |      4 |         4 |       257 || 张二   |      5 |         4 |       257 || 张四   |      6 |         4 |       276 || 铁锤   |      7 |         4 |       264 || 李三   |      8 |         4 |       264 || 李一   |      9 |         4 |       268 || 李二   |     10 |         4 |       297 || 李四   |     11 |         4 |       297 || 如花   |     12 |         4 |       297 || 刘三   |     13 |         1 |        87 |+--------+--------+-----------+-----------+</code></pre><h2 id="12、查询姓“李”的老师的个数；"><a href="#12、查询姓“李”的老师的个数；" class="headerlink" title="12、查询姓“李”的老师的个数；"></a>12、查询姓“李”的老师的个数；</h2><pre><code>方法1；select  count(tname) from teacher where tname like &apos;李%&apos;;方法2；select count(tid) from teacher where tname like &apos;李%&apos;;+--------------+| count(tname) |+--------------+|            2 |+--------------+</code></pre><h2 id="13、查询没学过“张磊老师”课的同学的学号、姓名；"><a href="#13、查询没学过“张磊老师”课的同学的学号、姓名；" class="headerlink" title="13、查询没学过“张磊老师”课的同学的学号、姓名；"></a>13、查询没学过“张磊老师”课的同学的学号、姓名；</h2><pre><code>select sid, sname from student where sid not in ( select student_id from score where course_id =(  select cid from course where teacher_id=( select tid from teacher where tname = &apos;张磊老师&apos;)));</code></pre><h2 id="14、查询学过“1”并且也学过编号“2”课程的同学的学号、姓名；"><a href="#14、查询学过“1”并且也学过编号“2”课程的同学的学号、姓名；" class="headerlink" title="14、查询学过“1”并且也学过编号“2”课程的同学的学号、姓名；"></a>14、查询学过“1”并且也学过编号“2”课程的同学的学号、姓名；</h2><pre><code>select sid, sname from student where sid in ( select s1.student_id from score as s1, score as s2 where s1.student_id = s2.student_id and s1.course_id = 1 and  s2.course_id =2);+-----+--------+| sid | sname  |+-----+--------+|   1 | 理解   ||   3 | 张三   ||   4 | 张一   ||   5 | 张二   ||   6 | 张四   ||   7 | 铁锤   ||   8 | 李三   ||   9 | 李一   ||  10 | 李二   ||  11 | 李四   ||  12 | 如花   |+-----+--------+</code></pre><h2 id="15、查询学过“李平老师”所教的所有课的同学的学号、姓名；"><a href="#15、查询学过“李平老师”所教的所有课的同学的学号、姓名；" class="headerlink" title="15、查询学过“李平老师”所教的所有课的同学的学号、姓名；"></a>15、查询学过“李平老师”所教的所有课的同学的学号、姓名；</h2><pre><code>select sid, sname from student where sid in ( select student_id from score where course_id in ( select cid from course where teacher_id =( select tid from teacher where tname = &apos;李平老师&apos;)) group by student_id);+-----+--------+| sid | sname  |+-----+--------+|   1 | 理解   ||   2 | 钢蛋   ||   3 | 张三   ||   4 | 张一   ||   5 | 张二   ||   6 | 张四   ||   7 | 铁锤   ||   8 | 李三   ||   9 | 李一   ||  10 | 李二   ||  11 | 李四   ||  12 | 如花   |+-----+--------+</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1、查询男生、女生的人数；&quot;&gt;&lt;a href=&quot;#1、查询男生、女生的人数；&quot; class=&quot;headerlink&quot; title=&quot;1、查询男生、女生的人数；&quot;&gt;&lt;/a&gt;1、查询男生、女生的人数；&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;select gender, cou
      
    
    </summary>
    
      <category term="mysql" scheme="http://yoursite.com/categories/mysql/"/>
    
    
      <category term="MySQL练习" scheme="http://yoursite.com/tags/MySQL%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Mysql增删改查</title>
    <link href="http://yoursite.com/2018/10/08/Mysql%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/"/>
    <id>http://yoursite.com/2018/10/08/Mysql增删改查/</id>
    <published>2018-10-08T08:11:58.327Z</published>
    <updated>2018-10-08T08:25:53.468Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL数据操作： DML<br>在MySQL管理软件中，可以通过SQL语句中的DML语言来实现数据的操作，包括</p><ol><li>使用INSERT实现数据的插入</li><li>UPDATE实现数据的更新</li><li>使用DELETE实现数据的删除</li><li>使用SELECT查询数据以及。</li></ol><h1 id="insert-插入数据"><a href="#insert-插入数据" class="headerlink" title="insert 插入数据"></a>insert 插入数据</h1><h2 id="插入完整数据"><a href="#插入完整数据" class="headerlink" title="插入完整数据"></a>插入完整数据</h2><pre><code>insert into class values(1, &apos;语文&apos;);</code></pre><h2 id="插入指定字段数据"><a href="#插入指定字段数据" class="headerlink" title="插入指定字段数据"></a>插入指定字段数据</h2><pre><code>insert into class(name) values(&apos;数学&apos;);</code></pre><h2 id="插入多条的数据"><a href="#插入多条的数据" class="headerlink" title="插入多条的数据"></a>插入多条的数据</h2><pre><code>insert into class(name) values(&apos;数学&apos;), (&apos;物理&apos;), (&apos;化学&apos;), (&apos;历史&apos;);</code></pre><h2 id="插入查询结果"><a href="#插入查询结果" class="headerlink" title="插入查询结果"></a>插入查询结果</h2><pre><code>insert into student(class_id) select id from class where name = &apos;语文&apos;;</code></pre><h2 id="导入sql文件"><a href="#导入sql文件" class="headerlink" title="导入sql文件"></a>导入sql文件</h2><pre><code>source /root/init.sql</code></pre><h1 id="update-更新数据"><a href="#update-更新数据" class="headerlink" title="update 更新数据"></a>update 更新数据</h1><pre><code>update class set name = &apos; 文学&apos; where id = 1;</code></pre><h1 id="delete-删除数据"><a href="#delete-删除数据" class="headerlink" title="delete 删除数据"></a>delete 删除数据</h1><pre><code>delete from class where id = 1;删除id = 1的数据</code></pre><h1 id="select查询–单表查询"><a href="#select查询–单表查询" class="headerlink" title="select查询–单表查询"></a>select查询–单表查询</h1><h3 id="单表查询的语法"><a href="#单表查询的语法" class="headerlink" title="单表查询的语法"></a>单表查询的语法</h3><pre><code>SELECT 字段1,字段2... FROM 表名                     WHERE 条件                     GROUP BY field                     HAVING 筛选                     ORDER BY field                     LIMIT 限制条数</code></pre><h3 id="关键字执行的优先级"><a href="#关键字执行的优先级" class="headerlink" title="关键字执行的优先级"></a>关键字执行的优先级</h3><pre><code>fromwheregroup byhavingselectdistinctorder bylimit1.找到表:from2.拿着where指定的约束条件，去文件/表中取出一条条记录3.将取出的一条条记录进行分组group by，如果没有group by，则整体作为一组4.将分组的结果进行having过滤5.执行select6.去重7.将结果按条件排序：order by8.限制结果的显示条数</code></pre><h2 id="简单查询"><a href="#简单查询" class="headerlink" title="简单查询"></a>简单查询</h2><h3 id="按字段查找"><a href="#按字段查找" class="headerlink" title="按字段查找"></a>按字段查找</h3><pre><code>select 字段,字段，... from 表;</code></pre><h3 id="查询所有"><a href="#查询所有" class="headerlink" title="查询所有"></a>查询所有</h3><pre><code>select * from 表;</code></pre><h3 id="避免重复-distinct"><a href="#避免重复-distinct" class="headerlink" title="避免重复 distinct"></a>避免重复 distinct</h3><pre><code>select distinct 字段 from 表;</code></pre><h3 id="通过四则运算查询"><a href="#通过四则运算查询" class="headerlink" title="通过四则运算查询"></a>通过四则运算查询</h3><pre><code>1. select 字段, 字段（能进行运算的类型） from 表;2. select 字段, 字段（能进行运算的类型）  as 别名 from 表;</code></pre><h3 id="定义显示格式"><a href="#定义显示格式" class="headerlink" title="定义显示格式"></a>定义显示格式</h3><pre><code>连接字符串 concat()select concat(&apos;姓名:&apos;, emp_name, &apos;年薪:&apos;, salary*12) as Annual_salary from employee;</code></pre><h3 id="以第一个参数为分隔符-concan-ws"><a href="#以第一个参数为分隔符-concan-ws" class="headerlink" title="以第一个参数为分隔符() concan_ws"></a>以第一个参数为分隔符() concan_ws</h3><pre><code>select concat_ws(&apos;:&apos;, emp_name, salary*12) as Annual_salary from employee;</code></pre><h3 id="结合case语句："><a href="#结合case语句：" class="headerlink" title="结合case语句："></a>结合case语句：</h3><pre><code>条件判断符合条件进行字符串拼接SELECT   (       CASE       WHEN emp_name = &apos;jingliyang&apos; THEN           emp_name       WHEN emp_name = &apos;alex&apos; THEN           CONCAT(emp_name,&apos;_BIGSB&apos;)       ELSE           concat(emp_name, &apos;SB&apos;)       END   ) as new_name</code></pre><p>   FROM<br>       employee;</p><h2 id="where约束"><a href="#where约束" class="headerlink" title="where约束"></a>where约束</h2><ol><li>比较运算符：&gt; &lt; &gt;= &lt;= &lt;&gt; !=</li><li>between 80 and 100 值在10到20之间</li><li>in(80,90,100) 值是10或20或30</li><li>like ‘egon%’<br> pattern可以是%或_，<br> %表示任意多字符<br> _表示一个字符 </li><li>逻辑运算符：在多个条件直接可以使用逻辑运算符 and or not<h3 id="单条件查询"><a href="#单条件查询" class="headerlink" title="单条件查询"></a>单条件查询</h3></li></ol><pre><code>查询所以 post =&apos;sale&apos; 数据select emp_name from employee where post =&apos;sale&apos;;</code></pre><h3 id="多条件查询"><a href="#多条件查询" class="headerlink" title="多条件查询"></a>多条件查询</h3><pre><code>and 多条件select emp_name, salary  from employee where post =&apos;teacher&apos; and salary &gt; 1000;between 在指定范围内 and是指定范围not between 不在指定范围select emp_name, salary  from employee where salary between 10000 and 20000;</code></pre><h3 id="关键字IS-NULL-判断某个字段是否为NULL不能用等号，需要用IS"><a href="#关键字IS-NULL-判断某个字段是否为NULL不能用等号，需要用IS" class="headerlink" title="关键字IS NULL(判断某个字段是否为NULL不能用等号，需要用IS)"></a>关键字IS NULL(判断某个字段是否为NULL不能用等号，需要用IS)</h3><pre><code>需要注意 空字符串不是nullselect emp_name, post_comment from employee where post_comment is null;</code></pre><h3 id="关键字IN集合查SELECT-emp-name-salary-FROM-employee"><a href="#关键字IN集合查SELECT-emp-name-salary-FROM-employee" class="headerlink" title="关键字IN集合查SELECT emp_name,salary FROM employee"></a>关键字IN集合查SELECT emp_name,salary FROM employee</h3><pre><code>or 满足一个就行WHERE salary=3000 OR salary=3500 OR salary=4000 OR salary=9000 ;in 代替了 or语句SELECT emp_name,salary FROM employee     WHERE salary IN (3000,3500,4000,9000) ;不在in集合里面SELECT emp_name,salary FROM employee     WHERE salary NOT IN (3000,3500,4000,9000) ;</code></pre><p>###关键字LIKE模糊查询<br>    通配符’%’ 所有<br>    SELECT * FROM employee<br>            WHERE emp_name LIKE ‘eg%’;</p><pre><code>通配符’_’_ 一个占位一个字符SELECT * FROM employee         WHERE emp_name LIKE &apos;al__&apos;;</code></pre><h3 id="group-by"><a href="#group-by" class="headerlink" title="group by"></a>group by</h3><p>单独使用GROUP BY关键字分组<br>    SELECT post FROM employee GROUP BY post;<br>    注意：我们按照post字段分组，那么select查询的字段只能是post，想要获取组内的其他相关信息，需要借助函数</p><h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><p><strong>强调：聚合函数聚合的是组的内容，若是没有分组，则默认一组</strong></p><pre><code>示例：SELECT COUNT(*) FROM employee;SELECT COUNT(*) FROM employee WHERE depart_id=1;SELECT MAX(salary) FROM employee;SELECT MIN(salary) FROM employee;SELECT AVG(salary) FROM employee;SELECT SUM(salary) FROM employee;SELECT SUM(salary) FROM employee WHERE depart_id=3;</code></pre><h3 id="HAVING过滤"><a href="#HAVING过滤" class="headerlink" title="HAVING过滤"></a>HAVING过滤</h3><p>HAVING与WHERE不一样的地方在于!!!!!!</p><pre><code>！！！执行优先级从高到低：where &gt; group by &gt; having 1. Where 发生在分组group by之前，因而Where中可以有任意字段，但是绝对不能使用聚合函数。2. Having发生在分组group by之后，因而Having中可以使用分组的字段，无法直接取到其他字段,可以使用聚合函数</code></pre><h3 id="ORDER-BY-查询排序"><a href="#ORDER-BY-查询排序" class="headerlink" title="ORDER BY 查询排序"></a>ORDER BY 查询排序</h3><pre><code>按单列排序SELECT * FROM employee ORDER BY salary; #默认SELECT * FROM employee ORDER BY salary ASC; #从小到大SELECT * FROM employee ORDER BY salary DESC; #从大到小</code></pre><h3 id="LIMIT-限制查询的记录数"><a href="#LIMIT-限制查询的记录数" class="headerlink" title="LIMIT 限制查询的记录数"></a>LIMIT 限制查询的记录数</h3><pre><code>  SELECT * FROM employee ORDER BY salary DESC     LIMIT 3;      #默认初始位置为0，向后查询3条 SELECT * FROM employee ORDER BY salary DESC    LIMIT 5,5; #从第5开始，即先查询出第一条，然后包含这一条在内往后查5条</code></pre><h3 id="使用正则表达式查询"><a href="#使用正则表达式查询" class="headerlink" title="使用正则表达式查询"></a>使用正则表达式查询</h3><pre><code>SELECT * FROM employee WHERE emp_name REGEXP &apos;^ale&apos;;SELECT * FROM employee WHERE emp_name REGEXP &apos;on$&apos;;SELECT * FROM employee WHERE emp_name REGEXP &apos;m{2}&apos;;小结：对字符串匹配的方式WHERE emp_name = &apos;egon&apos;;WHERE emp_name LIKE &apos;yua%&apos;;WHERE emp_name REGEXP &apos;on$&apos;;</code></pre><h1 id="select查询–多表查询"><a href="#select查询–多表查询" class="headerlink" title="select查询–多表查询"></a>select查询–多表查询</h1><h2 id="交叉连接：不适用任何匹配条件。生成笛卡尔积"><a href="#交叉连接：不适用任何匹配条件。生成笛卡尔积" class="headerlink" title="交叉连接：不适用任何匹配条件。生成笛卡尔积"></a>交叉连接：不适用任何匹配条件。生成笛卡尔积</h2><pre><code>select * from 表一, 表2;</code></pre><h2 id="内连接：只连接匹配的行"><a href="#内连接：只连接匹配的行" class="headerlink" title="内连接：只连接匹配的行"></a>内连接：只连接匹配的行</h2><pre><code>主要语法： 表 inner join  表 （建立连接）  on （条件）**employee inner join departmenton employee.dep_id=department.id;  //可换成where employee.dep_id=department.id**select employee.id,employee.name,employee.age,employee.sex,department.namefrom employee inner join departmenton employee.dep_id=department.id;</code></pre><h2 id="外链接之左连接：优先显示左表全部记录"><a href="#外链接之左连接：优先显示左表全部记录" class="headerlink" title="外链接之左连接：优先显示左表全部记录"></a>外链接之左连接：优先显示左表全部记录</h2><pre><code>#以左表为准，即找出所有员工信息，当然包括没有部门的员工#本质就是：在内连接的基础上增加左边有右边没有的结果mysql&gt; select employee.id,employee.name,department.name as depart_name from employee left join department on  #右边没有的选项也匹配， 以左边为准 employee.dep_id=department.id;</code></pre><h2 id="外链接之右连接：优先显示右表全部记录"><a href="#外链接之右连接：优先显示右表全部记录" class="headerlink" title="外链接之右连接：优先显示右表全部记录"></a>外链接之右连接：优先显示右表全部记录</h2><pre><code>和左连接一样 关键字right</code></pre><h2 id="全外连接：显示左右两个表全部记录"><a href="#全外连接：显示左右两个表全部记录" class="headerlink" title="全外连接：显示左右两个表全部记录"></a>全外连接：显示左右两个表全部记录</h2><p>全外连接：在内连接的基础上增加左边有右边没有的和右边有左边没有的结果<br><strong>注意：mysql不支持全外连接 full JOIN</strong><br><strong>强调：mysql可以使用此种方式间接实现全外连接</strong><br>    思路： 查询两个表用union 连接起来<br>    select <em> from employee left join department on employee.dep_id = department.id<br>    union<br>    select </em> from employee right join department on employee.dep_id = department.id</p><h2 id="符合条件连接查询"><a href="#符合条件连接查询" class="headerlink" title="符合条件连接查询"></a>符合条件连接查询</h2><h3 id="内连接的方式查询加入判断条件"><a href="#内连接的方式查询加入判断条件" class="headerlink" title="内连接的方式查询加入判断条件"></a>内连接的方式查询加入判断条件</h3><pre><code>select employee.name,department.name from employee inner join departmenton employee.dep_id = department.idwhere age &gt; 25;</code></pre><h3 id="内连接-asc-升序排列"><a href="#内连接-asc-升序排列" class="headerlink" title="内连接 asc 升序排列"></a>内连接 asc 升序排列</h3><pre><code>select employee.id,employee.name,employee.age,department.name from employee,departmentwhere employee.dep_id = department.idand age &gt; 25order by age asc;</code></pre><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>1：子查询是将一个查询语句嵌套在另一个查询语句中。<br>2：内层查询语句的查询结果，可以为外层查询语句提供查询条件。<br>3：子查询中可以包含：IN、NOT IN、ANY、ALL、EXISTS 和 NOT EXISTS等关键字<br>4：还可以包含比较运算符：= 、 !=、&gt; 、&lt;等</p><h3 id="带IN关键字的子查询"><a href="#带IN关键字的子查询" class="headerlink" title="带IN关键字的子查询"></a>带IN关键字的子查询</h3><pre><code>avg（求平均值） group by 那个组select id, name from department  where id in (select dep_id  from employee group by dep_id having avg(age) &gt; 25);distinct 不同的 结果是查询人数不足一个也就是没有的人的部门select name from department where id not in (select distinct dep_id from employee);</code></pre><h3 id="带比较运算符的子查询"><a href="#带比较运算符的子查询" class="headerlink" title="带比较运算符的子查询"></a>带比较运算符的子查询</h3><p>比较运算符：=、!=、&gt;、&gt;=、&lt;、&lt;=、&lt;&gt;<br>查询大于所有人平均年龄的员工名与年龄</p><pre><code> select name, age from employee where age &gt; (select avg(age) from employee);select t1.name,t1.age from employee    select t1.name,t1.age from employeeinner join(select dep_id,avg(age) avg_age from employee group by dep_id)on t1.dep_id = t2.dep_idwhere t1.age &gt; t2.avg_age; 查询大于部门内平均年龄的员工名、年龄#语法分析： 1.(select dep_id,avg(age) avg_age from employee group by dep_id) 形成一个新表avg_age2.inner join 连接select employee.name,employee.age from employeeinner join (select dep_id,avg(age) avg_age from employee group by dep_id) departmenton employee.dep_id = department.dep_idwhere employee.age &gt; department.avg_age;  </code></pre><h3 id="带EXISTS关键字的子查询"><a href="#带EXISTS关键字的子查询" class="headerlink" title="带EXISTS关键字的子查询"></a>带EXISTS关键字的子查询</h3><p>EXISTS关字键字表示存在。在使用EXISTS关键字时，内层查询语句不返回查询的记录。<br>而是返回一个真假值。True或False<br>当返回True时，外层查询语句将进行查询；当返回值为False时，外层查询语句不进行查询<br>    当子查询为true 显示结果 否则不显示<br>    select * from employee<br>        where exists<br>        (select id from department where id = 200);</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;MySQL数据操作： DML&lt;br&gt;在MySQL管理软件中，可以通过SQL语句中的DML语言来实现数据的操作，包括&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用INSERT实现数据的插入&lt;/li&gt;
&lt;li&gt;UPDATE实现数据的更新&lt;/li&gt;
&lt;li&gt;使用DELETE实现数据的删除&lt;/l
      
    
    </summary>
    
      <category term="mysql" scheme="http://yoursite.com/categories/mysql/"/>
    
    
      <category term="数据操作" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>PyMysql模块学习</title>
    <link href="http://yoursite.com/2018/10/08/Python_mysql/"/>
    <id>http://yoursite.com/2018/10/08/Python_mysql/</id>
    <published>2018-10-08T06:47:14.000Z</published>
    <updated>2018-10-08T08:01:08.858Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一：连接Mysql数据库"><a href="#一：连接Mysql数据库" class="headerlink" title="一：连接Mysql数据库"></a>一：连接Mysql数据库</h1><p>1.1连接条件：</p><ol><li>首先有个启动的mysql数据</li><li>有连接数据库的账号和密码</li><li>有权限操作数据库</li></ol><p>1.2使用pymysql</p><pre><code>import pymysql  #导入模块conn = pymysql.connect(    host=&apos;127.0.0.1&apos;,  #连接地址    port=&apos;3306&apos;,  #端口    user=&apos;root&apos;,  #mysql用户名    password=&apos;123&apos;,  #密码    database=&apos;db1008&apos;,  #数据库    charset=&apos;utf8&apos;  #编码方式)cursor = conn.cursor()  #获取光标对象，才可以操作数据库cursor.execute(&apos;show tables;&apos;)  #执行sql操作cursor.close()  #关闭光标conn.close()  #关闭连接</code></pre><h1 id="二：使用pymsql增删改查"><a href="#二：使用pymsql增删改查" class="headerlink" title="二：使用pymsql增删改查"></a>二：使用pymsql增删改查</h1><h2 id="2-1增删改（用到的操作相似）"><a href="#2-1增删改（用到的操作相似）" class="headerlink" title="2.1增删改（用到的操作相似）"></a>2.1增删改（用到的操作相似）</h2><pre><code>import pymysqlconn = pymysql.connect(    host=&apos;127.0.0.1&apos;,    port=3306,    user=&apos;root&apos;,    password=&apos;123&apos;,    database=&apos;db1008&apos;,    charset=&apos;utf8&apos;)cursor = conn.cursor()name = input(&apos;input_name:&apos;)pwd = input(&apos;inputZ_pwd:&apos;)#增加操作sql = &apos;insert into userinfo(username, possword) values(%s, %s);&apos;cursor.execute(sql,[name, pwd])  #防止SQL注入问题conn.commit()  #更新数据库 否则添加失败conn.rollback() 回滚取消操作。不进行添加#删除操作sql = &apos;delete from userinfo where username=%s and possword=%s&apos;cursor.execute(sql,[name, pwd])  #防止SQL注入问题#改操作sql = &apos;update userinfo set username=%s  where  possword=%s&apos;cursor.execute(sql,[name, pwd])  #防止SQL注入问题cursor.close()conn.close()</code></pre><h3 id="2-1-1-获取插入数据的ID-关联操作时会用到"><a href="#2-1-1-获取插入数据的ID-关联操作时会用到" class="headerlink" title="2.1.1 获取插入数据的ID(关联操作时会用到)"></a>2.1.1 获取插入数据的ID(关联操作时会用到)</h3><pre><code>import pymysqlconn = pymysql.connect(    host=&apos;127.0.0.1&apos;,    port=3306,    user=&apos;root&apos;,    password=&apos;123&apos;,    database=&apos;db1008&apos;,    charset=&apos;utf8&apos;)cursor = conn.cursor()name = input(&apos;input_name:&apos;)pwd = input(&apos;inputZ_pwd:&apos;)sql = &quot;insert into userinfo values(3,%s,%s);&quot;cursor.execute(sql, [name, pwd])conn.commit()id = cursor.lastrowidprint(id)cursor.close()conn.close()</code></pre><h2 id="2-2查询"><a href="#2-2查询" class="headerlink" title="2.2查询"></a>2.2查询</h2><h3 id="ret-cursor-fetchone-单行查询"><a href="#ret-cursor-fetchone-单行查询" class="headerlink" title="ret = cursor.fetchone()  # 单行查询"></a>ret = cursor.fetchone()  # 单行查询</h3><h3 id="ret-cursor-fetchall-查询所有的条件"><a href="#ret-cursor-fetchall-查询所有的条件" class="headerlink" title="ret = cursor.fetchall()  # 查询所有的条件"></a>ret = cursor.fetchall()  # 查询所有的条件</h3><h3 id="ret-cursor-fetchmany-2-查询2条"><a href="#ret-cursor-fetchmany-2-查询2条" class="headerlink" title="ret = cursor.fetchmany(2)  # 查询2条"></a>ret = cursor.fetchmany(2)  # 查询2条</h3><pre><code>import pymysqlconn = pymysql.connect(    host=&apos;127.0.0.1&apos;,    port=3306,    user=&apos;root&apos;,    password=&apos;123&apos;,    database=&apos;db1008&apos;,    charset=&apos;utf8&apos;)cursor = conn.cursor()name = input(&apos;input_name:&apos;)pwd = input(&apos;inputZ_pwd:&apos;)sql = &quot;select * from userinfo;&quot;cursor.execute(sql)# ret = cursor.fetchone()  # 单行查询# ret = cursor.fetchall()  # 查询所有的条件ret = cursor.fetchmany(2)  # 查询2条print(ret)cursor.close()conn.close()</code></pre><h3 id="2-2-1-进阶用法-移动光标"><a href="#2-2-1-进阶用法-移动光标" class="headerlink" title="2.2.1 进阶用法 移动光标"></a>2.2.1 进阶用法 移动光标</h3><pre><code># 可以获取指定数量的数据cursor.fetchmany(3)# 光标按绝对位置移动1cursor.scroll(1, mode=&quot;absolute&quot;)# 光标按照相对位置(当前位置)移动1cursor.scroll(1, mode=&quot;relative&quot;)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一：连接Mysql数据库&quot;&gt;&lt;a href=&quot;#一：连接Mysql数据库&quot; class=&quot;headerlink&quot; title=&quot;一：连接Mysql数据库&quot;&gt;&lt;/a&gt;一：连接Mysql数据库&lt;/h1&gt;&lt;p&gt;1.1连接条件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先有个启动的m
      
    
    </summary>
    
      <category term="mysql" scheme="http://yoursite.com/categories/mysql/"/>
    
    
      <category term="数据操作Python" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9CPython/"/>
    
  </entry>
  
  <entry>
    <title>多表结构的创建与分析</title>
    <link href="http://yoursite.com/2018/10/04/%E5%A4%9A%E8%A1%A8%E7%BB%93%E6%9E%84%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2018/10/04/多表结构的创建与分析/</id>
    <published>2018-10-04T05:34:28.019Z</published>
    <updated>2018-10-04T05:37:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分析步骤："><a href="#分析步骤：" class="headerlink" title="分析步骤："></a>分析步骤：</h1><h2 id="1、先站在左表的角度去找"><a href="#1、先站在左表的角度去找" class="headerlink" title="1、先站在左表的角度去找"></a>1、先站在左表的角度去找</h2><p>是否左表的多条记录可以对应右表的一条记录，如果是，则证明左表的一个字段foreign key 右表一个字段（通常是id）</p><h2 id="2、再站在右表的角度去找"><a href="#2、再站在右表的角度去找" class="headerlink" title="2、再站在右表的角度去找"></a>2、再站在右表的角度去找</h2><p>是否右表的多条记录可以对应左表的一条记录，如果是，则证明右表的一个字段foreign key 左表一个字段（通常是id）</p><h2 id="3、总结："><a href="#3、总结：" class="headerlink" title="3、总结："></a>3、总结：</h2><h3 id="多对一："><a href="#多对一：" class="headerlink" title="多对一："></a>多对一：</h3><p>如果只有步骤1成立，则是左表多对一右表<br>如果只有步骤2成立，则是右表多对一左表</p><p>###多对多<br>如果步骤1和2同时成立，则证明这两张表时一个双向的多对一，即多对多,需要定义一个这两张表的关系表来专门存放二者的关系</p><p>###一对一:<br>如果1和2都不成立，而是左表的一条记录唯一对应右表的一条记录，反之亦然。这种情况很简单，就是在左表foreign key右表的基础上，将左表的外键字段设置成unique即可</p><h1 id="建立表之间的关系"><a href="#建立表之间的关系" class="headerlink" title="建立表之间的关系"></a>建立表之间的关系</h1><h2 id="一对多或称为多对一"><a href="#一对多或称为多对一" class="headerlink" title="一对多或称为多对一"></a>一对多或称为多对一</h2><pre><code>三张表：出版社，作者信息，书一对多（或多对一）：一个出版社可以出版多本书关联方式：foreign key  references 关联标的字段（ press(id)）</code></pre><h3 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h3><h4 id="创建一个表"><a href="#创建一个表" class="headerlink" title="创建一个表"></a>创建一个表</h4><pre><code>create table press( id int primary key auto_increment, name varchar(20) );</code></pre><h4 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h4><pre><code>create table book(    id int primary key auto_increment,    name varchar(20),    press_id int not null,    foreign key(press_id) references press(id)    on delete cascade    on update cascade    );</code></pre><h3 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h3><pre><code>一个表可以关联多个表， 和多个表建立关系</code></pre><p>####代码实例</p><pre><code>#创建一个表create table class(       id int not null primary key auto_increment,    name varchar(20)    );create table course( cid int not null primary key auto_increment, name varchar(20) );#创建多个连接create table student( s_id int not null primary key auto_increment,     name varchar(20), 、class_id int,foreign key(class_id) references class(id) on delete cascade on update cascade ,course_id int,foreign key(course_id) references course(cid)  on delete cascade on update cascade);</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;分析步骤：&quot;&gt;&lt;a href=&quot;#分析步骤：&quot; class=&quot;headerlink&quot; title=&quot;分析步骤：&quot;&gt;&lt;/a&gt;分析步骤：&lt;/h1&gt;&lt;h2 id=&quot;1、先站在左表的角度去找&quot;&gt;&lt;a href=&quot;#1、先站在左表的角度去找&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="mysql" scheme="http://yoursite.com/categories/mysql/"/>
    
    
      <category term="多表" scheme="http://yoursite.com/tags/%E5%A4%9A%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>mysql基础</title>
    <link href="http://yoursite.com/2018/10/04/Mysql/"/>
    <id>http://yoursite.com/2018/10/04/Mysql/</id>
    <published>2018-10-04T04:31:00.000Z</published>
    <updated>2018-10-04T05:38:57.569Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一：数据库在未来的开发的地位"><a href="#一：数据库在未来的开发的地位" class="headerlink" title="一：数据库在未来的开发的地位"></a>一：数据库在未来的开发的地位</h1><pre><code># 后台/后端    # 复杂的代码 隐藏在后端# 前端    # 返回到前端 装饰一下 给别人看# python基础    # 后端程序的开发        # 数据的处理 （增删改查）# 员工信息表、选课系统    # 使用python和文件一起写程序的弊端：        # 结果不好看 需要在控制台、终端控制        # 文件的处理非常繁琐 ：增加 删除# 帮助你 管理 存储了数据的文件    # 更加方便、快速的实现数据的增 删 改 查# python + 数据库（存取数据） + 文件（记录日志）# 结果不好看 需要在控制台、终端控制</code></pre><h1 id="二：数据库中的几个概念"><a href="#二：数据库中的几个概念" class="headerlink" title="二：数据库中的几个概念"></a>二：数据库中的几个概念</h1><h2 id="记录、数据-data"><a href="#记录、数据-data" class="headerlink" title="记录、数据 data"></a>记录、数据 data</h2><pre><code># id,name,passwd,age,number# 1,alex,alex3714,83,13838384438   # 一条记录# 表 table# userinfo    # 一张表就是一个文件# 1,alex,alex3714,83,13838384438# 1,alex,alex3714,83,13838384438# 1,alex,alex3714,83,13838384438</code></pre><h2 id="库-base"><a href="#库-base" class="headerlink" title="库 base"></a>库 base</h2><pre><code># 选课系统     userinfo/studentinfo/courseinfo# 员工信息表   userinfo# ftp          userinfo# mysql这个软件来管理数据# 只有一个mysql来管理你的程序，# 你的程序之间的数据应该是隔离的# 创建两个文件夹 ：选课系统、员工信息表# 所谓数据库中的库 就是文件夹    # 一般情况下 每个程序使用一个库</code></pre><h2 id="数据库管理系统-dbms"><a href="#数据库管理系统-dbms" class="headerlink" title="数据库管理系统 dbms"></a>数据库管理系统 dbms</h2><pre><code># database management system# 能够通过一个软件来管理文件、文件夹、数据# 数据库服务器# 你把你的数据装在哪台机器上 这台机器就是数据库服务器# 关系型数据库和非关系型数据库# 关系型    # 一条数据包含了一个事物的多条信息，这些信息之间是有关联性的# 非关系型  :存取频繁的，并且要求效率高的，不突出数据之间关联的    # k-v    # id content</code></pre><h2 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h2><pre><code># mysql       开源# oracle      企业级# sqlite      轻量级# sql server  大学</code></pre><h2 id="非关系型数据库-：消息转发"><a href="#非关系型数据库-：消息转发" class="headerlink" title="非关系型数据库  ：消息转发"></a>非关系型数据库  ：消息转发</h2><pre><code># memcache# redis# MongoDB# nosql</code></pre><h1 id="数据库的基本操作"><a href="#数据库的基本操作" class="headerlink" title="数据库的基本操作"></a>数据库的基本操作</h1><h2 id="启动server端-可以在service服务中操作"><a href="#启动server端-可以在service服务中操作" class="headerlink" title="启动server端  - 可以在service服务中操作"></a>启动server端  - 可以在service服务中操作</h2><pre><code># (win)&gt;net start mysql</code></pre><h3 id="使用默认用户启动mysql客户端，默认的用户登录-是没有权限查看所有库的"><a href="#使用默认用户启动mysql客户端，默认的用户登录-是没有权限查看所有库的" class="headerlink" title="使用默认用户启动mysql客户端，默认的用户登录 是没有权限查看所有库的"></a>使用默认用户启动mysql客户端，默认的用户登录 是没有权限查看所有库的</h3><pre><code># &gt;mysql 表示启动mysql 客户端# mysql&gt; select user();  # 查看当前登录的用户    # liqinyang@192.168.16.53 # 用户名@ip地址# mysql&gt; show databases; # 查看所有的库# mysql&gt; exit  # 退出当前的客户端</code></pre><h3 id="指定用户登录-root用户-mysql当中权限最高的-管理员用户"><a href="#指定用户登录-root用户-mysql当中权限最高的-管理员用户" class="headerlink" title="指定用户登录 root用户 mysql当中权限最高的 管理员用户"></a>指定用户登录 root用户 mysql当中权限最高的 管理员用户</h3><h4 id="用户名root登录"><a href="#用户名root登录" class="headerlink" title="用户名root登录"></a>用户名root登录</h4><pre><code># &gt; mysql -uroot -p# 初始化没有密码的时候 直接按回车键进入数据库# mysql&gt; select user();</code></pre><h3 id="在输入sql语句的过程中-如果想要放弃本条语句-c"><a href="#在输入sql语句的过程中-如果想要放弃本条语句-c" class="headerlink" title="在输入sql语句的过程中 如果想要放弃本条语句 \c"></a>在输入sql语句的过程中 如果想要放弃本条语句 \c</h3><h4 id="设置密码"><a href="#设置密码" class="headerlink" title="设置密码"></a>设置密码</h4><pre><code># mysql&gt; set password = password(&apos;123&apos;);</code></pre><h4 id="创建用户-create-user"><a href="#创建用户-create-user" class="headerlink" title="创建用户 create user"></a>创建用户 create user</h4><pre><code># create user &apos;alex&apos;@&apos;192.168.16.*&apos; identified by &apos;123&apos;;# create user &apos;eva&apos;@&apos;%&apos; identified by &apos;123&apos;;# &gt; mysql -ueva -p123 -h 192.168.16.39  远程登录一个mysql服务# 新创建出来的用户eva没有使用数据库的权限</code></pre><h4 id="给新用户授权-grant"><a href="#给新用户授权-grant" class="headerlink" title="给新用户授权 grant"></a>给新用户授权 grant</h4><pre><code># grant 操作(select/all) on &apos;库.表&apos; to &apos;用户&apos;@&apos;ip地址&apos;# grant select on &apos;*.*&apos; to &apos;eva&apos;@&apos;%&apos;</code></pre><h4 id="创建用户并授权-grant"><a href="#创建用户并授权-grant" class="headerlink" title="创建用户并授权 grant"></a>创建用户并授权 grant</h4><pre><code># mysql&gt; grant all on *.* to &apos;eva&apos;@&apos;%&apos; identified by &apos;123</code></pre><h4 id="让公司的DBA给你创建用户并且授权"><a href="#让公司的DBA给你创建用户并且授权" class="headerlink" title="让公司的DBA给你创建用户并且授权"></a>让公司的DBA给你创建用户并且授权</h4><pre><code># 用户名 要哪个库的哪些权限</code></pre><h2 id="3-1处理库"><a href="#3-1处理库" class="headerlink" title="3.1处理库"></a>3.1处理库</h2><h3 id="创建库"><a href="#创建库" class="headerlink" title="创建库"></a>创建库</h3><pre><code>create database 数据库名 [charset utf-8];</code></pre><h3 id="查看库"><a href="#查看库" class="headerlink" title="查看库"></a>查看库</h3><pre><code>show databases;</code></pre><h3 id="修改库"><a href="#修改库" class="headerlink" title="修改库"></a>修改库</h3><pre><code>alter database 数据库的名字  你要修改的内容;</code></pre><h3 id="删除库"><a href="#删除库" class="headerlink" title="删除库"></a>删除库</h3><pre><code>drop database 数据库名;</code></pre><h2 id="3-2-处理表"><a href="#3-2-处理表" class="headerlink" title="3.2 处理表"></a>3.2 处理表</h2><h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><h3 id="mysql-gt-create-table-表的名字"><a href="#mysql-gt-create-table-表的名字" class="headerlink" title="mysql&gt; create table 表的名字 ("></a>mysql&gt; create table 表的名字 (</h3><pre><code>                    # 列1的名字 数据类型，                    # 列2的名字 数据类型，                    # ...                    # );create table class(id int not null unique, caption varchar(20)); </code></pre><h4 id="增加表内容"><a href="#增加表内容" class="headerlink" title="增加表内容"></a>增加表内容</h4><pre><code>1：插入单行insert into staff_info (id,name,age,sex,phone,job) values (1,&apos;Alex&apos;,83,&apos;female&apos;,&apos;13651054608&apos;,&apos;IT&apos;);2：插入多行# mysql&gt; insert into staff_info values -&gt; (2,&apos;Egon&apos;,26,&apos;male&apos;,&apos;13304320533&apos;,&apos;Tearcher&apos;), -&gt; (3,&apos;nezha&apos;,25,&apos;male&apos;,&apos;13332353222&apos;,&apos;IT&apos;), -&gt; (4,&apos;boss_jin&apos;,40,&apos;male&apos;,&apos;13332353333&apos;,&apos;IT&apos;);3: 范围测试 有符号和无符号mysql&gt; create table t6 (id1 int(4),id2 int unsigned);mysql&gt; insert into t6 values (123,2147483648);</code></pre><h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><pre><code>1.1查看表结构mysql&gt; desc staff_info;</code></pre><p>   1.2 查询固定表头<br>     select name,age from staff_info;</p><h1 id="三：数据类型"><a href="#三：数据类型" class="headerlink" title="三：数据类型"></a>三：数据类型</h1><h2 id="时间类型"><a href="#时间类型" class="headerlink" title="时间类型"></a>时间类型</h2><h3 id="date-描述年月日"><a href="#date-描述年月日" class="headerlink" title="date      描述年月日"></a>date      描述年月日</h3><h3 id="datetime-描述年月日时分秒"><a href="#datetime-描述年月日时分秒" class="headerlink" title="datetime  描述年月日时分秒"></a>datetime  描述年月日时分秒</h3><h3 id="timestamp字段默认不为空"><a href="#timestamp字段默认不为空" class="headerlink" title="timestamp字段默认不为空"></a>timestamp字段默认不为空</h3><h3 id="DATETIME、DATE、TIMESTAMP、TIME和YEAR。"><a href="#DATETIME、DATE、TIMESTAMP、TIME和YEAR。" class="headerlink" title="DATETIME、DATE、TIMESTAMP、TIME和YEAR。"></a>DATETIME、DATE、TIMESTAMP、TIME和YEAR。</h3><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="CHAR-0-255字节-定长字符串"><a href="#CHAR-0-255字节-定长字符串" class="headerlink" title="CHAR    0-255字节    定长字符串"></a>CHAR    0-255字节    定长字符串</h3><pre><code>定长 浪费磁盘 存取速度非常快</code></pre><h2 id="VARCHAR-0-65535-字节-变长字符串"><a href="#VARCHAR-0-65535-字节-变长字符串" class="headerlink" title="VARCHAR    0-65535 字节    变长字符串"></a>VARCHAR    0-65535 字节    变长字符串</h2><pre><code>变长 节省磁盘空间 存取速度相对慢char(5)     &apos;  abc&apos;  5   &apos;abcde&apos;  5这一列数据的长度变化小  手机号 身份证号 学号频繁存取、对效率要求高短数据varchar(5)  &apos;3abc&apos;   4   &apos;5abcde&apos; 6这一列的数据长度变化大  name  描述信息对效率要求相对小相对长</code></pre><h2 id="ENUM和SET类型"><a href="#ENUM和SET类型" class="headerlink" title="ENUM和SET类型"></a>ENUM和SET类型</h2><h3 id="ENUM"><a href="#ENUM" class="headerlink" title="ENUM"></a>ENUM</h3><pre><code>大小： 对1-255个成员的枚举需要1个字节存储;对于255-65535个成员，需要2个字节存储;最多允许65535个成员。用途： 单选：选择性别</code></pre><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><pre><code>create table t2 (name char(20),gender enum(&apos;男&apos;, &apos;女&apos;)); 插入gender选项不能插入两个值</code></pre><h3 id="SET"><a href="#SET" class="headerlink" title="SET"></a>SET</h3><pre><code>大小 ：1-8个成员的集合，占1个字节9-16个成员的集合，占2个字节17-24个成员的集合，占3个字节25-32个成员的集合，占4个字节 33-64个成员的集合，占8个字节用途 ：多选：兴趣爱好</code></pre><h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><pre><code>create table t11 (name char(20),hobby set(&apos;抽烟&apos;,&apos;喝酒&apos;,&apos;烫头&apos;,&apos;翻车&apos;));不能插入set 范围外的词 会报错</code></pre><h3 id="表的完整性约束"><a href="#表的完整性约束" class="headerlink" title="表的完整性约束"></a><strong>表的完整性约束</strong></h3><h4 id="not-noll"><a href="#not-noll" class="headerlink" title="not noll"></a>not noll</h4><pre><code>非空约束，指定某列不能为空；create table t12 (id int not null); //若是为空报错</code></pre><h4 id="default"><a href="#default" class="headerlink" title="default"></a>default</h4><pre><code>创建列时可以指定默认值，当插入数据时如果未主动设置，则自动添加默认值create table t13 (id1 int not null,id2 int not null default 222);</code></pre><h4 id="unique"><a href="#unique" class="headerlink" title="unique"></a>unique</h4><h5 id="唯一约束，指定某列或者几列组合不能重复"><a href="#唯一约束，指定某列或者几列组合不能重复" class="headerlink" title="唯一约束，指定某列或者几列组合不能重复"></a>唯一约束，指定某列或者几列组合不能重复</h5><pre><code>create table t3(id int unique, name char(20));插入相同的值会报错</code></pre><h5 id="指定某个属性为唯一"><a href="#指定某个属性为唯一" class="headerlink" title="  指定某个属性为唯一  "></a><strong>  指定某个属性为唯一  </strong></h5><pre><code>create table t4(id int unique, name char(20) unique(name));</code></pre><h5 id="not-null-和-unique-联合"><a href="#not-null-和-unique-联合" class="headerlink" title="not null 和 unique 联合"></a>not null 和 unique 联合</h5><pre><code>create table t1(id int not null unique);</code></pre><h4 id="指定多键联合"><a href="#指定多键联合" class="headerlink" title="指定多键联合"></a><strong>指定多键联合</strong></h4><pre><code>create table t5(id int, name char(20), unique(id, name));</code></pre><h4 id="primary-key"><a href="#primary-key" class="headerlink" title="primary key"></a>primary key</h4><h5 id="主键为了保证表中的每一条数据的该字段都是表格中的唯一值"><a href="#主键为了保证表中的每一条数据的该字段都是表格中的唯一值" class="headerlink" title="主键为了保证表中的每一条数据的该字段都是表格中的唯一值"></a>主键为了保证表中的每一条数据的该字段都是表格中的唯一值</h5><h4 id="第一种："><a href="#第一种：" class="headerlink" title="第一种："></a>第一种：</h4><pre><code>not null+unique</code></pre><h4 id="第二种：-primary-key"><a href="#第二种：-primary-key" class="headerlink" title="第二种： primary key"></a>第二种： primary key</h4><pre><code>create table t7(id int primary key,name char(20));</code></pre><h4 id="第三种：在所有字段后单独定义primary-key"><a href="#第三种：在所有字段后单独定义primary-key" class="headerlink" title="第三种：在所有字段后单独定义primary key"></a>第三种：在所有字段后单独定义primary key</h4><pre><code>create table t6(id int,name char(20), primary key(id));</code></pre><h4 id="第四种：给已建成的表添加主键"><a href="#第四种：给已建成的表添加主键" class="headerlink" title="第四种：给已建成的表添加主键"></a>第四种：给已建成的表添加主键</h4><pre><code>alter table department4 modify id int primary key;</code></pre><h4 id="第五种：多字段主键"><a href="#第五种：多字段主键" class="headerlink" title="第五种：多字段主键"></a>第五种：多字段主键</h4><pre><code>create table t8(id int, name char(20), primary key(id, name));</code></pre><h3 id="AUTO-INCREMENT"><a href="#AUTO-INCREMENT" class="headerlink" title="AUTO_INCREMENT"></a>AUTO_INCREMENT</h3><h5 id="约束字段为自动增长，被约束的字段必须同时被key约束"><a href="#约束字段为自动增长，被约束的字段必须同时被key约束" class="headerlink" title="约束字段为自动增长，被约束的字段必须同时被key约束"></a>约束字段为自动增长，被约束的字段必须同时被key约束</h5><h4 id="不指定id，则自动增长，-对于自增的字段，在用delete删除后，再插入值，该字段仍按照删除前的位置继续增长"><a href="#不指定id，则自动增长，-对于自增的字段，在用delete删除后，再插入值，该字段仍按照删除前的位置继续增长" class="headerlink" title="不指定id，则自动增长， 对于自增的字段，在用delete删除后，再插入值，该字段仍按照删除前的位置继续增长"></a>不指定id，则自动增长， 对于自增的字段，在用delete删除后，再插入值，该字段仍按照删除前的位置继续增长</h4><pre><code>create table student(id int primary key auto_increment,    name varchar(20),    sex enum(&apos;male&apos;,&apos;female&apos;) default &apos;male&apos;    );</code></pre><h4 id="foreign-key"><a href="#foreign-key" class="headerlink" title="foreign key"></a>foreign key</h4><h4 id="当设置字段为unique唯一字段时，设置该字段为外键才可以成功"><a href="#当设置字段为unique唯一字段时，设置该字段为外键才可以成功" class="headerlink" title="当设置字段为unique唯一字段时，设置该字段为外键才可以成功"></a>当设置字段为unique唯一字段时，设置该字段为外键才可以成功</h4><h4 id="设置外键"><a href="#设置外键" class="headerlink" title="设置外键"></a>设置外键</h4><pre><code>create table staff_info (s_id int,    name varchar(20),    dep_id int,    foreign key(dep_id) references departments(dep_id)); #departments(dep_id)) 外表ID</code></pre><h4 id="给予表权限，-外表删除，本表也跟新"><a href="#给予表权限，-外表删除，本表也跟新" class="headerlink" title="给予表权限， 外表删除，本表也跟新"></a>给予表权限， 外表删除，本表也跟新</h4><pre><code>on delete cascade  # 连级删除on update cascade # 连级更新</code></pre><h1 id="表简单增删改查"><a href="#表简单增删改查" class="headerlink" title="表简单增删改查"></a>表简单增删改查</h1><h2 id="表的查看"><a href="#表的查看" class="headerlink" title="表的查看"></a>表的查看</h2><h3 id="describe-staff-info"><a href="#describe-staff-info" class="headerlink" title="describe staff_info;"></a>describe staff_info;</h3><pre><code>查看表结构</code></pre><h3 id="desc-staff-info"><a href="#desc-staff-info" class="headerlink" title="desc staff_info;"></a>desc staff_info;</h3><pre><code>查看表结构</code></pre><h3 id="show-create-table-staff-info-G"><a href="#show-create-table-staff-info-G" class="headerlink" title="show create table staff_info\G;"></a>show create table staff_info\G;</h3><pre><code>查看表结构</code></pre><h2 id="修改表结构"><a href="#修改表结构" class="headerlink" title="修改表结构"></a>修改表结构</h2><h3 id="修改表名字"><a href="#修改表名字" class="headerlink" title="修改表名字"></a>修改表名字</h3><pre><code>alter table t1 rename t4_1;//alter table (修改的表) rename （新的表名字）；</code></pre><h3 id="增加字段"><a href="#增加字段" class="headerlink" title="增加字段"></a>增加字段</h3><pre><code>alter table t4_1 add age int, add sex char(3);//alter table t4_1 add (字段的属性), add (字段属性);</code></pre><h3 id="删除字段"><a href="#删除字段" class="headerlink" title="删除字段"></a>删除字段</h3><pre><code>alter table t4_1 drop sex;//alter table （操作的表） drop （字段名字）;</code></pre><h3 id="修改字段"><a href="#修改字段" class="headerlink" title="修改字段"></a>修改字段</h3><pre><code>alter table t4_1 modiey name char(20) not null;//alter table (表名字) modiey （字段） （数据类型） （约束条件）;#修改字段的名字alter table t4_1 change name myname int not null;//alter table 表名 change 原表名字 新的名字 数据类型 约束条件;</code></pre><h3 id="修改字段排列顺序-在增加的时候指定字段位置"><a href="#修改字段排列顺序-在增加的时候指定字段位置" class="headerlink" title="修改字段排列顺序/在增加的时候指定字段位置"></a>修改字段排列顺序/在增加的时候指定字段位置</h3><h4 id="给表首位字段插入一个"><a href="#给表首位字段插入一个" class="headerlink" title="给表首位字段插入一个"></a>给表首位字段插入一个</h4><pre><code>alter table t4_1 add key_id int not null first;//alter table 表 add 新的字段 数据类型 约束条件 first; #first代表首位</code></pre><h3 id="给表固定位字段插入一个"><a href="#给表固定位字段插入一个" class="headerlink" title="给表固定位字段插入一个"></a>给表固定位字段插入一个</h3><pre><code>alter table t4_1 add key_id int not null after id;//alter table 表 add 新的字段 数据类型 约束条件 after; #after 在那个字段之后</code></pre><h3 id="修改字段名，-并且移动到固定位置"><a href="#修改字段名，-并且移动到固定位置" class="headerlink" title="修改字段名， 并且移动到固定位置"></a>修改字段名， 并且移动到固定位置</h3><pre><code>alter table t4_1 change id_new id_n int first;alter table t4_1 change id_n id_new int after id; #那个字段后面//alter table 表名 change 要修改的字段 新的字段 数据类型 约束条件 first; </code></pre><h3 id="修改字段的位置"><a href="#修改字段的位置" class="headerlink" title="修改字段的位置"></a>修改字段的位置</h3><pre><code>alter table t4_1 modify  age int  after id;//alter table 表名 modify  字段名 属性 after 字段名;</code></pre><h2 id="表的删除"><a href="#表的删除" class="headerlink" title="表的删除"></a>表的删除</h2><pre><code>drop table t4_1;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一：数据库在未来的开发的地位&quot;&gt;&lt;a href=&quot;#一：数据库在未来的开发的地位&quot; class=&quot;headerlink&quot; title=&quot;一：数据库在未来的开发的地位&quot;&gt;&lt;/a&gt;一：数据库在未来的开发的地位&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;# 后台/后端
    # 
      
    
    </summary>
    
      <category term="mysql" scheme="http://yoursite.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>明天会更好</title>
    <link href="http://yoursite.com/2018/10/03/%E5%8A%AA%E5%8A%9B%E5%89%8D%E8%A1%8C/"/>
    <id>http://yoursite.com/2018/10/03/努力前行/</id>
    <published>2018-10-03T13:37:18.000Z</published>
    <updated>2018-10-03T14:08:41.807Z</updated>
    
    <content type="html"><![CDATA[<p>#分析自身现状<br>  最近一直以来状态不太好， 感觉学习没有刚开始学习的时候好了。最要表现在一下几个方面</p><p>1.学习热度没有开始学习的时候好<br>2.学习效率低，分心程序高，不够专注<br>3.个人作息有严重的问题<br>4.上课不注意听讲， 下课总结不到位<br>5.今后的问题应该是多注意总结学习新的知识</p><p>#个人问题<br>一直以来都很胖， 也健过身最后也有好的效果。但是过后又恢复一前模样，总结原因是没有坚持。成功路上的多数难题是不够坚持，这是我发现自身的问题的根本所在。固然懒惰是人的天性， 一直以来自己都想改变自己，我考虑良久想从跑步做起，培养自己的意志力。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#分析自身现状&lt;br&gt;  最近一直以来状态不太好， 感觉学习没有刚开始学习的时候好了。最要表现在一下几个方面&lt;/p&gt;
&lt;p&gt;1.学习热度没有开始学习的时候好&lt;br&gt;2.学习效率低，分心程序高，不够专注&lt;br&gt;3.个人作息有严重的问题&lt;br&gt;4.上课不注意听讲， 下课总结不到
      
    
    </summary>
    
      <category term="个人感想" scheme="http://yoursite.com/categories/%E4%B8%AA%E4%BA%BA%E6%84%9F%E6%83%B3/"/>
    
    
      <category term="珍惜" scheme="http://yoursite.com/tags/%E7%8F%8D%E6%83%9C/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2018/10/02/hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2018/10/02/hexo个人博客搭建整理/</id>
    <published>2018-10-02T13:07:50.989Z</published>
    <updated>2018-10-02T13:56:46.704Z</updated>
    
    <content type="html"><![CDATA[<p>#一什么是 Hexo？<br>    官方解释说Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。<br>    也就是说Hexo是一款能够帮助我们快速构建博客的轻型框架。但是如何使用Hexo呢？<br>    如标题所言，我们是结合GitHub来使用Hexo,因此在创建博客的过程中我们就可以分成两个部分，GitHub准备工作和Hexo搭建工作<br><strong>注：实例运行环境为Windos,教程较为浅显，读者可根据个人实际情况选择性阅读该教程</strong></p><p>##安装主要配置软件<br>1： Node.js :<a href="http://nodejs.cn/download/" title="Node.js" target="_blank" rel="noopener">http://nodejs.cn/download/</a></p><p>2：Git（前往下载）<a href="https://git-scm.com/downloads" title="Git（前往下载）" target="_blank" rel="noopener">https://git-scm.com/downloads</a></p><ol start="3"><li>安装hexo看到这么多安装，千万不要紧张，一定要稳住，别怕，因为后面的东西都是在gitbash中用npm工具安装就好了。先创建一个文件（用来存放所有blog的东西），然后cd到该文件夹下。</li><li>安装hexo命令：npm i -g hexo安装完成后，查看版本：<br> <img src="https://i.imgur.com/FoaoPPl.png" alt=""></li></ol><pre><code>* 解释一下：node_modules：是依赖包        * public：存放的是生成的页面        * scaffolds：命令生成文章等的模板        * source：用命令创建的各种文章        * themes：主题        * _config.yml：整个博客的配置        * db.json：source解析所得到的        * package.json：项目所需模块项目的配置信息</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#一什么是 Hexo？&lt;br&gt;    官方解释说Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。&lt;br&gt;    也就是说Hexo是一款能够帮助我们快速构建博客的轻型框架。但是如
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>操作系统和进程的基础概念</title>
    <link href="http://yoursite.com/2018/10/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <id>http://yoursite.com/2018/10/02/操作系统与进程的基础概念/</id>
    <published>2018-10-02T04:24:39.008Z</published>
    <updated>2018-10-03T10:33:57.030Z</updated>
    
    <content type="html"><![CDATA[<p>#操作系统的发展史</p><p>##手工操作 —— 穿孔卡片      </p><p>###手工操作的两个特点：<br>    1：用户独占全机， 不会出现因资源一杯其他用户占用而等待的现象， 但是资源利用率低<br>    2：cup等待手工操作。 CPU的利用不充分</p><p>##批处理 —— 磁带存储和批处理系统、</p><p>###批处理系统：加载在计算机上的一个系统软件， 在他的控制下， 计算机能够自动的， 成批地处理有个或者多个用户的作业</p><p>###卫星机：<br>    一台不与主机直接相连而用于输出输入设备打交道<br>    其功能：<br>        1：输入机上读取用户作业并放到磁带上<br>        2：从输入磁带上读取执行结果给打印机<br>    不足：每次主机内存中仅存放到一道作业， 每当它运行期间输入、输出请求后， 高速的CPU变处于等待低速的IO完成状态致使CPU空闲</p><p>##多道程序系统<br><img src="https://i.imgur.com/DU9G0m7.png" alt=""></p><p>###所谓的多道程序设计技术， 就是指允许多个程序进入内存并允许。 即把多个程序放入内存。他们在内存中交替运行。共享系统资源。一道程序运行结束立马转向去另一个。</p><p>###单机处理系统中的多道程序运行的特点：<br>    1：多道：计算机内部放入多道程序<br>    2:宏观上的并行： 同时进入系统的几道程序都处于运行过程中，都开始运行，但都为运行完毕<br>    3：微观上串性：各道程序轮流的用CPU， 交替运行</p><p>##多道批处理系统</p><p>##分时系统</p><p>##实时系统</p><p>##通用操作系统</p><p>##操作系统的进一步发展</p><p>##操作系统的作用</p><p>I/O ：input 进入内存的过程就是输入<br>    ：ouput 数据从内存从内存出去的过程就是输出 （写文件， dump， send）</p><p>##多道操作系统<br>    可以有多个程序在操作系统中执行<br>    当一个程序遇到IO操作时候就把CPU让出来给其他程序</p><p>###分时操作系统</p><pre><code>#时间片 特别短的时间#不是遇到IO的时候才让出CPU， 而是时间到了就将CPU让出来#切换要占时间：单纯的分时系统没有提高CPU的利用率                提高了用户体验</code></pre><p>###实时系统</p><p>###个人计算机<br>    python celery 分布式计算</p><p>##进程 Process id = pid<br>程序  进程<br>pid 是全系统</p><p>进程是操作系统最小的资源分配单位</p><p>资源分配  — 内存 寄存器</p><p>多级反馈附列<br>    先把短的执行， 长任务放到队列下面</p><p>同步阻塞： 不能充分利用CPU<br>异步非阻塞： 过度利用CPU</p><p>IO多路复用：比较完善的在网络编程中的解决方案</p><h2 id="if-name-‘name‘"><a href="#if-name-‘name‘" class="headerlink" title="if name == ‘name‘:"></a>if <strong>name</strong> == ‘<strong>name</strong>‘:</h2><pre><code>只有在winds上才需要</code></pre><p>1：父进程和子进程的启动时异步的<br>父进程只负责通知操作系统启动子进程<br>接下来的工作由操作系统接手，父进程继续执行<br>2：父进程执行完毕后并不会直接结束程序<br>而是等待所有的子进程都执行完毕后才结束<br>父进程要负责回收子进程的资源</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#操作系统的发展史&lt;/p&gt;
&lt;p&gt;##手工操作 —— 穿孔卡片      &lt;/p&gt;
&lt;p&gt;###手工操作的两个特点：&lt;br&gt;    1：用户独占全机， 不会出现因资源一杯其他用户占用而等待的现象， 但是资源利用率低&lt;br&gt;    2：cup等待手工操作。 CPU的利用不充分
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>socke</title>
    <link href="http://yoursite.com/2018/10/02/socket/"/>
    <id>http://yoursite.com/2018/10/02/socket/</id>
    <published>2018-10-02T04:24:38.992Z</published>
    <updated>2018-10-03T10:33:43.888Z</updated>
    
    <content type="html"><![CDATA[<p>#1：网络编程之socketserver</p><p>###1:首先socketserver 服务器调用socketserver 模块</p><p>###2:继承了socketserver.BaseRequestHandler</p><p>###3:在父类的基础上重写了handle</p><p>##下面是一个简单的文件登录文件上传的例子</p><p>###server端<br>    import socketserver<br>    import json<br>    import struct<br>    import socket</p><pre><code>class MyTCPHandler(socketserver.BaseRequestHandler):def handle(self):    flag = self.login_check()    while flag:        try:            self.data = self.request.recv(1024).strip()            print(&apos;{} wrote&apos;.format(self.client_address[0]))            print(self.data)            self.request.send(self.data.upper())            print(self.data.decode(&apos;utf-8&apos;))            if self.data.decode(&apos;utf-8&apos;) == &apos;2&apos;:                self.uploading()        except ConnectionResetError as e:            print(&apos;error&apos;, e)            breakdef login_check(self):    dic_user = {        &apos;name&apos;: &apos;qwer&apos;,        &apos;pwad&apos;: &apos;1234&apos;    }    dic_clinet = self.request.recv(1024).strip()    dic_clinet = json.loads(dic_clinet)    print(dic_clinet)    if dic_user[&apos;name&apos;] == dic_clinet[&apos;name&apos;] and \            dic_user[&apos;pwad&apos;] == dic_clinet[&apos;pwad&apos;]:        self.request.send(b&apos;True&apos;)        return Truedef uploading(self):    &apos;&apos;&apos;接受上传文件&apos;&apos;&apos;    ret = self.request.recv(1024)    dic_client = json.loads(ret)    print(dic_client)    self.request.send(b&apos;Start To upload&apos;)    print(&apos;Start the download&apos;)    size = dic_client[&apos;size&apos;]    with open(dic_client[&apos;filename&apos;],&apos;wb&apos;) as f:        while size:            ret = self.request.recv(1024)            f.write(ret)            size -= len(ret)    print(&apos;下载完毕！&apos;)if __name__ == &apos;__main__&apos;:    Host, port = &apos;127.0.0.1&apos;, 9999    # sever = socketserver.TCPServer((Host, port), MyTCPHandler)    sever = socketserver.ThreadingTCPServer((Host, port), MyTCPHandler)    sever.serve_forever()</code></pre><p>###client端</p><pre><code>import socketimport jsonimport osimport sysimport time#进度条import timefrom tqdm import tqdm# for i in tqdm(range(100)):#     time.sleep(0.05)def processBar(num, total):    rate = num / total    rate_num = int(rate * 100)    if rate_num == 100:        r = &apos;\r%s&gt;%d%%\n&apos; % (&apos;|&apos; * rate_num, rate_num,)    else:        r = &apos;\r%s&gt;%d%%&apos; % (&apos;|&apos; * rate_num, rate_num,)    sys.stdout.write(r)    sys.stdout.flushclass Client():    &apos;&apos;&apos;客户端&apos;&apos;&apos;    cmd_list = [        (&apos;下载文件&apos;, &apos;ncftpget&apos;),        (&apos;上传文件&apos;, &apos;upload&apos;),        (&apos;切换目录&apos;, &apos;chdir&apos;),        (&apos;创建目录&apos;, &apos;create_directory&apos;),        (&apos;删除文件或者目录&apos;,&apos;expurgate &apos;),    ]    def __init__(self):        self.client = socket.socket() #实例socket对象    def connect(self, ip, port):        &apos;&apos;&apos;绑定端口&apos;&apos;&apos;        self.client.connect((ip, port))    def logon(self):        &apos;&apos;&apos;用户登录&apos;&apos;&apos;        name = input(&apos;user_name:&apos;)        pawd = input(&apos;passwork:&apos;)        user_dic = {            &apos;name&apos;: name,            &apos;pwad&apos;: pawd        }        self.client.send(json.dumps(user_dic).encode(&apos;utf-8&apos;))        ret = self.client.recv(1024).decode(&apos;utf-8&apos;)        print(ret)        return ret    def User_input(self):        flag = self.logon()        name_path = &apos;/home/&apos;        while flag:            for index, val in enumerate(self.cmd_list, 1):                print(&apos;%s  %s&apos;%(index, val[0]))            inp = input(&apos;%s:&apos;%name_path)            self.client.send(inp.encode(&apos;utf-8&apos;))            ret = self.client.recv(1024).decode(&apos;utf-8&apos;)            if inp == &apos;2&apos;:                self.upload()        else:            print(&apos;密码错误！&apos;)    def ncftpget(self):        &apos;&apos;&apos;下载文件&apos;&apos;&apos;    def upload(self):        &apos;&apos;&apos;上传文件&apos;&apos;&apos;        path_name = r&apos;G:\python笔记\Pythonjing\day18\video\01 深圳校区 python fullstuck 1期 day18 内容回顾.mp4&apos;        size = os.path.getsize(path_name)        print(size)        total = size        dic_user = {            &apos;means&apos;: &apos;uploading&apos;,            &apos;filename&apos;: &apos;test.mp4&apos;,            &apos;size&apos;: size,        }        self.client.send(json.dumps(dic_user).encode(&apos;utf-8&apos;))        ret = self.client.recv(1024)        print(ret)        with open(path_name, &apos;rb&apos;) as f:            count = 0            time_old = time.clock()            pbar = tqdm(total=size)            while size:                data = f.read(1024)                self.client.send(data)                size -= len(data)                count += len(data)                pbar.update(len(data)) #进度条                # processBar(count, total) #进度条            time_new = time.clock()            pbar.close()            print(&apos;上传完毕！一个用时%s秒&apos;%int(time_new - time_old))    def chdir(self):        &apos;&apos;&apos;切换目录&apos;&apos;&apos;    def create_directory(self):        &apos;&apos;&apos;创建目录&apos;&apos;&apos;    def expurgate(self):        &apos;&apos;&apos;删除文件或者文件夹&apos;&apos;&apos;if __name__ == &apos;__main__&apos;:    # Host, port = &apos;127.0.0.1&apos;, 9999    Host, port = &apos;192.168.16.46&apos;, 9999    cl = Client()    cl.connect(Host, port)    cl.User_input()</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#1：网络编程之socketserver&lt;/p&gt;
&lt;p&gt;###1:首先socketserver 服务器调用socketserver 模块&lt;/p&gt;
&lt;p&gt;###2:继承了socketserver.BaseRequestHandler&lt;/p&gt;
&lt;p&gt;###3:在父类的基础上重写
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>multiprocessing模块</title>
    <link href="http://yoursite.com/2018/10/02/multiprocess%E8%BF%9B%E7%A8%8B-%E9%94%81-%E4%BF%A1%E5%8F%B7%E9%87%8F-%E4%BA%8B%E4%BB%B6/"/>
    <id>http://yoursite.com/2018/10/02/multiprocess进程-锁-信号量-事件/</id>
    <published>2018-10-02T04:24:38.979Z</published>
    <updated>2018-10-03T10:32:42.931Z</updated>
    
    <content type="html"><![CDATA[<p>##1.1：process模块介绍</p><p>###具体方法<br>    p.start()：启动进程，并调用该子进程中的p.run()<br>    p.run():进程启动时运行的方法，正是它去调用target指定的函数，我们自定义类的类中一定要实现该方法<br>    p.terminate():强制终止进程p，不会进行任何清理操作，如果p创建了子进程，该子进程就成<br>    了僵尸进程，使用该方法需要特别小心这种情况。如果p还保存了一个锁那么也将不会被释放，进而导致死锁<br>    p.is_alive():如果p仍然运行，返回True<br>    p.join([timeout]):主线程等待p终止（强调：是主线程处于等的状态，而p是处于运行的状态）。<br>    timeout是可选的超时时间，需要强调的是，p.join只能join住start开启的进程，而不能join住run开启的进程  </p><p>###具体实现<br>    p.daemon：默认值为False，如果设为True，代表p为后台运行的守护进程，当p的父进程终止时，p也随之终止，并且设定为True后，p不能创建自己的新进程，必须在p.start()之前设置<br>    p.name:进程的名称<br>    p.pid：进程的pid<br>    p.exitcode:进程在运行时为None、如果为–N，表示被信号N结束(了解即可)<br>    p.authkey:进程的身份验证键,默认是由os.urandom()随机生成的32字符的字符串。这个键的用途是为涉及网络连接的底层进程间通信提供安全性，这类连接只有在具有相同的身份验证键时才能成功（了解即可）</p><p>###具体代码<br>    import os<br>    from multiprocessing import Process</p><pre><code>def f(x):    print(&apos;子进程id ：&apos;,os.getpid(),&apos;父进程id ：&apos;,os.getppid())    #查看主进程和子进程的进程号    return x*xif __name__ == &apos;__main__&apos;:    print(&apos;主进程id ：&apos;, os.getpid())    p_lst = []    for i in range(5):        p = Process(target=f, args=(i,))        p.start()</code></pre><p>##1.2：守护进程</p><pre><code>会随着主进程的结束而结束。主进程创建守护进程　　其一：守护进程会在主进程代码执行结束后就终止　　其二：守护进程内无法再开启子进程,否则抛出异常：AssertionError: daemonic processes are not allowed to have children注意：进程之间是互相独立的，主进程代码运行结束，守护进程随即终止</code></pre><p>###具体代码<br>    from multiprocessing import Process<br>    import time<br>    def fun():<br>        while 1:<br>            print(‘守护进程’)<br>            time.sleep(1)<br>    if <strong>name</strong> == ‘<strong>main</strong>‘:<br>        p = Process(target= fun)<br>        p.daemon = True<br>        p.start()<br>        time.sleep(5) #主进程结束守护进程结束</p><p>##1.3：multiprocess.Lock</p><pre><code>#加锁可以保证多个进程修改同一块数据时，同一时间只能有一个任务可以进行修改，即串行的修改，没错，速度是慢了，但牺牲了速度却保证了数据安全。虽然可以用文件共享数据实现进程间通信，但问题是：1.效率低（共享数据基于文件，而文件是硬盘上的数据）2.需要自己加锁处理#因此我们最好找寻一种解决方案能够兼顾：1、效率高（多个进程共享一块内存的数据）2，我们处理好锁问题。这就是mutiprocessing模块为我们提供的基于消息的IPC通信机制：队列和管道。队列和管道都是将数据存放于内存中队列又是基于（管道+锁）实现的，可以让我们从复杂的锁问题中解脱出来，我们应该尽量避免使用共享数据，尽可能使用消息传递和队列，避免处理复杂的同步和锁问题，而且在进程数目增多时，往往可以获得更好的可获展性。</code></pre><p>###抢票的例子</p><pre><code>#文件db的内容为：{&quot;count&quot;:1}#注意一定要用双引号，不然json无法识别#并发运行，效率高，但竞争写同一文件，数据写入错乱from multiprocessing import Process,Lockimport time,json,randomdef search():    dic=json.load(open(&apos;db&apos;))    print(&apos;\033[43m剩余票数%s\033[0m&apos; %dic[&apos;count&apos;])def get():    dic=json.load(open(&apos;db&apos;))    time.sleep(0.1) #模拟读数据的网络延迟    if dic[&apos;count&apos;] &gt;0:        dic[&apos;count&apos;]-=1        time.sleep(0.2) #模拟写数据的网络延迟        json.dump(dic,open(&apos;db&apos;,&apos;w&apos;))        print(&apos;\033[43m购票成功\033[0m&apos;)def task():    search()    get()if __name__ == &apos;__main__&apos;:    for i in range(100): #模拟并发100个客户端抢票        p=Process(target=task)        p.start()</code></pre><p>##multiprocess.Semaphore<br>    斥锁同时只允许一个线程更改数据，而信号量Semaphore是同时允许一定数量的线程更改数据 。<br>    假设商场里有4个迷你唱吧，所以同时可以进去4个人，如果来了第五个人就要在外面等待，等到有人出来才能再进去玩。<br>    实现：<br>    信号量同步基于内部计数器，每调用一次acquire()，计数器减1；每调用一次release()，计数器加1.<br>    当计数器为0时，acquire()调用被阻塞。这是迪科斯彻（Dijkstra）信号量概念P()和V()Python实现。信号量同步机制适用于访问像服务器这样的有限资源。<br>    信号量与进程池的概念很像，但是要区分开，信号量涉及到加锁的概念</p><p>###具体例子（进KTV）<br>    from multiprocessing import Process,Semaphore<br>    import time,random</p><pre><code>def go_ktv(sem,user):    sem.acquire()    print(&apos;%s 占到一间ktv小屋&apos; %user)    time.sleep(random.randint(0,3)) #模拟每个人在ktv中待的时间不同    sem.release()if __name__ == &apos;__main__&apos;:    sem=Semaphore(4)    p_l=[]    for i in range(13):        p=Process(target=go_ktv,args=(sem,&apos;user%s&apos; %i,))        p.start()        p_l.append(p)    for i in p_l:        i.join()    print(&apos;============》&apos;)</code></pre><p>##multiprocess.Event</p><p>###介绍<br>    python线程的事件用于主线程控制其他线程的执行，事件主要提供了三个方法 set、wait、clear。</p><pre><code>事件处理的机制：全局定义了一个“Flag”，如果“Flag”值为 False，那么当程序执行 event.wait 方法时就会阻塞，如果“Flag”值为True，那么event.wait 方法时便不再阻塞。clear：将“Flag”设置为Falseset：将“Flag”设置为True</code></pre><p>###红绿灯例子<br>    import time<br>    import random<br>    from multiprocessing import Process,Event<br>    def traffic_light(e):<br>        print(‘\033[31m红灯亮\033[0m’)<br>        while True:<br>            if e.is_set():<br>                time.sleep(2)<br>                print(‘\033[31m红灯亮\033[0m’)<br>                e.clear()<br>            else:<br>                time.sleep(2)<br>                print(‘\033[32m绿灯亮\033[0m’)<br>                e.set()</p><pre><code>def car(e,i):    if not e.is_set():        print(&apos;car %s 在等待&apos; % i)        e.wait()    print(&apos;car %s 通过了&apos;%i)if __name__ == &apos;__main__&apos;:    e = Event()    p = Process(target=traffic_light,args=(e,))    p.daemon = True    p.start()    p_lst = []    for i in  range(20):        time.sleep(random.randrange(0,3,2))        p = Process(target=car,args=(e,i))        p.start()  # car19        p_lst.append(p)    for p in p_lst:p.join()</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##1.1：process模块介绍&lt;/p&gt;
&lt;p&gt;###具体方法&lt;br&gt;    p.start()：启动进程，并调用该子进程中的p.run()&lt;br&gt;    p.run():进程启动时运行的方法，正是它去调用target指定的函数，我们自定义类的类中一定要实现该方法&lt;br&gt;
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
  </entry>
  
</feed>
